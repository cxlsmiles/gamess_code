C 22 Oct 14 - HN - changes for FMO 5.1 
C 21 May 13 - DGF,HN,TN - changes for FMO 5.0
C 19 Oct 12 - MWS - synchronize FRGINF common
C  2 Sep 12 - MWS - synchronize MCINP
C 21 JUN 12 - DGF - changes for FMO 4.3
C 23 MAR 12 - DGF - pad common blocks
C 28 DEC 11 - DGF - pad commons for FMO 4.2
C 15 Apr 11 - MWS - synch FMOPNT common
C 11 Aug 10 - TN  - new module for Hessians in FMO
c
C*MODULE FMOHSS  *DECK FMODEH
C>
C>     @brief Hessian contributions 
C>
C>     @details Accumulates Hessian contributions. 
C>
C>     @author Takeshi Nagata
C>
      SUBROUTINE FMODEH(ida,FCM,fmoddm,FMOFCM,fmopg,iaglob,job)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
      Parameter (MXATM=5000)
CZCZ  common /GRAD  / DE(3,MXATM)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
CZCZ  COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,nfmopcm
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
cz    common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
cz   *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
cz   *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
cz   *                IESDPPC,idoprop,mp2run
      dimension fmopg(3,*),iaglob(*)
      DIMENSION fmoddm(3,3,natfmo),FMOFCM(3*natfmo,*),FCM(3*nat,*)
c
c     gather FMO HESSIAN contributions coming from the analytic gradient of a
c     monomer/dimer.
c
c     Add the contribution from electrostatic potential 
      if(ida.eq.0) return
      da  = ida
      neh = natfmo * natfmo * 9
      if(maswrk) call daxpy(neh,da,FCM,1,FMOFCM,1)
C
      if(nat.lt.0) write(iw,*) fmopg(1,1)
      if(job.eq.1) return
      NC1 = 3*NAT
c
c     Accumulate the dipole derivatives. 
c
      CALL DAREAD(IDAF,IODA,FCM,3*NC1,34,0)

      if(maswrk) then
      da = ida
      do i = 1, nat
        ih  = iaglob(i)
        do k = 1,3
          ii  = 9*(i-1)+(k-1)*3
          do l = 1,3
            fmoddm(l,k,ih) = fmoddm(l,k,ih)+da*fcm(ii+l,1)
c           Here we treat fcm as a linear array of size 3*3*nat.
          end do
        end do
      end do
      endif
c
c     Accumulate the Hessian
c
      CALL DAREAD(IDAF,IODA,FCM,NC1*NC1,4,0)
   
      if(maswrk) then
      da = ida
      do i = 1, nat
        ih  = iaglob(i)
        ii  = 3*(i-1)
        ims = 3*(ih-1)
        do j = 1, nat
          jh  = iaglob(j)
          jj  = 3*(j-1)
          jms = 3*(jh-1)
          do k = 1,3
            do l = 1,3
              fmofcm(ims+k,jms+l)=fmofcm(ims+k,jms+l)+da*fcm(ii+k,jj+l)
            end do
          end do
        end do
      end do
      endif
c
      CALL VCLR(FCM,1,NC1*NC1)
      CALL DAWRIT(IDAF,IODA,FCM,NC1*NC1,4,0)
c
c     No FMO/PCM contribution for separated dimers.
CZCZ  if(nfmopcm.gt.0.and.ifmostp.ne.6.and.ifmostp.ne.7
CZCZ *   .and.IESDPPC.eq.0) call daxpy(natfmo*3,da,fmopg,1,fmode,1)
      return
      end
C*MODULE FMOHSS  *DECK FMOHESSX
C>
C>     @brief FMO Hessian driver
C>
C>     @details Perform FMO Hessian calculations. 
C>
C>     @author Takeshi Nakata
C>
      SUBROUTINE FMOHESSX(VIBOVR,GOTWFN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION METHOD,METHNR
C
      LOGICAL PRTIFC,PURIFY,PROJCT,VIBANL,RDHESS,DECOMP,LINEAR,
     *        GOTEG,GOTEH,GOTDDM,GOTADM,STATPT,SOME,PRTSCN,GOTFRQ,
     *        VIBOVR,GOTWFN,GOPARR,DSKWRK,MASWRK,TEST,
     *        PULCOR,EFLDL,POLAR,HSSEND,SCFOK,REDOVB,OK,FGONLY,
     *        QMMM,MMONLY,CARTSN,CANONC,FCORE,FORS,EKT,LINSER,
     *        MPGRD,CIGRD,DIISON
C
      PARAMETER (MXATM=5000, MXAO=2047, MXPT=100, MXFRG=65,
     *           MXFGPT=2000, MXNORO=250, MAXNFRAGS=10,
     *           MXDFG=1, MXDPPT=MXFRG*MXDFG*12)
      PARAMETER (NNAM=18)
C
      DIMENSION QNAM(NNAM), KQNAM(NNAM), APOL(6), RAMALF(6)
C
      COMMON /CHFINF/ CHFSLV,CPTYPE,NWDCHF,POLAR
      COMMON /EFLDC / EVEC(3),EFLDL
      COMMON /FMCOM / X(1)
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FRGMSS/ FPMASS(MXPT),FMASS(MXFGPT),
     *                FPNUC(MXPT),FGNUC(MXFGPT)
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      COMMON /FUNCT / E,EG(3,MXATM)
      COMMON /GVBWFN/ CICOEF(2,12),F(25),ALPHA(325),BETA(325),NO(10),
     *                NCO,NSETO,NOPEN,NPAIR,NORB,NCONF(MXAO),NHAM
      COMMON /HSSCTL/ IHESSM,IHREP,HSSEND
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /MCINP / METHNR,CISTEP,FINALCI,ACURCY,ENGTOL,DAMP,
     *                MICIT,NWORD,NORBMC,NOROT(2,MXNORO),MOFRZ(15),
     *                NPFLG(10),NOFO,MCFMO,IDIABAT,
     *                CANONC,FCORE,FORS,EKT,LINSER
      COMMON /MIOPT / DTOL,CNVLOC,DIISTL,ALPHAX,
     *                NF(MAXNFRAGS),MF(MAXNFRAGS),NFRAGS,MSHIFT,ITERMI,
     *                ITLOC,IGUESS,MXDIIS,
     *                IOPT,MIFLAG,DIISON
      COMMON /MP2PAR/ OSPT,CODEMP,SCSPT,TOLMP,METHMP,NWDMP2,MEMPRI,
     *                MPPROP,NACORMP,NBCORMP,NOAMP,NOBMP,NORBMP,NBFMP,
     *                NOMITMP,MPCPHF,MAXITCMP
      COMMON /NEOJOB/ NEORUN,NELERM
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMPAR/ IPCM,NFT26,NFT27,IRPPCM,IEF,IP_F,NFMOPCM
      COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
     *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SVPOPT/ ISVP,NSVP,MTHSVP,NCAV,NVLPL,IQP
      COMMON /THERMD/ FREQ(3*MXATM),TEMP(10),SCLFAC,NTEMP,PRTSCN,GOTFRQ
      COMMON /TINOPT/ mparti,MMONLY,QMMM
      COMMON /VBDCMP/ DECOMP,NROW,NDEG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZMAT  / NZMAT,NZVAR,NVAR,NSYMC,LINEAR
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
c
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
C
C     COSMO information
C
      LOGICAL ISEPS,USEPS
      COMMON /ISEPS / ISEPS, USEPS
      LOGICAL COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
      COMMON /COSDAT/ SE2,SECORR,QVCOSMO,ELAST,EMP2COS,EMP2LAST,
     *                COSVOL,COSSAR,EDIEL,EOC1,DEOC_RS,SUMQSC,
     *                SUMQSCOLD,ZSUM,ZSUM2,ZSUM3,FEPSI,RDS,DISEX2,
     *                EPSI,COSRAD,DISEX,OUTCHG,EDIEL_SAVE,
     *                MAXNPS,ICORR,ITRIP,NQS,MP2TRIP,MP2ITER,
     *                ICFREQ,NSPA,NSPH,NPSD,NPS,NPS2,NDEN,NPSPHER,
     *                COSBUG,COSWRT,DCOSMO,PRFCND,IOUTCH
C
      PARAMETER (TOLG=0.0005D+00, ZERO=0.0D+00)
C
C     ----- SET UP NAMELIST SIMULATION -----
C
      DATA FORCE/8HFORCE   /
      DATA QNAM/8HNVIB    ,8HVIBSIZ  ,8HPRTIFC  ,8HPURIFY  ,8HPROJCT  ,
     *          8HMETHOD  ,8HVIBANL  ,8HRDHESS  ,8HDECOMP  ,8HSCLFAC  ,
     *          8HTEMP    ,8HFREQ    ,8HPRTSCN  ,8HNPRT    ,8HNPUN    ,
     *          8HPULCOR  ,8HTEST    ,8HREDOVB  /
      DATA KQNAM/1,3,0,0,0,5,0,0,0,3,103,-3,0,1,1,0,0,0/
C
      DATA HSSIAN/8HHESSIAN /
      DATA GAMMA/8HGAMMA    /
      DATA ANAL,SNUM,FNUM,RNUM
     *      /8HANALYTIC,8HSEMINUM ,8HFULLNUM ,8HNUMERIC /
      DATA RHF,ROHF,UHF/8HRHF     ,8HROHF    ,8HUHF     /
      DATA      GVB,RMC/8HGVB     ,8HMCSCF   /
      DATA GENCI,GUGA,CIS/8HGENCI   ,8HGUGA    ,8HCIS     /
      DATA ZAPT/8HZAPT    /
      DATA NONE,RNONE/4HNONE,8HNONE    /
      DATA CHECK/8HCHECK   /
czcz
      DATA FMOHESS/8HFMOHESS /
      dimension dum3(3)
czcz
C
C     ----- MAIN DRIVER TO OBTAIN HESSIAN MATRIX -----
C
C     THE ENERGY, GRADIENT, HESSIAN, AND DIPOLE DERIVATIVE TENSOR
C     ARE OBTAINED BY READING THEM FROM CARDS, OR COMPUTING THEM.
C     THE ALPHA POLARIZABILITY DERIVATIVE TENSOR IS OBTAINED ONLY
C     BY READING IT FROM CARDS.  IT IS COMPUTED ONLY BY RUNTYP=RAMAN.
C
C     THE CALLING ARGUMENTS PERMIT YOU TO OVERRIDE THE VALUE OF
C     VIBANL GIVEN IN $FORCE BELOW, AND INDICATE THE SUCCESFUL
C     CONCLUSION OF A GEOMETRY SEARCH, USEFUL FOR $STATPT 'HSSEND'
C
CZCZ    
CZ    Scan $FMOXYZ to find natfmo.
CZ    
      call fmoxyz(' $FMOXYZ',1,natfmo,dum,dum3,idum)
CZ
      CALL VALFM(LOADFM)
      LFMOC   = LOADFM  + 1
      LFMOZAN = LFMOC   + 3*(NATFMO+1)
      LFMOMAS = LFMOZAN + NATFMO
      LIZBAS  = LFMOMAS + NATFMO
      LAST    = LIZBAS  + (NATFMO-1)/NWDVAR+1 
      NEEDFMO = LAST - LOADFM - 1
      CALL GETFM(NEEDFMO)
CZCZ

      SOME = NPRINT.NE.-5 .AND. MASWRK
CZCZ  NCOORD = 3*NAT
      NCOORD = 3*natfmo
      NCF    = 6*NFRG
      GOTEG  = .FALSE.
      GOTEH  = .FALSE.
      GOTDDM = .FALSE.
      GOTADM = .FALSE.
C
C     ----- READ $FORCE INPUT GROUP -----
C
C        THE STRATEGY FOR DETERMINING THE DEFAULT DIFFERENTIATION
C        IS TO PERFORM AN ANALYTIC CALCULATION IF POSSIBLE, OR TO
C        CHOOSE SEMI-NUMERICAL DIFFERENTIATION OF ANALYTIC GRADIENTS.
C        IF THE ANALYTIC GRADIENT IS NOT CODED, THE USER IS PERMITTED
C        TO REQUEST FULLY NUMERIC DIFFERENTIATION, BUT BECAUSE THIS
C        IS REASONABLE ONLY FOR SMALL MOLECULES, WE NEVER PICK THAT
C        AS A DEFAULT (THEY MUST TYPE IT).
C
      METHOD=ANAL
C
C     ---- THE FOLLOWING METHODS ONLY ALLOW SEMI-NUMERIC HESSIANS ----
C        BASIS SETS WITH F OR G FUNCTIONS
C        UHF, OR GVB WITH MORE THAN ONE PERFECT PAIR
C        MCSCF IF IT DOES NOT USE FULL ACTIVE SPACE DETERMINANT CODE
C        CI, MP2 (RHF OR UHF), DFT
C        MOPAC WAVEFUNCTIONS
C        SIMOMM MODEL
C        SOLVENT MODELS: EFP, ONSAGER, PCM, OR COSMO
C        SCALAR RELATIVISTIC CORRECTIONS
C        APPLIED EXTERNAL ELECTRIC FIELD
C        SCF-MI
C     ALL OF WHICH HAVE ANALYTIC GRADIENTS PROGRAMMED.
C     IN ADDITION, THE PARTIAL HESSIAN ANALYSIS IS SEMI-NUMERIC
C
      CALL BASCHK(LMAX)
      IF(LMAX.GT.2)                             METHOD=SNUM
      IF(SCFTYP.EQ.UHF)                         METHOD=SNUM
      IF(SCFTYP.EQ.GVB  .AND.  NPAIR.GT.1)      METHOD=SNUM
      IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.GUGA)  METHOD=SNUM
      IF(SCFTYP.EQ.RMC  .AND.  CISTEP.EQ.GENCI) METHOD=SNUM
      IF(MPLEVL.GT.0)                           METHOD=SNUM
      IF(CITYP.NE.RNONE)                        METHOD=SNUM
      IF(DFTYPE.NE.RNONE)                       METHOD=SNUM
      IF(SCFTYP.EQ.RHF  .AND. TDDFTYP.NE.RNONE) METHOD=SNUM
      IF(MPCTYP.NE.NONE)                        METHOD=SNUM
      IF(IECP.EQ.5)                             METHOD=SNUM
      IF(QMMM)                                  METHOD=SNUM
      ISOLV = NFRG + IZRF + IPCM
      IF(ISOLV.GE.1  .OR.  ISEPS)               METHOD=SNUM
      IF(RMETHOD.NE.RNONE)                      METHOD=SNUM
      IF(EFLDL)                                 METHOD=SNUM
      IF(MIFLAG.EQ.1)                           METHOD=SNUM
      IF(RUNTYP.EQ.HSSIAN.AND.IFREEZ(1).NE.0)   METHOD=SNUM
      IF(NEORUN.EQ.1)                           METHOD=SNUM
C
C         IF WE HAVE THE ENERGY, BUT NOT THE ANALYTIC GRADIENTS...
C
      MPGRD = SCFTYP.EQ.RHF  .OR.  SCFTYP.EQ.UHF
     *                       .OR. (SCFTYP.EQ.ROHF  .AND.  OSPT.EQ.ZAPT)
      CIGRD = SCFTYP.EQ.RHF .AND. (CITYP.EQ.GUGA  .OR.  CITYP.EQ.CIS)
      IF(MPLEVL.GT.0  .AND.  .NOT.MPGRD)           METHOD=RNONE
      IF(CITYP.NE.RNONE  .AND.  .NOT.CIGRD)        METHOD=RNONE
      IF(CCTYP.NE.RNONE)                           METHOD=RNONE
      IF(VBTYP.NE.RNONE)                           METHOD=RNONE
      IF(SCFTYP.NE.RHF  .AND. TDDFTYP.NE.RNONE)    METHOD=RNONE
      IF(ISVP.EQ.1)                                METHOD=RNONE
C        NOTE THAT WE ARE LETTING EFP SLIDE HERE,
C        FOR TRADITIONAL REASONS,
C        BUT WE DON'T HAVE MP2/CI+EFP GRADIENTS CORRECTLY CODED.
      IF(MPLEVL.GT.0  .OR.  CITYP.NE.RNONE) THEN
         IF(IZRF.GE.1 .OR.  IPCM.EQ.1  .OR. ISEPS) METHOD=RNONE
      END IF
C
C         REMEMBER THIS DEFAULT FOR ERROR CHECKING LATER
C
      IANAL=0
      ISNUM=0
      IFNUM=0
      IF(METHOD.EQ.ANAL)  IANAL=1
      IF(METHOD.EQ.SNUM)  ISNUM=1
      IF(METHOD.EQ.RNONE) IFNUM=1
C
      FGONLY = NUM.EQ.0  .AND.  NFRG.GT.0
      IF(ISEPS) ICFREQ=1
      RDHESS=.FALSE.
      NVIB = 1
      MPRINT=NPRINT
      VIBSIZ=0.01D+00
      PURIFY=.FALSE.
      PRTIFC=.FALSE.
      VIBANL=.FALSE.
czcz  IF(RUNTYP.EQ.HSSIAN) VIBANL=.TRUE.
      IF(RUNTYP.EQ.FMOHESS) VIBANL=.TRUE.
      DECOMP=.FALSE.
      PROJCT=.FALSE.
      IF(IFREEZ(1).NE.0.AND.RUNTYP.EQ.HSSIAN) PROJCT=.TRUE.
      SCLFAC = 1.0D+00
      DO 100 I=1,10
         TEMP(I) = ZERO
  100 CONTINUE
      TEMP(1) = 298.15D+00
      KQNAM(12) = NCOORD*10+3
      DO 110 I=1,NCOORD
         FREQ(I) = ZERO
  110 CONTINUE
      PRTSCN = .FALSE.
      NPRT = 0
      NPUN = 0
      PULCOR=.FALSE.
      REDOVB=.TRUE.
C
C     "TEST" IS AN UNDOCUMENTED WAY TO AVOID THE CHECK MADE
C     BELOW AS TO WHEN ANALYTIC HESSIANS CAN BE REQUESTED.
C
      TEST=.FALSE.
C
      JRET=0
      CALL NAMEIO(IR,JRET,FORCE,NNAM,QNAM,KQNAM,
     *            NVIB,VIBSIZ,PRTIFC,PURIFY,PROJCT,METHOD,VIBANL,
     *            RDHESS,DECOMP,SCLFAC,TEMP,FREQ,PRTSCN,NPRT,NPUN,
     *            PULCOR,TEST,REDOVB,
     *            0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,
     *    0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0,  0,0,0,0,0)
      NERR=0
      IF(JRET.EQ.2) NERR=NERR+1
C
C       'NUMERIC ' IS TO BE CONSIDERED AN ACCEPTABLE TYPO FOR 'SEMINUM '
      IF(METHOD.EQ.RNUM) METHOD=SNUM
C
      IF(NPRT.LT.0) NPRT=0
      IF(NPRT.GT.1) NPRT=1
      IF(NPUN.LT.0) NPUN=0
      IF(NPUN.GT.2) NPUN=2
C
      IF(SOME) WRITE(IW,9010) METHOD,NVIB,VIBSIZ,
     *                        RDHESS,PURIFY,PRTIFC,
     *                        VIBANL,DECOMP,PROJCT,
     *                        SCLFAC,PRTSCN,NPRT,
     *                        PULCOR,NPUN,REDOVB
C
      NTEMP=0
      DO 200 I=1,10
         IF(TEMP(I).NE.ZERO) NTEMP=NTEMP+1
  200 CONTINUE
      IF(SOME  .AND.  VIBANL) WRITE(IW,9012) NTEMP,(TEMP(I),I=1,NTEMP)
C
      NFREQ=0
      DO 210 I=1,NCOORD
         IF(FREQ(I).NE.ZERO) NFREQ=NFREQ+1
  210 CONTINUE
      IF(NFREQ.GT.0) THEN
         IF (SOME) WRITE(IW,9014) NFREQ,(FREQ(I),I=1,NFREQ)
         GOTFRQ=.TRUE.
      END IF
C
      IF(NVIB.LE.0  .OR.  NVIB.GT.2) NERR=NERR+1
      IF(ABS(VIBSIZ).GT.0.25D+00) NERR=NERR+1
C
      OK=.FALSE.
      IF(METHOD.EQ.ANAL) OK=.TRUE.
      IF(METHOD.EQ.SNUM) OK=.TRUE.
      IF(METHOD.EQ.FNUM) OK=.TRUE.
      IF(.NOT.OK) THEN
         IF(MASWRK) WRITE(IW,*)
     *       '*** ERROR: METHOD = ANALYTIC, SEMINUM, OR FULLNUM ONLY'
         NERR=NERR+1
      END IF
      IF(METHOD.EQ.ANAL) NHLEVL=0
      IF(METHOD.EQ.SNUM) NHLEVL=1
      IF(METHOD.EQ.FNUM) NHLEVL=2
C
      IF(NGLEVL.EQ.1) THEN
         IF(MASWRK) WRITE(IW,9090)
         NERR=NERR+1
      END IF
C
C        CHECK TO SEE IF DIFFERENTIATION METHOD IS REASONABLE
C     THE UNDOCUMENTED KEYWORD -TEST- ALLOWS SKIPPING THESE CHECKS.
C     OF COURSE, -TEST- SHOULD BE CHOSEN ONLY BY SOMEONE WHO IS
C     TRYING TO PROGRAM A MISSING METHOD.
C
      IF(.NOT.TEST) THEN
         IF(METHOD.EQ.ANAL  .AND.  (ISNUM+IFNUM).GT.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            IF(MASWRK) WRITE(IW,9105) METHOD
            NERR=NERR+1
         END IF
         IF(METHOD.EQ.SNUM  .AND.  IFNUM.GT.0) THEN
            IF(MASWRK) WRITE(IW,9100)
            IF(MASWRK) WRITE(IW,9105) METHOD
            NERR=NERR+1
         END IF
      END IF
C
C        PRINT SOME FRIENDLY ADVISE IF A HIGHER METHOD IS FEASIBLE
C
      IF(MASWRK) THEN
         IF(METHOD.EQ.SNUM  .AND.  IANAL.EQ.1) WRITE(IW,9106) ANAL,SNUM
         IF(METHOD.EQ.FNUM  .AND.  IANAL.EQ.1) WRITE(IW,9106) ANAL,FNUM
         IF(METHOD.EQ.FNUM  .AND.  ISNUM.EQ.1) WRITE(IW,9106) SNUM,FNUM
      END IF
C
      IF(NERR.GT.0) THEN
         IF(MASWRK) WRITE(IW,*)
     *      'ERROR IN $FORCE INPUT, PLEASE FIX AND TRY AGAIN.'
         CALL ABRT
      END IF
C
      IF(GOTFRQ) GO TO 800
C
C     ----- READ INTERNALS, GENERATE B MATRIX -----
C     THIS MUST BE DONE AFTER -DECOMP- IS KNOWN, AS THE DECOMPOSITION
C     SOMETIMES USES MORE THAN 3N-6 COORDINATES.  THE Z-MATRIX
C     CODE PERMITS MORE THAN 3N-6 COORDINATES ONLY IF DECOMP=.T.
C
      CARTSN = NZVAR.EQ.0
      IF(NZVAR.GT.0 .AND. RUNTYP.EQ.HSSIAN) THEN
         CALL ZMATIN(CARTSN)
         CALL BANDBI
         CALL PZANDG(F,0)
      END IF
C
C     ----- OBTAIN THE INFORMATION FROM CARD INPUT -----
C
      IF(RDHESS) THEN
         CALL VALFM(LOADFM)
         LFCM   = LOADFM+1
         LDDM   = LFCM   + (NCOORD+NCF)*(NCOORD+NCF)
         LADM   = LDDM   + 3*(NCOORD+NCF)
C
C            NOTE THAT $ALPDR IS NOT SET UP TO WORK WITH ANY
C        --- SOLVATION MODELS, SO ONLY 6*NCOORDS WORDS ARE
C            NEEDED INSTEAD OF 6*(NCOORD+NCF)
C
         LEG    = LADM   + 6*NCOORD
         LAST   = LEG    + NCOORD
         NEED = LAST-LOADFM
         CALL GETFM(NEED)
C
C           LOOK FOR OPTIONAL GRADIENT VECTOR
C           LOOK FOR HESSIAN MATRIX
C           LOOK FOR OPTIONAL DIPOLE DERIVATIVE TENSOR
C           LOOK FOR OPTIONAL ALPHA POLARIZABILITY DERIVATIVE TENSOR
C
         CALL EGIN(X(LEG),NCOORD,GOTEG,' $GRAD  ')
         CALL FCMIN(X(LFCM),NCOORD+NCF,GOTEH)
         CALL DDMIN(X(LDDM),NCOORD+NCF,GOTDDM)
         CALL ADMIN(RAMALF,X(LADM),NCOORD,GOTADM)
         CALL RETFM(NEED)
         IF(GOTEH) THEN
            SCFOK=.TRUE.
            GO TO 700
         ELSE
            IF (MASWRK) WRITE(IW,9030)
            CALL ABRT
         END IF
      END IF
C
C     ----- OTHERWISE, THEY MUST BE COMPUTED -----
C
CZ 
CZ    FMO HESSIAN CALCULATION
CZ
      if (.not.rdhess) then
        GOTDDM=.TRUE.
        if (maswrk) write(iw,*) 'HESS CALC IN FMOHESS DRIVER STARTS'
        CALL FMOX(0)
        if (maswrk) write(iw,*) 'HESS CALC IN FMOHESS DRIVER ENDS'
        ncoord = natfmo*3
        SCFOK = .TRUE.
      end if
cz
cz    Tricky part: this is just for the vibrational analysis
cz
      nat = natfmo
czcz

cz    IF(METHOD.EQ.ANAL) THEN
cz       IHESSM=2
cz       GOTDDM=.TRUE.
cz       GOTEG =.TRUE.
cz       CALL VALFM(LOADFM)
cz       LDDM = LOADFM+1
cz       LAST = LDDM  + 3*NCOORD
cz       NEED = LAST-LOADFM
cz       CALL GETFM(NEED)
cz       CALL VCLR(X(LDDM),1,3*NCOORD)
cz       CALL DAWRIT(IDAF,IODA,X(LDDM),3*NCOORD,34,0)
cz       CALL RETFM(NEED)
cz       CALL HSSANA(GOTWFN)
cz       SCFOK=.TRUE.
cz    END IF
C
cz    IF(METHOD.EQ.SNUM) THEN
cz       IHESSM=1
cz       GOTDDM=.TRUE.
cz       GOTEG =.TRUE.
cz       CALL VALFM(LOADFM)
cz       LFCM   = LOADFM + 1
cz       LDDM   = LFCM   +   (NCOORD+6*NFRG)**2
cz       LIST   = LDDM   + 3*(NCOORD+6*NFRG)
cz       LSKIP  = LIST   + 6*NFRG*NVIB
cz       LSKIP2 = LSKIP  + NAT+2*NFRG
cz       LWRK   = LSKIP2 + NAT*NAT
cz       LAST   = LWRK   + NUM*NUM
cz       NEED = LAST-LOADFM
cz       CALL GETFM(NEED)
cz       NATM = NAT
cz       CALL HSSNUM(X(LFCM),X(LDDM),X(LSKIP),X(LSKIP2),X(LWRK),
cz   *               X(LIST),NCOORD+6*NFRG,NAT+2*NFRG,NATM,
cz   *               NVIB,VIBSIZ,NPRT,NPUN,SCFOK,GOTWFN,REDOVB)
cz       CALL RETFM(NEED)
cz    END IF
c
cz    IF(METHOD.EQ.FNUM) THEN
cz       IHESSM=0
cz       IF(NFRG.GT.0) THEN
cz          IF(MASWRK) WRITE(IW,*)
cz   *          'FULLY NUMERIC HESSIAN NOT AVAILABLE WITH EFP'
cz          CALL ABRT
cz       END IF
cz       GOTDDM = .FALSE.
cz       GOTEG  = .FALSE.
cz       MYNC1  = 3*NAT
C           THE ACTUAL NUMBER OF POINTS DONE CANNOT EXCEED MXSP
cz       MXSP   = 1 + 24*NAT + 18*NAT*NAT
cz       CALL VALFM(LOADFM)
cz       LFCM   = LOADFM + 1         ! START OF FCM
cz       LDDM   = LFCM   + MYNC1**2  ! START OF DDM
cz       LSKIP  = LDDM   + 3*MYNC1   ! START OF SKIP ARRAY
cz       LATMP  = LSKIP  + NAT       ! START OF ATOM PAIR ARRAY
cz       LWRK   = LATMP  + NAT*NAT   ! STORT OF VIB0 ORBITALS
cz       LESP   = LWRK   + NUM*NUM   ! START OF SINGLE POINT ENERGIES
cz       LEG    = LESP   + MXSP      ! START OF GRADIENT
cz       LAST   = LEG    + NCOORD    ! LAST ADDRESS ON STACK
cz       NEED   = LAST - LOADFM
cz       CALL GETFM(NEED)
cz       CALL HSSFUL(X(LESP),X(LFCM),X(LSKIP),X(LATMP),X(LWRK),
cz   *               NAT,MYNC1,MXSP,VIBSIZ,GOTEG,SCFOK)
cz       CALL RETFM(NEED)
cz    END IF
C
C         THE HESSIAN COMPUTATION IS NOW FINISHED
C
  700 CONTINUE
C
C         HESSIAN MAY BE COMPUTED AS PART OF A GEOMETRY OPTIMIZATION,
C         ETC., AND THOSE RUNS MAY NOW TEST -IHESSM- TO KNOW THEY ARE
C         NO LONGER IN A HESSIAN CALCULATION PHASE...
C
      IHESSM=0
C
C     --- PURIFY THE HESSIAN,DIPOLE DERIVATIVES,ALPHA POLARIZABILITY ---
C
      NPRINT=MPRINT
      IF(NZVAR.GT.0 .AND. (PURIFY.OR.PRTIFC.OR.DECOMP.OR.PULCOR)) THEN
         CALL VALFM(LOADFM)
         LFCM   = LOADFM + 1
         LFCMI  = LFCM  + NCOORD*NCOORD
         LEG    = LFCMI + NROW*NROW
         LDDM   = LEG   + MAX(NCOORD,NROW)
         LDDN   = LDDM  + 3*NCOORD
         LADM   = LDDN  + 3*NVAR
         LADMI  = LADM  + 6*NCOORD
         LBMAT  = LADMI + 6*NVAR
         LBINV  = LBMAT + NVAR*NCOORD
         LWRK   = LBINV + NCOORD*NVAR
         LZMAT  = LWRK  + MAX(NCOORD,NROW)
         LIZMAT = LZMAT + NVAR
         LIWRK  = LIZMAT+ NZMAT
         LAST   = LIWRK + NVAR
         NEED = LAST - LOADFM - 1
         CALL GETFM(NEED)
C
C    PURIFY GRADIENT AND/OR PRINT INTERNAL GRADIENT
C
         IF(PRTIFC.OR.PURIFY) THEN
            CALL DAREAD(IDAF,IODA,X(LEG),NCOORD,3,0)
            CALL TRANG(X(LEG),NVAR,NCOORD)
            IF (PRTIFC) THEN
               CALL PZANDG(X(LEG),1)
               IF (NSYMC .EQ. 0)
     *            CALL PUZMAT(X(LZMAT),X(LIZMAT),X(LIWRK),NVAR,NZMAT)
            END IF
            IF (PURIFY) CALL TRANGB(X(LEG),NVAR,NCOORD)
         END IF
C
         CALL PURFCM(X(LFCM),X(LFCMI),X(LIZMAT),NCOORD,NROW,NVAR,
     *               NZMAT,PURIFY,PRTIFC,DECOMP)
C
         IF (PULCOR) THEN
C---         CALL HSSCOR(X(LFCM),X(LFCMI),X(LBINV),X(LEG),NCOORD,NVAR)
             IF(MASWRK) WRITE(IW,*) 'OPTION -PULCOR- IS INACTIVE'
         END IF
C
         IF(GOTDDM  .AND.  PURIFY)
     *      CALL PURDDM(X(LDDM),X(LDDN),X(LBMAT),X(LBINV),X(LWRK),
     *                  NCOORD,NVAR)
         IF(GOTADM .AND. PURIFY)
     *      CALL PURADM(X(LADM),X(LADMI),X(LBMAT),X(LBINV),X(LWRK),
     *                  NCOORD,NVAR)
         CALL RETFM(NEED)
      END IF
C
C     ----- PRINT/PUNCH GRADIENT, HESSIAN, DIPOLE DERIVATIVES,
C     ----- ALPHA POLARIZABILITY DERIVATIVES.
C
      CALL VALFM(LOADFM)
      LFCM = LOADFM + 1
      LEG  = LFCM   + (NCOORD+6*NFRG)*(NCOORD+6*NFRG)
      LDDM = LEG    + NCOORD
      LADM = LDDM   + 3*(NCOORD+6*NFRG)
      LAST = LADM   + 6*NCOORD
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      IF(NAT.GT.0) CALL DAREAD(IDAF,IODA,X(LEG) ,NCOORD,3,0)
      CALL DAREAD(IDAF,IODA,X(LFCM),(NCOORD+6*NFRG)**2, 4,0)
      IF(GOTDDM) THEN
         CALL DAREAD(IDAF,IODA,X(LDDM),3*(NCOORD+6*NFRG) ,34,0)
      ELSE
         CALL VCLR(X(LDDM),1,3*(NCOORD+6*NFRG))
      END IF
C
      IF(RUNTYP.EQ.GAMMA) CALL FCMSAV(X(LFCM),NCOORD)
C
      IF(GOTEG .AND. .NOT. FGONLY) THEN
         GRMS = DDOT(NCOORD,X(LEG),1,X(LEG),1)
         GRMS = SQRT(GRMS/NCOORD)
         LOCMX = IDAMAX(NCOORD,X(LEG),1)
         GMAX = X(LEG-1+LOCMX)
         STATPT = GMAX.LT.TOLG  .AND.  GRMS.LT.(TOLG/3.0D+00)
      ELSE
         STATPT = .TRUE.
      END IF
C
czcz  IF(RUNTYP.EQ.HSSIAN  .OR.  GOTWFN) THEN
      IF(RUNTYP.EQ.FMOHESS  .OR.  GOTWFN) THEN
         IF(GOTEG.AND.MASWRK) WRITE(IW,9040)
         IF(GOTEG)  CALL  EGOUT(X(LEG) ,NAT)
CZCZ                CALL FCMOUT(X(LFCM),NCOORD+6*NFRG)
                    CALL FMOFCMOUT(X(LFCM),NCOORD+6*NFRG)
         IF(POLAR  .AND.  EXETYP.NE.CHECK) THEN
            IF(IFREEZ(1).EQ.0) THEN
               CALL DAREAD(IDAF,IODA,APOL,6,251,0)
               CALL POLOUT(APOL)
            END IF
         END IF
         IF(GOTDDM .AND. .NOT.FGONLY) THEN
            IF(IFREEZ(1).EQ.0) THEN
               CALL DDMOUT(X(LDDM),NCOORD+6*NFRG)
            END IF
         END IF
         IF(GOTADM .AND. .NOT.FGONLY) THEN
            CALL POLOUT(RAMALF)
            CALL ADMOUT(X(LADM),NCOORD)
         END IF
      END IF
C
      IF(GOTEG)  CALL  EGPUN(X(LEG) ,NAT,' $GRAD  ')
                 CALL FCMPUN(X(LFCM),NCOORD+6*NFRG)
      IF(GOTDDM) CALL DDMPUN(X(LDDM),NCOORD+6*NFRG)
      IF(GOTADM) CALL ADMPUN(E,RAMALF,X(LADM),NCOORD)
      CALL RETFM(NEED)
C
C     ----- NORMAL COORDINATE VIBRATIONAL ANALYSIS -----
C
  800 CONTINUE
      IF(.NOT.VIBANL  .AND.  .NOT.VIBOVR) RETURN
      NC1 = NCOORD+6*NFRG
      NC2 = (NC1**2+NC1)/2
      NC3 = NC1**2
C
      NPART = NAT
      KMASS=0
      DO 820 IFRG=1,NFRG
         DO 810 III=1,NMPTS(IFRG)
            IF(FMASS(III+KMASS).GT.ZERO) NPART=NPART+1
  810    CONTINUE
         KMASS=KMASS+NMPTS(IFRG)
  820 CONTINUE
C
      CALL VALFM(LOADFM)
      LVEC   = LOADFM + 1
      LFCM   = LVEC   + NC3
      LE     = LFCM   + NC2
      LSCR   = LE     + NC1
      LIA    = LSCR   + NC1*8
      LRM    = LIA    + NC1
      LSVT   = LRM    + (NCOORD+21*NFRG)
      LSVR   = LSVT   + NC1*3
      LSVTT  = LSVR   + NC1*3
      LSVRT  = LSVTT  + NC1
      LCC    = LSVRT  + NC1
      LCOM   = LCC    + 3*NPART
      LZMS   = LCOM   + 3*NPART
      LBUF1  = LZMS   +   NPART
      LBUF2  = LBUF1  + NC3
      LDDM   = LBUF2  + NC3
      LADM   = LDDM   + NC1*3
      LAST   = LADM   + NC1*6
      NEED = LAST-LOADFM
      CALL GETFM(NEED)
CZ    NATM = NAT+2*NFRG
      IF(NEORUN.EQ.0) THEN
         CALL FGMTRX(X(LVEC),X(LFCM),X(LE),X(LSCR),X(LIA),X(LRM),
     *               X(LSVT),X(LSVR),X(LSVTT),X(LSVRT),
     *               X(Lfmoc),X(LCOM),X(Lfmomas),X(LBUF1),X(LBUF2),
     *               NC1,NC2,NPART,X(LDDM),GOTDDM,X(LADM),GOTADM,
     *               PROJCT,STATPT,SCFOK,nfg)
      ELSE
         CALL FGMTRX_NEO(X(LVEC),X(LFCM),X(LE),X(LSCR),X(LIA),X(LRM),
     *               X(LSVT),X(LSVR),X(LSVTT),X(LSVRT),
     *               X(Lfmoc),X(LCOM),X(Lfmomas),X(LBUF1),X(LBUF2),
     *               NC1,NC2,NPART,X(LDDM),GOTDDM,X(LADM),GOTADM,
     *               PROJCT,STATPT,SCFOK)
      END IF
C
C        SAVE HARMONIC FREQUENCIES AND NORMAL MODES FOR EXTENDED TDHF
C
      IF(IGETOLI(1).NE.0) THEN
        CALL SVGFNM(FREQ,X(LVEC),NC1,LINEAR)
      END IF
C
      CALL RETFM(NEED)
czcz
      call retfm(needfmo)
czcz
      IF (MASWRK) WRITE(IW,9020)
      CALL TIMIT(1)
      RETURN
C
 9010 FORMAT(/5X,33(1H-)/
     *        5X,'HESSIAN MATRIX CONTROL PARAMETERS'/5X,33(1H-)/
     *        5X,'METHOD=',A8,3X,'NVIB  =',I8,3X,'VIBSIZ=',F8.5/
     *        5X,'RDHESS=',L8,3X,'PURIFY=',L8,3X,'PRTIFC=',L8/
     *        5X,'VIBANL=',L8,3X,'DECOMP=',L8,3X,'PROJCT=',L8/
     *        5X,'SCLFAC=',F8.5,3X,'PRTSCN=',L8,3X,'NPRT  =',I8/
     *        5X,'PULCOR=',L8,3X,'NPUN  =',I8,3X,'REDOVB=',L8)
 9012 FORMAT(5X,'THERMOCHEMISTRY WILL BE PRINTED FOR',I5,
     *          ' TEMPERATURES:'/(3X,5F12.5/))
 9014 FORMAT(5X,'HESSIAN COMPUTATION WILL BE SKIPPED AS'/
     *       5X,'A TOTAL OF',I5,' FREQUENCIES WERE INPUT:'/
     *      (5X,5F12.5/))
 9020 FORMAT(1X,'......END OF NORMAL COORDINATE ANALYSIS......')
 9030 FORMAT(1X,'RDHESS IS TRUE, BUT NO HESSIAN MATRIX WAS FOUND IN',
     *          ' YOUR INPUT FILE.')
 9040 FORMAT(/10X,15(1H-)/10X,'ENERGY GRADIENT'/10X,15(1H-))
 9090 FORMAT(/1X,'PLEASE DO NOT USE NUMGRD=.TRUE. DURING HESSIAN JOBS,'/
     *   1X,'INSTEAD USE METHOD=ANALYTIC, SEMINUM, OR FULLNUM ONLY.'/
     *   1X,'(IF NECESSARY, RUN THE HESSIAN IN A SEPARATE JOB THAN'/
     *   1X,'A GEOMETRY SEARCH (I.E. AVOID HESS=CALC OR HSSEND=.TRUE.)')
 9100 FORMAT(/10X,'**** ERROR IN DIFFERENTIATION METHOD ****'//
     *  1X,'ANALYTIC COMPUTATION OF THE HESSIAN IS IMPLEMENTED'/
     *  5X,'FOR S,P,D BASIS SETS (INCLUDING ECP USAGE) FOR AB INITIO',
     *     ' RHF, ROHF,'/
     *  5X,'GVB (OPEN SHELL OR TCSCF) AND MCSCF (CISTEP=ALDET)',
     *     ' WAVEFUNCTIONS.'//
     *  1X,'SEMI-NUMERIC HESSIANS CAN BE COMPUTED WHEN ANALYTIC',
     *     ' GRADIENTS ARE AVAILABLE:'/
     *  5X,'IF F,G FUNCTIONS ARE IN THE BASIS SET,'/
     *  5X,'IF USING GRID-BASED OR GRID-FREE DFT,'/
     *  5X,'IF UHF, OR IF GVB WITH MORE THAN ONE PERFECT PAIR,'/
     *  5X,'IF MCSCF USES SOME CISTEP OTHER THAN ALDET,'/
     *  5X,'IF MPLEVL=2 FOR RHF OR UHF WAVEFUNCTIONS,'/
     *  5X,'IF EXCITED STATE CIS FOR RHF WAVEFUNCTIONS,'/
     *  5X,'IF GROUND OR EXCITED STATE GUGA CI FOR RHF WAVEFUNCTIONS,'/
     *  5X,'IF SEMI-EMPIRICAL MODELS AM1, PM3, OR MNDO ARE USED,'/
     *  5X,'IF EFP, PCM, ONSAGER, OR COSMO SOLVENT MODELS ARE USED,'/
     *  5X,'IF THERE IS AN APPLIED EXTERNAL ELECTRIC FIELD,'/
     *  5X,'IF SCALAR RELATIVISTIC TRANSFORMATIONS ARE IN USE, OR'/
     *  5X,'IF RUNNING SCF-MI COMPUTATIONS.'//
     *  1X,'FULLY NUMERIC HESSIANS CAN BE COMPUTED WHEN ONLY THE',
     *     ' ENERGY IS AVAILABLE:'/
     *  5X,'WHEN MODEL CORE POTENTIAL INTEGRALS ARE USED,'/
     *  5X,'WHEN MPLEVL=2 FOR SCFTYP=ROHF/OSPT=RMP OR SCFTYP=MCSCF,'/
     *  5X,'WHEN CITYP IS SELECTED AND THE SCFTYP IS NOT RHF,'/
     *  5X,'WHEN THE CITYP SELECTED IS NOT CIS OR GUGA, OR'/
     *  5X,'WHEN ANY CCTYP IS SELECTED'/)
 9105 FORMAT(1X,'YOUR INPUT MISTAKENLY REQUESTED METHOD=',A8)
 9106 FORMAT(/15X,'* * * EFFICIENCY NOTE * * *'/
     *        1X,'THIS CALCULATION CAN BE RUN WITH DIFFERENTIATION',
     *           ' METHOD=',A8/
     *        1X,'THIS MIGHT BE MORE ACCURATE AND/OR FASTER THAN',
     *           ' YOUR CHOICE,'/
     *        1X,'BUT THE REQUESTED CALCULATION METHOD=',A8,
     *           ' IS PROCEEDING.'/)
      END
C*MODULE FMOHSS  *DECK FMOFCMOUT
      SUBROUTINE FMOFCMOUT(FCM,NCOORD)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION FCM(NCOORD,NCOORD)
      DIMENSION CLAB(3)
czcz
      character*4 cdum4(4)
      character*8 cdum8
czcz
C
      PARAMETER (MXATM=5000, MXFRG=65,
     *           MXDFG=1, MXDPPT=MXFRG*MXDFG*12)
C
      COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
     *                NPPTS(MXFRG),NPTTPT,IEFP,
     *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
     *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
     *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FROZNC/ IFREEZ(3*MXATM),NFRZ
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
Cz    COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),BNAM(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
CZ
      COMMON /FMCOM / X(1)
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
czcz
C
      DATA CLAB /4H   X,4H   Y,4H   Z/
      DATA HSSIAN/8HHESSIAN /
C
      IF(.NOT.MASWRK) RETURN
C
      WRITE(IW,9000)
C
      IF(IFREEZ(1).NE.0.AND.RUNTYP.EQ.HSSIAN.AND.MASWRK)
     *  WRITE (IW, 9005)
C
      cdum8 = '        '
      INCR= 2
      IF(NPRINT.EQ.6) INCR=4
      DO 140 MINCOL=1,NATfmo,INCR
         MAXCOL = MINCOL+INCR-1
         IF (MAXCOL .GT. NAT) MAXCOL = NATfmo
         ico = 0
         do ii = mincol, maxcol
           ico = ico + 1
CZ         ztmp = x(lfmomas+ii-1)
           iantmp = int(x(lfmozan+ii-1)+0.1D+00)
           call zsymnum(cdum8,cdum4(ico),iantmp)
         end do
         WRITE(IW,9010) (N,N = MINCOL,MAXCOL)
CZ       WRITE(IW,9020) (ANAM(N),BNAM(N),N = MINCOL,MAXCOL)
         WRITE(IW,9020) (cdum4(N),cdum8,N = 1,ico)
         WRITE(IW,9030) ((CLAB(M),M = 1,3),N = MINCOL,MAXCOL)
         J0 = 3*(MINCOL-1)+1
         J1 = 3*MAXCOL
         IFC=1
         DO 120 IAT = MINCOL,NATfmo+2*NFRG
            I0 = 3*(IAT-1)
            IF(IAT.LE.NATfmo) THEN
CZ             ztmp = x(lfmomas+iat-1)
               iantmp = int(x(lfmozan+iat-1)+0.1D+00)
               call zsymnum(cdum8,cdum4(1),iantmp)
               WRITE(IW,9040) IAT,cdum4(1),cdum8,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
            ELSE
               IFCT=MOD(IAT-NAT,2)
               IF(IFCT.EQ.1) THEN
                 WRITE(IW,9050) IFC,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
               ELSE IF(IFCT.EQ.0) THEN
                 WRITE(IW,9060) IFC,CLAB(1),
     *                         (FCM(I0+1,J),J = J0,J1)
               IFC=IFC+1
               END IF
            END IF
            WRITE(IW,9070) CLAB(2),(FCM(I0+2,J),J = J0,J1)
            WRITE(IW,9070) CLAB(3),(FCM(I0+3,J),J = J0,J1)
  120    CONTINUE
  140 CONTINUE
C                    TWO SETS OF COLUMNS (TRANSLATION AND ROTATION)
C                    FOR PRINTING THE FRAGMENT/FRAGMENT BLOCK
      DO 150 IFRG=1,NFRG
         WRITE(IW,9080) IFRG
         WRITE(IW,9030) ((CLAB(M),M = 1,3),N = 1,2)
         J0 = 3*NAT + 6*(IFRG-1) + 1
         J1 = J0 + 5
         DO 130 JFRG = IFRG,NFRG
            I0 = 3*NAT + 6*(JFRG-1)
            WRITE(IW,9050) JFRG,CLAB(1),(FCM(I0+1,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(2),(FCM(I0+2,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(3),(FCM(I0+3,J),J = J0,J1)
            WRITE(IW,9060) JFRG,CLAB(1),(FCM(I0+4,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(2),(FCM(I0+5,J),J = J0,J1)
            WRITE(IW,9070)      CLAB(3),(FCM(I0+6,J),J = J0,J1)
  130    CONTINUE
  150 CONTINUE
      RETURN
C
 9000 FORMAT(/10X,31(1H-)/10X,'CARTESIAN FORCE CONSTANT MATRIX'/
     *        10X,31(1H-))
 9005 FORMAT(//1X,'THERE ARE FROZEN COORDINATES, ',
     *'PARTIAL HESSIAN ANALYSIS WILL BE DONE.'//1X,
     *'FOR THE FROZEN ATOMS AND FRAGMENTS, ',
     *'DIAGONAL MATRIX ELEMENTS ARE '/1X,'SET TO BE 1.0D-08,',
     *' ALL THE OTHER MATRIX ELEMENTS RELATED TO FROZEN '/1X,
     *'ATOMS AND FRAGMENTS ARE SET TO BE ZERO.'//)
 9010 FORMAT(/20X,4(12X,I4,11X))
 9020 FORMAT( 20X,4(11X,A8,A2,6X))
 9030 FORMAT( 20X,4(3X,A4,5X,A4,5X,A4,2X))
 9040 FORMAT(I3,3X,A8,A2,A4,12F9.6)
 9050 FORMAT(1X,'FRAG.',I3,1X,'TRANS.',A4,12F9.6)
 9060 FORMAT(1X,'FRAG.',I3,1X,'ROT.  ',A4,12F9.6)
 9070 FORMAT(16X,A4,12F9.6)
 9080 FORMAT(/20X,'FRAGMENT',I3,3X,'TRANSLATION',13X,'ROTATION ')
      END
C
C*MODULE FMOHSS  *DECK FMOESHSS
C>
C>     @brief ESP contributions to FMO Hessian
C>
C>     @details Add ESP contributions to FMO Hessian. 
C>
C>     @author Hiroya Nakata 
C>
      SUBROUTINE FMOESHSS(L1,L2,DA,SCFFRG,IDMREC0,DC,WRK1,
     *                    MAPI,MAPJ,MAP3,MAXL1D,IREC00,
     *                    ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,
     *                    NQMTFG,
     *                    YALAG,IPTYA,YAWRK,FCM,
     *                    numfrg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=5000,MXSH=1000,MXGTOT=5000, MXRT=5000 )
c     LOGICAL DIRSCF,FDIFF,PACK2E,GOPARR,DSKWRK,MASWRK,QFMM,QOPS
      LOGICAL ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH
      LOGICAL LCFLAG,LRINT,CAMFLAG,LCFLAGS,LRINTS,CAMFLAS
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      DIMENSION DA(*),SCFFRG(*),IDMREC0(*)
      DIMENSION DC(*),WRK1(*),MAPI(*),MAPJ(*),MAP3(MAXL1D,3)
      DIMENSION NQMTFG(*), numfrg(1)
C
      COMMON /DFTCAM/ ALPHAC,BETAC,CAMMU,CAMVWN,CAMLYP,CAMFLAG
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      COMMON /FMCOM / X(1)
c     COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
C     COMMON /INTOPT/ ISCHWZ,IECP,NECP,IEFLD
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /NLRC  / LCFLAG,LRINT,EMU,EMU2,LRFILE
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
c     COMMON /OPTSCF/ DIRSCF,FDIFF
c     COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /QMFM  / SIZE,EPS1,DPGD,QFMM,NP,NS,IWS,NPGP,MPMTHD,NUMRD,
c    *                ITERMS,QOPS,ISCUT
c     COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
c     COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
c     COMMON /SHLEXC/ NORGSH(3),NORGSP(3),IEXCH,NANGM,NGTH(4)
c     COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
c    *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                modlmo,nopden,mofock,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas
c     common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
c     COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
c     COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
c    *                MPLEVL,MPCTYP
C
c     COMMON /GRAD  / DE(3,MXATM)
C   
C     FMO second derivative 
C     This subroutine calculate the contribution
C     which come from the Electrostatic Potential
C     For the detail mathmatical equation:  J. Chem. Phys. 138, 164103 (2013)
C      
C
      DIMENSION YALAG(*),IPTYA(*),YAWRK(*),FCM(3*natfmo,*)
C
      CALL TIMIT(1)
      IF(MASWRK) WRITE(IW,*) 'BEGIN FMOESHSS'
C
      LWRKDEN =LFMOBUF(1) ! MAXL1D+MAXL2D+MAXL3D
      LWRKESP =LFMOBUF(2) ! MAXL2D
      IFG=ICURFG
      JFG=JCURFG
      KFG=KCURFG
      L1IJ=L1
      L2IJ=L2
      L3IJ=L1 * L1
      L1K = 1
      L2K = 1
      IF(IFG.EQ.0) RETURN
      L1I  = IAND(NUMFRG(IFG),65535)
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
      END IF
      IF (KFG.NE.0) THEN
        L1K  = IAND(NUMFRG(KFG),65535)
        L2K   = (L1K*L1K + L1K)/2
      END IF
      L2I   = (L1I*L1I + L1I)/2
      L2J   = (L1J*L1J + L1J)/2
      NDSIJ = L2  * NAT  * 3
C
      LCFLAGS = LCFLAG
      LRINTS  = LRINT
      CAMFLAS = camFLAG
      LCFLAG  = .FALSE.
      camFLAG = .FALSE.
      LRINT   = .FALSE.
C
      CALL DERCHK(NDER)
      if(nder.ne.2) then
        write(iw,*) 'FMOESHSS: nder=',nder
        call abrt
      endif
C 
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C 
      IESDPPC = 1
C    allocate memory 
      CALL VALFM(LOADFM)
      LEG  = LOADFM + 1
      LEH  = LEG    + 3 *  NATFMO
      LFD  = LEH    + 9 * (NATFMO*NATFMO+NATFMO)/2
      LAST = LFD    + MAX(3 *  NATFMO * L2,L3IJ*2)
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
CZ
      NFD  = 3*NATFMO*L2
      NEGH = 3*NATFMO+9*(NATFMO*(NATFMO+1))/2
c
c     if(maswrk) write(6,*) "Construct ini den"
C     Get Density ||  S^{a,I} || S^{a,J}
CZ    DA is  Delta DIJ - DI - DJ
      call ESDDVDD(l1,l2,DA,X(LFMODB),DC,X(LWRKDEN),WRK1,
     *     X(LFMOESPA),X(LWRKESP),X(LNUMFRG),MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC00,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *     l1i,l1j,X(LFD))
c     CALL TIMIT(1)
C
      call vclr(x(leg),1,NEGH)
      call vclr(x(lfd),1,NFD)
c     Second derivative for one-electron terms
      call esddv1d(DA,LEG,LEH,LFD)
c     if(maswrk) write(6,*) "begin second derivative"
c     Second derivative for two-electron terms
c     kfg = 0
      call esddv2d(IFG,JFG,KFG,L1IJ,L1I,L1J,l1k,nak,nbk,natk,
     *     X(LFMOESPA),X(LIAGLOB),X(LEG), X(LEH),l2ij,NQMTFG,
     *     X(LFMODB),X(LWRKDEN),x(LLAYFRG),IDMREC0,DA,x(LFD),FCM,
     *     scffrg)
c     CALL TIMIT(1)
C     summing up contribution (\Delta D * V^ab)
      call addhss(natfmo,natfmo,x(LEH),FCM,0,x(liaglob))
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
      NCURSH = 0
C
      CALL VALFM(LOADFM)
      LDSIJ  = LOADFM + 1
      LAST   = LDSIJ  + NDSIJ
      NEEDIJ = LAST-LOADFM-1
      CALL GETFM(NEEDIJ)
C
c     write(6,*) "begin ESP",KFG
c     calcualting S^a * V^b terms in ( fmohss1a.src )
      IF (KFG.EQ.0) THEN
       call ESPSDXVD(l1,l2,X(LFMODB),X(LWRKDEN),WRK1,
     *      X(LNUMFRG),MAPI,MAPJ,MAP3, x(liaglob), MAXL1D,IREC00,
     *      ORBXCH1, KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *      x(LDSIJ),l1i,l2i,x(LDSIJ),l1j,l2j,x(LDSIJ),l2ij,x(LFD),
     *      NQMT0,FCM,YALAG,IPTYA,YAWRK,NA0,NB0,
     *      l1k,l2k,x(LDSIJ))
      ELSE IF(KFG.NE.0) THEN
       call ESPSDXVD(l1,l2,X(LFMODB),X(LWRKDEN),WRK1,
     *      X(LNUMFRG),MAP3(1,1),MAP3(1,2),MAP3(1,3), x(liaglob), 
     *      MAXL1D,IREC00,
     *      ORBXCH1, KODEXCH,JODEXCH,IODEXCH,NQMTFG, scffrg,0,
     *      x(LDSIJ),l1i,l2i,x(LDSIJ),l1j,l2j,x(LDSIJ),l2ij,x(LFD),
     *      NQMT0,FCM,YALAG,IPTYA,YAWRK,NA0,NB0,
     *      l1k,l2k,x(LDSIJ))
      END IF
c     
      NQMT = NQMT0
C
      LCFLAG  = LCFLAGS
      LRINT   = LRINTS
      camFLAG = CAMFLAS
C
      CALL RETFM(NEEDIJ)
      CALL RETFM(NEED)

      IF(MASWRK) WRITE(IW,*) 'DONE FMOESHSS'
      CALL TIMIT(1)
      return
      end

C*MODULE FMOHSS  *DECK ESDDVDD
C>
C>     @brief Density contributions from ESP for FMO Hessian
C>
C>     @details Add density contributions from ESP for FMO Hessian.
C>
C>     @author Hiroya Nakata 
C>
      subroutine ESDDVDD(l1,l2,DA,DB,DC,WRK,WRK1,
     *     ESPA,WRKESP,NUMFRG,MAPI,MAPJ,MAP3,
     *     MAXL1D,IREC0,ORBXCH1,ENEXCH1,
     *     KODEXCH,JODEXCH,IODEXCH,NQMTFG,
     *     scffrg,IMODE,l1i,l1j,FD)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      PARAMETER (MXATM=5000,ONE=1.0D+00)
C
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL SOME1,ORBXCH1,ENEXCH1
      LOGICAL KODEXCH,JODEXCH,IODEXCH
C
C
      DIMENSION DA(1),DB(1),DC(1),FD(*)
      DIMENSION ESPA(1),WRK(1),WRK1(1),WRKESP(1)
      DIMENSION NUMFRG(1),NQMTFG(*)
      DIMENSION MAPI(1),MAPJ(1),MAP3(MAXL1D,3) 
      DIMENSION scffrg(*)
c     DIMENSION DSI(l2i,*),DSJ(l2j,*),DSIJ(l2ij,*)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
c     COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas
      COMMON /IOFILE/ IR,IW,IP,IJK,IPK,IDAF,NAV,IODA(950)
CZ    COMMON /SCZVEC/ IDFZVEC,LIPTZVEC,LIPTLG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
c     COMMON /GRAD  / DE(3,MXATM)
      DATA   UHF/8HUHF     / 
      DATA  ROHF/8HROHF    / 
CZ
CZ    DENSITY DERIVATIVES OF EXTERNAL ELECTROSTATIC POTENTIALS
CZ
C     dummy argument it is used later implementation
c     DC(1)=0.0D+00
      DUM  = ESPA(1)
      if(imode.ne.0) write(iw,*) "imode =",
     * imode
C
      IFG=ICURFG
      JFG=JCURFG
      KFG=KCURFG
      l3 =l1 * l1

C     Notice record number 16 is written by diminid  subroutine
      IF(scftyp.eq.uhf.or.scftyp.eq.rohf) then 
          CALL DAREAD(IDAF,IODA,FD      ,L3,15,0)
          CALL DAREAD(IDAF,IODA,FD(L3+1),L3,19,0)
          call dmtx2(wrkesp,FD,na,l1,l1,0) 
          call dmtx2(da(l2+1),FD(l3+1),nb,l1,l1,0) 
          call daxpy(L2,one,da(l2+1),1,wrkesp,1) 
          iomit = 0
      ELSE
          CALL DAREAD(IDAF,IODA,da(l2+1),L3,15,0)
          call dmtx2(wrkesp,da(l2+1),na,l1,l1,na) 
          iomit = 1
      END IF

      L1I  = IAND(NUMFRG(IFG),65535)
      NAI  = ISHFT(NUMFRG(IFG),-16)
c     NATI = IXFTCH(X(LNATFRG),IFG)
      MULI = IXFTCH(X(LMULFG),IFG)
      NBI  = NAI-MULI+1
      NQI  = IAND(NQMTFG(IFG),65535)
      IF (JFG.NE.0) THEN
        L1J  = IAND(NUMFRG(JFG),65535)
        NAJ  = ISHFT(NUMFRG(JFG),-16)
c       NATJ = IXFTCH(X(LNATFRG),JFG)
        MULJ = IXFTCH(X(LMULFG),JFG)
        NBJ  = NAJ-MULJ+1
        NQJ  = IAND(NQMTFG(JFG),65535)
      END IF
      IF (KFG.NE.0) THEN
        L1K  = IAND(NUMFRG(KFG),65535)
        NAK  = ISHFT(NUMFRG(KFG),-16)
        MULK = IXFTCH(X(LMULFG),KFG)
        NBK  = NAK-MULK+1
        NQK  = IAND(NQMTFG(KFG),65535)
      END IF
c
      some1=.False.
      if(ifmostp.eq.4) then 
        CALL DIMINID(0,JFG,IFG,L1J,L1I,NQJ,NQI,NAJ,NAI,NBJ,NBI,L1,DA,DB,
     *               WRK,WRK1,X(LIODFMO),IREC0,X(LIABDFG),X(LJABDFG),
     *               X(LINDAT),X(LIAGLOB),X(LLOCFMO),MAPJ,MAPI,
     *               ORBXCH1,ENEXCH1,JODEXCH,IODEXCH,0,DUM,iomit,
     *               scffrg(jfg).eq.uhf,scffrg(ifg).eq.uhf,
     *               X(LMULFG),some1)
      END IF
      if(ifmostp.eq.9) then 
c       write(6,*) "FMO trimer initial Density",l1,MAXL1D
        CALL TRIMINID(KFG,JFG,IFG,L1K,L1J,L1I,NQK,NQJ,NQI,NAK,NAJ,NAI,
     *               NBK,NBJ,NBI,L1,DA,DB,DC,WRK,WRK1,X(LIODFMO),IREC0,
     *               X(LIABDFG),X(LJABDFG),X(LINDAT),X(LIAGLOB),
     *               X(LLOCFMO),MAP3(1,3),MAP3(1,2),MAP3(1,1),
     *               ORBXCH1,ENEXCH1,KODEXCH,JODEXCH,IODEXCH,iomit,
     *               scffrg(kfg).eq.uhf,scffrg(jfg).eq.uhf,
     *               scffrg(ifg).eq.uhf,SOME1)
      END IF

      CALL DAXPY(L2,-ONE,WRKESP,1,DA,1)
      CALL DSCAL(L2,-ONE,DA,1)
c     NCURS  = NCURSH
c     NCURSH = 0
c     write(*,*) "check density"
c     call prtril(DA,L1)
C
      IF(scftyp.eq.uhf.or.scftyp.eq.rohf) then 
        CALL dawrit(IDAF,IODA,FD,L3,15,0)
        CALL dawrit(IDAF,IODA,FD(L3+1),L3,19,0)
      END IF
C
c     CALL MAKEMOL(IFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
c     CALL EXTSDER(WRK,DSI,L1I,L2I,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSI,L2I*3*NATI)
C
c     CALL MAKEMOL(JFG,0,0,ILAY,0,0,0,0,0,0,0,.FALSE.)
c     CALL EXTSDER(WRK,DSJ,L1J,L2J,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSJ,L2J*3*NATJ)
C
c     CALL MAKEMOL(IFG,JFG,0,ILAY,0,0,0,0,0,0,0,.true.)
c     CALL EXTSDER(WRK,DSIJ,L1,L2IJ,.TRUE.,.TRUE.,0)
c     IF(GOPARR) CALL DDI_GSUMF(1501,DSIJ,L2IJ*3*NAT)

c     NCURSH = NCURS  
      return
      end
C
C*MODULE FMOHSS  *DECK YALGMEM1
C>
C>     @brief Measure size of Ya
C>
C>     @details Get total dimension of  U^{a} and max dimension of U^{a,X}.
C>
C>     @author Hiroya Nakata 
C>
      SUBROUTINE YALGMEM1(NYA,MXYAWK,NQMTFG,scffrg,mulfg,natfrg,layfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION NQMTFG(*),natfrg(*)
C     FOR UHF 
      DIMENSION mulfg(nfg),scffrg(nfg),layfrg(*)
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
c
C     dummy arguments
c     if(scffrg(1).eq.uhf) write(*,*) "mulfg=",mulfg(1)
c
      NYA = 0
      MXYAWK = 0
      DO I = 1, NFG
        IF(layfrg(I).EQ.nlayer) THEN
          NQMT = IAND(NQMTFG(I),65535)
          NAI  = ISHFT(NQMTFG(I),-16)
          NOCV = NAI * (NQMT - NAI)
          NXYZI= natfrg(i) * 3
          IF(scffrg(I).eq.UHF.or.scffrg(I).eq.rohf) THEN
            NBI = NAI  - mulfg(I) + 1
            NOCV= NOCV + NBI * (NQMT - NBI)
          END IF
c         write(*,*) "NXYZI NOCV = ",NXYZI,NOCV
          NYA  = NYA + NOCV * NXYZI
          DO j=1,I-1
             NXYZJ = natfrg(j) * 3
             NATOMT= NXYZI + NXYZJ
             MXYAWK= max(MXYAWK,NATOMT)
c            write(*,*) " NATOMT = " , NATOMT
             IF(NBODY.EQ.3) THEN
               DO K=1,J-1
                 NXYZK = natfrg(k) * 3
                 NATOMT= NXYZI + NXYZJ + NXYZK
                 MXYAWK= max(MXYAWK,NATOMT)
               END DO
             END IF
          END DO
        END IF
      END DO
C
      RETURN
      END
c
C*MODULE FMOHSS* DECK YALGMEM2 
C>
C>     @brief Mapping for U^a
C>
C>     @details Get point for respective U^{a,X}.
C>
C>     @author Hiroya Nakata 
C>
      SUBROUTINE YALGMEM2(NFG,IPTLG,NQMTFG,scffrg,mulfg,natfrg)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION IPTLG(1),NQMTFG(1),natfrg(1)
c     For UHF fragment
      DIMENSION mulfg(nfg),scffrg(nfg)
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
c
C     dummy arguments
c     if(scffrg(1).eq.uhf) write(*,*) "mulfg=",mulfg(1)
C
      IPT = 1
      DO I = 1, NFG
        IPTLG(I) = IPT
        NQMT =  IAND(NQMTFG(I),65535)
        NAI  = ISHFT(NQMTFG(I),-16)
        NOCV = NAI * (NQMT - NAI)
        IF(SCFFRG(I).EQ.UHF.or.SCFFRG(I).EQ.rohf) THEN
          NBI  = NAI  - mulfg(I)+1
          NOCVB= NBI  * (NQMT - NBI)
          NOCV = NOCV + NOCVB
        END IF
        NXYZI= natfrg(i) * 3
c       write(*,*) "NXYZI NOCV = ",NXYZI,NOCV
        IPT = IPT + NOCV * NXYZI
      END DO
      IPTLG(NFG+1) = IPT - 1
C
      RETURN
      END
C
C*MODULE FMOHSS  *DECK addhss
C>
C>     @brief   Add V^{ab} contributions to FMO Hessian
C>
C>     @details Add FCMWRK to FCM.
C>
C>     @author Hiroya Nakata 
C>
      subroutine addhss(nat,natfmo,FCMWRK,FCM,imode,iaglob) 
      implicit double precision(A-H,O-Z)
c    
      DIMENSION FCMWRK(9,(nat*nat+nat)/2)
      DIMENSION FCM(natfmo*3,natfmo*3),iaglob(*)
c
      do iatom = 1,nat
         do jatom = 1,iatom
            if(imode.eq.0) then
              ij = (iatom * iatom - iatom)/ 2 + jatom 
              ix = (iatom-1) * 3 + 1
              iy = (iatom-1) * 3 + 2
              iz = (iatom-1) * 3 + 3
              jx = (jatom-1) * 3 + 1
              jy = (jatom-1) * 3 + 2
              jz = (jatom-1) * 3 + 3
            else if(imode.eq.1) then
              ij = (iatom * iatom - iatom)/ 2 + jatom 
              ix = (iaglob(iatom)-1) * 3 + 1
              iy = (iaglob(iatom)-1) * 3 + 2
              iz = (iaglob(iatom)-1) * 3 + 3
              jx = (iaglob(jatom)-1) * 3 + 1
              jy = (iaglob(jatom)-1) * 3 + 2
              jz = (iaglob(jatom)-1) * 3 + 3
            end if
            if(iatom.ne.jatom) then
               FCM(ix,jx) = FCM(ix,jx) + FCMWRK(1,ij) 
               FCM(ix,jy) = FCM(ix,jy) + FCMWRK(2,ij)
               FCM(ix,jz) = FCM(ix,jz) + FCMWRK(3,ij)
               FCM(iy,jx) = FCM(iy,jx) + FCMWRK(4,ij)
               FCM(iy,jy) = FCM(iy,jy) + FCMWRK(5,ij)
               FCM(iy,jz) = FCM(iy,jz) + FCMWRK(6,ij)
               FCM(iz,jx) = FCM(iz,jx) + FCMWRK(7,ij)
               FCM(iz,jy) = FCM(iz,jy) + FCMWRK(8,ij)
               FCM(iz,jz) = FCM(iz,jz) + FCMWRK(9,ij)
C
               FCM(jx,ix) = FCM(jx,ix) + FCMWRK(1,ij) 
               FCM(jy,ix) = FCM(jy,ix) + FCMWRK(2,ij)
               FCM(jz,ix) = FCM(jz,ix) + FCMWRK(3,ij)
               FCM(jx,iy) = FCM(jx,iy) + FCMWRK(4,ij)
               FCM(jy,iy) = FCM(jy,iy) + FCMWRK(5,ij)
               FCM(jz,iy) = FCM(jz,iy) + FCMWRK(6,ij)
               FCM(jx,iz) = FCM(jx,iz) + FCMWRK(7,ij)
               FCM(jy,iz) = FCM(jy,iz) + FCMWRK(8,ij)
               FCM(jz,iz) = FCM(jz,iz) + FCMWRK(9,ij)
            else
               FCM(ix,jx) = FCM(ix,jx) + FCMWRK(1,ij) 
               FCM(ix,jy) = FCM(ix,jy) + FCMWRK(2,ij)
               FCM(ix,jz) = FCM(ix,jz) + FCMWRK(3,ij)
               FCM(iy,jx) = FCM(iy,jx) + FCMWRK(4,ij)
               FCM(iy,jy) = FCM(iy,jy) + FCMWRK(5,ij)
               FCM(iy,jz) = FCM(iy,jz) + FCMWRK(6,ij)
               FCM(iz,jx) = FCM(iz,jx) + FCMWRK(7,ij)
               FCM(iz,jy) = FCM(iz,jy) + FCMWRK(8,ij)
               FCM(iz,jz) = FCM(iz,jz) + FCMWRK(9,ij)
C
            end if 
         end do
      end do
      return
      end
c
C*MODULE FMOHSS  *DECK FMOCPHOP
C>
C>     @brief Add P^a contributions to CPHF equation 
C>
C>     @details Add (S DD S^a) contributions to FMO Hessian.
C>
C>     @author Hiroya Nakata 
C>
      SUBROUTINE FMOCPHOP(nocc,nvir,l1,l2,nxyz,WAX,nrot,AA,nocc2,
     *            SS,  SDER,DD,NAO,NMO,ILOC,PARRGO,WRK3,nomit,
     *           NOCCB,NOCC2B,NVIRB,AB,WAXB,CPHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION SDER(L2,3,NAT), DD(1),  SS(L1,*)
      DIMENSION WAX(nocc,nvir,*), AA(nocc2,*),WRK3(*)
      DIMENSION AB(nocc2b,*),WAXB(noccb,nvirb,*)
C
      PARAMETER (ONE=1.0D+00,TWO=2.0D+00,MXATM=5000,MXAO=2047)
      PARAMETER (ZERO=0.0D+00)
c
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IJPAIR/ IA(MXAO)
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      data UHF/8HUHF     /
c
      l3 = l1 * l1
      LC = L3 *  3 + 1
      if(nrot.eq.0) write(6,*) "dumm =",NMO,parrgo,NXYZ,lcrfrg
c     MAXIC = NATFMO
c     call setatz(1,MAXIC,fastvesp,lfvesp,needfv)
c      
      do 30 iatom = 1,nat
c       IAZ=IXFTCH(X(LIAGLOB),iatom)
c       icind=lfvesp+(IAZ-1)*6
c       FRACESPI=x(icind+1)
c       write(*,*) "fracespi =",fracespi,IAZ
        SCAL = TWO * TWO
c       if(fracespi.ge.0.5D+00.and.fracespi.ne.zero) go to 30
c       if(fracespi.ne.zero) go to 30
        do ixyz = 1,3          
          izxyz = (iatom - 1) * 3 + ixyz
          CALL CPYTSQ(SDER(1,ixyz,iatom),WRK3,l1,1)
          CALL CPYTSQ(DD,WRK3(l3+1),NAO,1)
C         S^a(l1,nao) * DD(NAO,NAO) *  S(l1,nao)^T
          CALL DGEMM('N','N',l1,NAO,NAO,ONE,WRK3(iloc*l1-l1+1),L1,
     *                wrk3(l3+1),NAO,ZERO, WRK3(L3*2+1),L1)
          CALL DGEMM('N','T',l1, l1,NAO,ONE,WRK3(l3*2+1),L1,
     *                SS(1,iloc),l1,ZERO, WRK3,L1)
          CALL SQ2TRI(L1,L1,WRK3,WRK3(l3+1),one)
C         C^T *  P * C   ( AO --> MO)
          CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LC),WRK3(2*l3+1),NQMT,l1,l1)
C         summing up contributions
          do 10 iocc = 1,nocc 
            do 20 jocc = 1,iocc
              IJ = IA(IOCC) + JOCC
              AA(ij,izxyz) = AA(ij,izxyz) + WRK3(IJ) * SCAL 
c             if(iatom.eq.3.and.ixyz.eq.3) write(*,*) WRK3(IJ),IJ
 20         continue
 10       continue
c         do 15 ivir = 1,nvir
          do 15 ivir = 1,nvir-nomit
            do 25 iocc = 1,nocc
              ij = IA(nocc+ivir) + iocc
              WAX(iocc,ivir,izxyz)=WAX(iocc,ivir,izxyz)+WRK3(IJ)*SCAL
c             if(iatom.eq.3.and.ixyz.eq.3) write(*,*) "val=",WRK3(IJ),IJ
 25         continue
 15       continue
          if(cphf.eq.uhf) then
           LCB = L3 * 4 + 1
           CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LCB),WRK3(2*l3+1),NQMT,l1,l1)
C          summing up contributions
           do iocc = 1,noccb
             do jocc = 1,iocc
               IJ = IA(IOCC) + JOCC
               AB(ij,izxyz) = AB(ij,izxyz) + WRK3(IJ) * SCAL 
c              if(iatom.eq.3.and.ixyz.eq.3) write(*,*) WRK3(IJ),IJ
             end do
           end do
c          do 15 ivir = 1,nvir
           do ivir = 1,nvirb
             do iocc = 1,noccb
               ij = IA(noccb+ivir) + iocc
               WAXB(iocc,ivir,izxyz)=WAXB(iocc,ivir,izxyz)+WRK3(IJ)*SCAL
c              if(iatom.eq.3.and.ixyz.eq.3) write(*,*) "val=",WRK3(IJ),IJ
             end do
           end do 
c          write(*,*) "added contributions to WAXB",
c    *                IJ,WAXB(noccb,nvirb,izxyz)
c          write(*,*) "U-a P^b terms",WRK3(IJ),noccb,nvirb
          end if
        end do
 30   continue
c
c     if(fastvesp) call retfm(needfv)
c
      return
      END
C
C*MODULE FMOHSS  *DECK FMOCPHOP2
C>
C>     @brief Add P^a contribution to CPHF equation 
C>
C>     @details Add (S DD^a S) contribution to CPHF equation.
C>
C>     @author Hiroya Nakata 
C>
      SUBROUTINE FMOCPHOP2(L1,IRGHT,LEFT,ILOC,PARRGO,JJ,JAT,
     *                    NAO,NMO,CLCAO,LDC,ROTLCAO,LDR,NSHELL,
     *                    KATOM,KTYPE,KLOC,KMIN,SHIFTB,IBDTYP,
     *                    IAPRJO,JAPRJO,ISIDE, SS,ZAXIS,BOND,
     *                    WAX,AA,WRK3,nomit,nocc,nvir,nocc2,
     *                    NOCCB,nocc2B,NVIRB,AB,WAXB,CPHF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXSH=1000, MXATM=5000,MXAO=2047)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00)
C
c     LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION CLCAO(LDC,NMO),ROTLCAO(LDR,NMO),
     *          KATOM(*),KTYPE(*),KLOC(*),KMIN(*)
      DIMENSION SHIFTB(MAXCAO,*),IAPRJO(MAXCAO,*),JAPRJO(MAXCAO,*)
      DIMENSION SS(L1,*),ZAXIS(3),BOND(3)
      DIMENSION WAX(nocc,nvir,*), AA(nocc2,*),WRK3(*)
      DIMENSION AB(nocc2b,*),WAXB(noccb,nvirb,*)
C
      COMMON /FMCOM / X(1)
      common /fmodim/ maxbnd,maxknd,maxcbs,maxcao,maxvec,maxl1,maxnat,
     *                maxabd,maxbas,maxbbd,maxlmo,maxslo,maxabd2
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /SYMTRY/ MAPSHL(MXSH,48),MAPCTR(MXATM,48),
     *                TT(432),INVT(48),NT
      COMMON /IJPAIR/ IA(MXAO)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      data UHF/8HUHF     /
C 
C     COMPUTE DERIVATIVES OF HOP COEFFICIENTS
      if(l1.eq.0) write(6,*) "PARRGO =",PARRGO
C 
      CALL VALFM(LOADFM)
      LPTRD  = LOADFM + 1
      LDTRD  = LPTRD  + 3*3
      LFTRD  = LDTRD  + 6*6
      LGTRD  = LFTRD  + 10*10
      LDROT  = LGTRD  + 15*15
      LAST   = LDROT  + LDR*NAO

      NEED  = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
C     wrk1 : LWAX
C     wrk2 : LAA
C     wrk3 : l3 * 4 free space
      l3   = l1 * l1
      lc   = l3 *  3 + 1
      ilin = 0
      irin = 0
      DO iatom = 1, nat
        IAZ=IXFTCH(X(LIAGLOB),iatom)
        if(iaz.eq.LEFT ) ilin = iatom
        if(iaz.eq.IRGHT) irin = iatom
      END DO
c     write(*,*) "in fmohop =",nomit
      DO IC = 1, 3
        CALL VECROTDER(ISKIP,IC,ZAXIS,BOND,TT)
        IF (ISKIP.EQ.0) THEN
          CALL TRMATDER(X(LPTRD),X(LDTRD),X(LFTRD),X(LGTRD))
          CALL VCLR(X(LDROT),1,LDR*NAO)
          ! note that nao is reset here
          CALL ROTCAO(JJ,JAT,X(LPTRD),X(LDTRD),X(LFTRD),X(LGTRD),NAO,
     *                NMO,CLCAO,LDC,X(LDROT),LDR,NSHELL,KATOM,KTYPE,
     *                KLOC,KMIN,.TRUE.)
c
          CALL VCLR(WRK3,1,NAO*NAO+l3)
          DO IMO = 1, NMO
            if(iside.eq.0.and.iaprjo(imo,ibdtyp).ne.0.or.
     *         iside.ne.0.and.japrjo(imo,ibdtyp).ne.0) then

             BSHIFT = SHIFTB(imo,ibdtyp)
             CALL DGEMM('N','T',NAO,NAO,1,BSHIFT,X(LDROT+LDR*(IMO-1)),
     *                   LDR,ROTLCAO(1,IMO),LDR,ZERO,WRK3,NAO)
             CALL DAXPY(NAO*NAO,ONE,WRK3,1,WRK3(l3+1),1)
            end if
          END DO
          CALL SQ2TRI(NAO,NAO,WRK3(l3+1),WRK3(l3*2+1),one)
          CALL TFTRI0(WRK3(l3+1),WRK3(L3*2+1),SS(ILOC,1),WRK3,
     *                L1,NAO,L1)
c       C^T *  P * C   ( AO --> MO)
          CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LC),WRK3(2*l3+1),NQMT,l1,l1)
          do 10 iocc = 1,nocc 
            do 20 jocc = 1,iocc
             IJ = IA(IOCC) + JOCC
             ll = (ilin - 1) * 3 + IC
             kk = (irin - 1) * 3 + IC
c            write(*,*) "IJ =",IJ,nocc2,WRK3(IJ)
             if(ilin.ne.0) AA(IJ,ll) = AA(IJ,ll) - WRK3(IJ) *two*two
             if(irin.ne.0) AA(IJ,kk) = AA(IJ,kk) + WRK3(IJ) *two*two
 20         continue
 10       continue
c         write(*,*) "U-a P^b terms"
c         do 15 mm = 1,nvir
          do 15 mm = 1,nvir - nomit
            do 25 ii = 1,nocc
              ij = IA(nocc+mm) + ii
              ll = (ilin - 1) * 3 + IC
              kk = (irin - 1) * 3 + IC
c             write(*,*) "IJ =",IJ,WRK3(IJ)
             if(ilin.ne.0) 
     *          wax(ii,mm,ll) = wax(ii,mm,ll) - WRK3(IJ) * two * two
             if(irin.ne.0)                                          
     *          wax(ii,mm,kk) = wax(ii,mm,kk) + WRK3(IJ) * two * two
 25         continue
 15       continue
          IF(CPHF.EQ.UHF) THEN
           LCB  = l3 *  4 + 1
           CALL TFTRI(WRK3,wrk3(l3+1),wrk3(LCB),WRK3(2*l3+1),NQMT,l1,l1)
           do    iocc = 1,noccb
             do    jocc = 1,iocc
              IJ = IA(IOCC) + JOCC
              ll = (ilin - 1) * 3 + IC
              kk = (irin - 1) * 3 + IC
c             write(*,*) "IJ =",IJ,nocc2,WRK3(IJ)
              if(ilin.ne.0) AB(IJ,ll) = AB(IJ,ll) - WRK3(IJ) *two*two
              if(irin.ne.0) AB(IJ,kk) = AB(IJ,kk) + WRK3(IJ) *two*two
             end do
           end do
c          do 15 mm = 1,nvir
           do    mm = 1,nvirb
             do    ii = 1,noccb
               ij = IA(noccb+mm) + ii
               ll = (ilin   - 1) * 3 + IC
               kk = (irin   - 1) * 3 + IC
c              write(*,*) "IJ =",IJ,WRK3(IJ)
              if(ilin.ne.0) 
     *          waxb(ii,mm,ll) = waxb(ii,mm,ll) - WRK3(IJ) *two*two
              if(irin.ne.0)                                          
     *          waxb(ii,mm,kk) = waxb(ii,mm,kk) + WRK3(IJ) *two*two
             end do
           end do
          END IF
        END IF
      END DO
c
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE FMOHSS  *DECK HOPSHSS
C>
C>     @brief Add P^ab contribution to FMO Hessian
C>
C>     @details Add P^ab contribution to FMO Hessian.
C>
C>     @author Hiroya Nakata 
C>
      SUBROUTINE HOPSHSS(L1,L2,ILOC,NAO,PARRGO,SDER,DD,DENS,SS,
     *                   WRK1,WRK2,WRK3,FCM)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      PARAMETER (MXATM=5000)
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+00,two=2.0D+00)
  
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL PARRGO
      DIMENSION SDER(L2,*), DD(1), DENS(1), SS(L1,*)
      DIMENSION WRK1(L1,*), WRK2(L1,*),WRK3(*)
      DIMENSION FCM(natfmo*3,*)

      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /MACHIN/ NWDVAR,MAXFM,MAXSM,LIMFM,LIMSM
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
c     COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
C
C     SDER is Overlap derivative, DD is projection matrix
C     DENS is Density matrix (density or symmetrized ZVEC)
C     SS   is Overlap matrix in the square form  
      if(l1.eq.0) write(6,*) "jjjjj =",PARRGO
      L3   = l1   * l1
      LC   = l3   * 3   + 1
c     NLOC = ILOC + NAO - 1
c     call vclr(FCM,1,negh)
c     write(*,*) "check01 =",NAO,ILOC
      CALL TFTRI0(WRK1,DD,SS(ILOC,1),WRK3,L1,NAO,L1)
      CALL TFTRI(WRK3(l3+1),wrk1,wrk3(LC),WRK3,NQMT,l1,l1)
      IJ = 0
      DO 130 I = 1,L1
         DO 120 J = 1,I
            IJ = IJ+1
            DUM = ZERO
            DO 110 K = 1,NA
               II  = LC + l1 * (K - 1)  + I - 1
               JJ  = LC + l1 * (K - 1)  + J - 1
               KK  = (K * K  - K)/2 + 1 + L3
               DUM = DUM+WRK3(KK)*WRK3(II)*WRK3(JJ)
  110       CONTINUE
c           WRK3(IJ) = DUM + DUM
            WRK3(IJ) = DUM 
  120    CONTINUE
  130 CONTINUE
C-
      do 200 iat =  1,nat
        IAZ=IXFTCH(X(LIAGLOB),IAT)
        do ixyz = 1,3
          izxyz = (iaz - 1) * 3 + ixyz
          ii    = (iat - 1) * 3 + ixyz 
c         CALL CPYTSQ(DENS,WRK3,L1,1)
          CALL CPYTSQ(SDER(1,ii),WRK2,L1,1)
          CALL CPYTSQ(WRK3,WRK3(L3+1),L1,1)
          CALL DGEMM('N','N',L1,L1,L1,ONE,WRK2,L1,wrk3(l3+1),L1,ZERO,
     *               WRK1,L1)
          do 100 jat = 1,nat
            JAZ=IXFTCH(X(LIAGLOB),JAT)
            do jxyz = 1,3
              jzxyz = (jaz - 1) * 3 + jxyz
              jj    = (jat - 1) * 3 + jxyz
              CALL CPYTSQ(SDER(1,jj),WRK2,L1,1)
              CALL DGEMM('N','N',L1,L1,L1,ONE,WRK1,L1,wrk2,L1,ZERO,
     *               WRK3(l3+1),L1)
              CALL CPYTSQ(DENS,WRK2,L1,1)
              val = ddot(l1*l1,WRK3(L3+1),1,WRK2,1) 
C   
              FCM(izxyz,jzxyz) =  FCM(izxyz,jzxyz) - val  
              FCM(jzxyz,izxyz) =  FCM(jzxyz,izxyz) - val  
c             write(*,*) "val01  =",val,izxyz,jzxyz
            end do
 100      continue          
        end do
 200  continue
C
C
      CALL VALFM(LOADFM)
      NGOTMX=LIMFM-LOADFM
c     
      LSX    = 1     + LOADFM
      LSY    = LSX   + L2
      LSZ    = LSY   + L2
      LDSDX  = LSZ   + L2
      LDSDY  = LDSDX + L3
      LDSDZ  = LDSDY + L3
      LDE    = LDSDZ + L3
      LDH    = LDE   + NAT * 3
      LAST   = LDH   + (NAT+NAT*NAT)*9/2
      NEED   = LAST  - LSX
      IF(NEED.GT.NGOTMX) THEN
         IF (MASWRK) WRITE(6,*) 'IN SD, NEED,NGOT=',NEED,NGOTMX
         CALL ABRT
      END IF
      CALL GETFM(NEED)
c 
      NEGH = 3*NAT+9*(NAT*(NAT+1))/2
      CALL VCLR(X(LDE),1,NEGH)
      CALL VCLR(X(LDSDX),1,L3)
      CALL VCLR(X(LDSDY),1,L3)
      CALL VCLR(X(LDSDZ),1,L3)
C
      CALL DSCAL(L2,two,wrk3,1)
C
      CALL SDSPD(X(LDE),x(LDH),WRK3,X(LSX),X(LSY),X(LSZ),
     *           X(LDSDX),X(LDSDY),X(LDSDZ),.false.,WRK1,.false.)
      IF(GOPARR) CALL DDI_GSUMF(1625,x(LDE),NEGH)
      call addhss(nat,natfmo,x(LDH),FCM,1,x(liaglob))
C
C-
C
      CALL RETFM(NEED)
      RETURN
      END
C
C*MODULE FMOHSS  *DECK FMOESP_CPFCK
C>    @brief Calculate derivative of ESP terms
C>
C>    @details Calculate the electrostatic potential derivative 
C>    for B^a matrix to solve CPHF
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param   L1      Number of atomic orbital
C>    @param   L2      Number of elements in triangular matrix of AO
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   LFG     Fragment indice in current for trimer
C>    @param IDMREC0   Record number to read orbital
C>    @param SCFFRG    SCFTYP for fragment (for UHF or ROHF)
C>           --- OUTPUT ---
C>    @param DV        Derivative of ESP with respect to cartesian coordinate in FMO
      SUBROUTINE FMOESP_CPFCK(DV,L1,L2,IFG,JFG,LFG,IDMREC0,SCFFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=5000,MXSH=1000,MXGTOT=5000,MXRT=5000)
      PARAMETER (MXGSH=30,MXG2=MXGSH*MXGSH,MAXL=5)
      PARAMETER (TWO=2.0D+00,HALF=0.5D+00,ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK,SAVGOP,NXT
      LOGICAL ESPPAR,LARGEPRI,DODDCOR,BSSEDIM,PACK2E
      DIMENSION DV(L2,*),IDMREC0(*),SCFFRG(*)
      DIMENSION KARTEN(0:MAXL-1)
C
      COMMON /FMCOM / X(1)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm,ndualb
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,NZMTFMO,ifmobas
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      DATA KARTEN/1,4,6,10,15/ 
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
C
C
c     irec0=ixftch(x(lidmrec),ICURLAY)
C
C     write(*,*) "NQMT =",NQMT
C
      call TVD_CPHF(DV)
C
      CALL DSCAL(L2*NAT*3,TWO,DV,1)
      do I = 1,NAT*3
         II=0
         DO JJ=1,L1
           II = II+JJ
           DV(II,I) = DV(II,I) * HALF
         ENDDO
      end do
C
C
      ILAY    = ICURLAY
      KFG0    = 1
      KFG1    = NFG
c     NATA    = NAT
c     IZ      = 1
      ESPPAR=MOD(MODPAR/2,2).NE.0.AND.GOPARR
c     RESPAPI =RESPAP(IZ)
c     RESPPCI =RESPPC(IZ)
C
C
      CALL MONBSR(NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR,
     *            NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,
     *            NCURSH,NGAU0,ENUCR0)
C
      NE0C=NE0+ICH0
      LOADHF=MOD(MODPAR,2)
      LARGEPRI=LOADHF.EQ.1.AND.ESPPAR
      DODDCOR=IAND(IXESP,1024).NE.0
C
C     ----- INITIALIZATION FOR PARALLEL WORK -----
C
      NXT = IBTYP.EQ.1
      NEXT  = -1
      KOUNT = -1
C     ESP WILL BE COMPUTED IN THE DIRECT FASHION
C
      DO 100 KKFG=KFG0,KFG1
C
        IF(LARGEPRI) THEN
          KFG=IXFTCH(X(LLOADM),KKFG)
        ELSE
          KFG=KKFG
        ENDIF
C
        IF(IFG.EQ.KFG.OR.JFG.EQ.KFG.OR.LFG.EQ.KFG) GOTO 100
C
        IF(ESPPAR) THEN
          KOUNT=KOUNT+1
          IF(GOPARR) THEN
            IF(NXT) THEN
              IF(KOUNT.GT.NEXT) CALL DDI_DLBNEXT(NEXT)
              IF(NEXT.NE.KOUNT) GOTO 100
            ELSE
              IF(MOD(KOUNT,NPROC).NE.ME) GOTO 100
            ENDIF
          ENDIF
          SAVGOP=GOPARR
          GOPARR=.FALSE.
c         GOPARR IS SET TO .FALSE. TO PREVENT SHELL-BASED WORK DIVISION
C         INSIDE OF EXCHNG AND FMOESP. 
C         NOTE THAT SHELL-BASED WORK DIVISION IS USED FOR ESPPAR=.FALSE. 
        ENDIF
        KLAY=MIN(ILAY,ixftch(x(llayfrg),KFG))
        BSSEDIM=NBSSE.EQ.2.AND.IFMOSTP.EQ.5
        KFGX = KFG
C
C
        CALL MAKEMOL(KFGX,0,0,KLAY,0,NAT0,NCURSH,NGAU0,NE0C,ICH0,MUL0,
     *               .FALSE.)
C
        L1K=NUM-NUM0
        L2K=(L1K*L1K+L1K)/2
        L3K=L1K*L1K 
c       natk = nat - nat0
C
        IREC0=IDMREC0(KLAY)
        IF(DODDCOR) THEN
          IREC0RHF=1
          IF(IREC0.EQ.1) IREC0RHF=NFG*2+1
          IREC0=IREC0RHF
        ENDIF
C
CC
        IDMREC0K=KFG+IREC0
        NAK  = ISHFT(IXFTCH(X(LNUMFRG),KFG),-16) 
        NBK  = NAK
C       FOR UHF
        IF(SCFFRG(KFG).EQ.UHF.OR.SCFFRG(KFG).EQ.ROHF) THEN
          MULK = IXFTCH(X(LMULFG),KFG)
          NBK  = NAK - MULK + 1
        END IF
C
C
C
        CALL BASCHK(LMAX)
        IF(LMAX.GE.5) THEN
           IF(MASWRK) WRITE(6,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
           CALL ABRT
        END IF
        NANGM= KARTEN(MAX(LMAX,1))
        MAXG = NANGM**4
C
        lenrec = L3K + L1K
        if(scffrg(kfg).eq.uhf) lenrec= L3K+L1K+L3K+L1K
C
        CALL VALFM(LOADFM)
        CALL GOTFM(NGOTMX)
C
        NSH2    = (NSHELL + NSHELL * NSHELL)/ 2
        LXCHNG  = LOADFM  + 1
        LGHOND  = LXCHNG  + NSH2
        LDDIJ   = LGHOND  + MAXG
        LWRK    = LDDIJ   +  49 * MXG2  
        LAST    = LWRK    + L2K + lenrec
C
        NEEDK   =  LAST   - LOADFM -1
        if(NEEDK.gt.NGOTMX) then
            write(6,*) "Can not allocate  memory in fmohss"
            write(6,*) "NEED = ",NEEDK,"MAX =",NGOTMX
            call abrt
        end if
C
        CALL GETFM(NEEDK)
C
CC
        CALL RAREADS(IDAFMO,X(LIODFMO),X(LWRK+L2K),lenrec,
     *               IDMREC0K,0)
CC     Outside Density K
        if(scffrg(kfg).eq.uhf) then
          CALL DMTX2(X(LWRK),X(LWRK+L2K),NAK,L1K,L1K,0) 
          CALL DMTX2(X(LWRK+L2K),X(LWRK+L2K+L3K),NBK,L1K,L1K,0) 
          CALL DAXPY(L2K,ONE,X(LWRK+L2K),1,X(LWRK),1)
        else
          CALL DMTX2(X(LWRK),X(LWRK+L2K),NAK,L1K,L1K,NBK) 
        end if
C
        IST=1
        JST=1
        KST=1
        LST=1
        CALL JANDK
        CALL EXCHNG(X(LXCHNG),X(LGHOND),X(LDDIJ), NSH2,MAXG,INTTYP)
C
        call FMO2_CPHF(IFG,JFG,KFG,L1,L1K,
     *     X(LWRK),L2K,DV,L2,nat0,BSSEDIM,X(LXCHNG)) 
C
        IF(ESPPAR) GOPARR=SAVGOP
        CALL RETFM(NEEDK)
 100  CONTINUE
C
      IF (GOPARR) THEN
          CALL DDI_GSUMF(1605,DV,3*NAT0*L2)
      END IF
C
      CALL DSCAL(3*NAT0*L2,HALF,DV,1)
      do i = 1, NAT0 * 3
         II=0
         DO JJ=1,L1
           II = II+JJ
           DV(II,i) = DV(II,i) + DV(II,i)
         ENDDO
      end do
C
      CALL MAKEMOL(IFG,JFG,LFG,ILAY,0,0,0,0,0,0,0,.TRUE.)
C
      CALL MONBSR(NAT0,ICH0,MUL0,NUM0,NQMT0,NE0,NA0,NB0,NCURSH,NGAU0,
     *           ENUCR0,NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,NSHELL,NGAU,ENUCR)
C
      NCURSH = 0
C
C     write(*,*) "NQMT =",NQMT
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK ADD_ESPDER
C>    @brief Adder ESP derivative term to WAX
C>
C>    @details Added ESP terms to second order derivative of energy
C>    with respect to the orbital and coordinate
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine written
C>
C>           --- INPUT ---
C>    @param   L1      Number of atomic orbital
C>    @param NNXYZ     Number of unique cartesian coodinate elements
C>    @param NOCC      Number of occupied molecular orbital
C>    @param NVIR      Number of virtual  molecular orbital
C>    @param DV        Derivative of ESP with respect to cartesian coordinate in FMO
C>    @param   L2      Number of elements in triangular matrix of AO
C>    @param WRK3      Temporary work for ESP derivative
C>    @param  SCAL     Scal factor to control closed or open shell orbital
C>    @param  VEC      molecular orbital coefficient
C>           --- OUTPUT ---
C>    @param WAX       Derivative of energy with respect to MO and coordiante 
      SUBROUTINE ADD_ESPDER(L1,NNXYZ,WAX,NOCC,NVIR,DV,L2,WRK3,SCAL,VEC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION WAX(NOCC,NVIR,NNXYZ),DV(L2,NNXYZ),WRK3(*)
      DIMENSION VEC(*)
      PARAMETER (MXATM=5000)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C      
       
      L3 = L1 * L1
C
      DO ixyz = 1,NNXYZ
C
        CALL TFTRI(WRK3(L3+1),DV(1,ixyz),VEC,WRK3,NQMT,l1,l1)
        CALL CPYTSQ(WRK3(l3+1),WRK3,NQMT,1)
C
        DO IVIR= 1,NVIR
          DO IOCC = 1,NOCC
            III = IOCC + (IVIR + NOCC - 1) * NQMT
            WAX(IOCC,IVIR,ixyz)=WAX(IOCC,IVIR,ixyz) + WRK3(III) * SCAL
          END DO
        END DO
C
      END DO
C
      RETURN
      END
C
C
C*MODULE FMOHSS  *DECK FMODDMNUC
C>    @brief Nuclear atom contribution to Derivative of dipolemoment
C>
C>    @details Calculate dipole mooment derivative terms 
C>     of nuclear coordinate and charge if necessary
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine writte
C>
C>           --- INPUT ---
C>    @param  NFG      number of fragment
C>    @param  ZAN      atomic nuclear charge
C>    @param ZMASS     nuclear mass
C>    @param  NAT      number of atom in fragments
C>    @param ichfg     number of charge in fragments
C>           --- OUTPUT---
C>    @param  ddm      dipole derivative momens
      SUBROUTINE FMODDMNUC(NFG,ZAN,ZMASS,NAT,ichfg,ddm)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION ZAN(*)
      DIMENSION ZMASS(*)
      DIMENSION DDM(9,*)
      DIMENSION ichfg(*)
C
      ICH=0
      DO IFG=1,NFG
       ICH=ICH+ichfg(ifg)
      END DO
C
c     write(6,*) "ICH=",ICH,NAT
C
      total_mass = 0.0D+00
      DO  I=1,NAT
         total_mass = total_mass + ZMASS(I)
      enddo
C
      DO 4 L=1,9,4
         DO 5 N=1,NAT
            DDM(L,N)=DDM(L,N) + ZAN(N) *4.803242D+00
C     This is the contribution to charged molecules that results
C     from using the center of mass as the origin.
            DDM(L,N)=DDM(L,N) -
     &           4.803242D+00 * ICH * zmass(N) / total_mass
c         write(6,'("MASS =",I3,2F10.7)') N,zmass(N),ZAN(N)
    5    CONTINUE
    4 CONTINUE
C
      RETURN
      END 
c
C*MODULE FMOHSS  *DECK ESDHSS
C>    @brief Second order derivatiev of energy separated dimers
C>
C>    @details  Main driver to allocate memory, and calculate
C>      for all the contribution of separated dimers to Hessian
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param NDER      Energy derivative order
C>    @param SCFFRG    SCFTYP for fragment (for UHF or ROHF)
C>    @param IREC0     Record number to read orbital in the fragments
C>    @param YALAG     The solution of alpha orbital relaxation term for entire systems 
C>    @param IPTYA     The pointer  for YALAG
C>    @param numfrg    number of AO basis in the respective fragments
C>    @param NQMTFG    number of MO basis in the respectvie fragments
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   DI      Density for IFG
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   DJ      Density for JFG
C>    @param LAYFRG    Layer information for respective fragments
C>           --- OUTPUT ---
C>    @param    FCM    Foce constant matrix
      SUBROUTINE ESDHSS(NDER,FCM,scffrg,irec0,YALAG,IPTYA,numfrg,
     *           NQMTFG,IFG,DI,JFG,DJ,LAYFRG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=5000,MXSH=1000,MXGTOT=5000, MXRT=5000 )
      PARAMETER (ONE=1.0D+00)
      LOGICAL GOPARR,DSKWRK,MASWRK
      LOGICAL FIRST,SECND,CPHF,BOTH,MFIRST,MSECND,MCPHF 
      Common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /HSSPAR/ FIRST,SECND,CPHF,BOTH,MFIRST,MSECND,MCPHF
      common /fmorun/ espscf,e0scf(2),emp2s,IDAFMO,icurfg,jcurfg,kcurfg,
     *                icurlay,icurunt,nat1e,ncursh,ngau,icurpop,ifmostp,
     *                moncor,needr,modrst,norbproj,nunesp,iskipesp,
     *                IESDPPC,idoprop,mp2run,icurit,idmfmo,iddfmo,
     *                iddcur,nddleft,ivmfmo,NZMTFMO,ifmobas
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /ENRGYS/ ENUCR,EELCT,ETOT,SZ,SZZ,ECORE,ESCF,EERD,E1,E2,
     *                VEN,VEE,EPOT,EKIN,ESTATE(MXRT),STATN,EDFT(2),EDISP
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
C
      DIMENSION FCM(natfmo*3,*),SCFFRG(*)
      DIMENSION numfrg(*),NQMTFG(*)
      DIMENSION YALAG(*),IPTYA(*),DI(*),DJ(*)
      DIMENSION LAYFRG(*)
C
      DATA UHF/8HUHF     /
C
      FIRST=.TRUE.
      SECND=.TRUE.
      CPHF=.TRUE.
      BOTH=.TRUE.
      MFIRST=.TRUE.
      MSECND=.TRUE.
      MCPHF=.TRUE.
C
      ilay=layfrg(ifg)
      jlay=layfrg(jfg)
      IF(NDER.ne.2) write(6,*) IPTYA(1),NUMFRG(1),YALAG(1)
C
      call makemol(ifg,0,0,ilay,0,0,0,0,0,0,0, .false.)
C
      call monbsr(nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr,
     *            nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,
     *            ncursh,ngau0,enucr0)
      NE0C=NE0+ICH0
C
C     IF(MASWRK) write(*,*) "Second order derivative for ES-DIM terms"
C
      NATI = NAT
      l1I  = num
      L2I  = (L1I*L1I+L1I)/2
      L3I  = L1I*L1I 
C
      MULI = IXFTCH(X(LMULFG),IFG)
      NAI  = NA
      NBI  = NA - MULI + 1 
C
c     write(*,*) "INFO IFG=",IFG,NATI,l1I,NAI,NBI,NQI,ncursh
C
      call makemol(jfg,0,0,jlay,0,nat0,ncursh,ngau0,ne0c,ich0,mul0,
     *               .false.)
C
      NATJ = NAT-NATI
      l1J  = num - l1I
      L2J  = (L1J*L1J+L1J)/2
      L3J  = L1J*L1J 
c     NQJ  = IAND(NQMTFG(JFG),65535) 
      MULJ = IXFTCH(X(LMULFG),JFG)
      NAJ  = NA - NAI 
      NBJ  = NAJ-MULJ+1
C
C
      lenrecj= L3J + L1J
      lenreci= L3I + L1I
      if(scffrg(jfg).eq.uhf)  lenrecj = L3J * 2 + L1J * 2
      if(scffrg(ifg).eq.uhf)  lenreci = L3I * 2 + L1I * 2
      
C
      CALL rareads(IDAFMO,x(liodfmo),DJ(l2j+1),lenrecj,jfg+irec0,0)
      if(scffrg(jfg).eq.uhf) then
        call DMTX2(DJ,DJ(l2j+1),naj,l1j,l1j,0)
        call DMTX2(DJ(l2j+1),DJ(l2j+1+l3j),nbj,l1j,l1j,0)
        CALL DAXPY(L2J,ONE,DJ(L2J+1),1,DJ,1)
        CALL rareads(IDAFMO,x(liodfmo),DJ(l2j+1),lenrecj,jfg+irec0,0)
      else
        call DMTX2(DJ,DJ(l2j+1),naj,l1j,l1j,nbj)
      end if
C
      CALL rareads(IDAFMO,x(liodfmo),DI(l2i+1),lenreci,ifg+irec0,0)
      if(scffrg(ifg).eq.uhf) then
        call DMTX2(DI,DI(L2I+1),NAI,L1I,L1I,0)
        call DMTX2(DI(l2I+1),DI(L2I+1+L3I),NBI,L1I,L1I,0)
        CALL DAXPY(L2I,ONE,DI(L2I+1),1,DI,1)
        CALL rareads(IDAFMO,x(liodfmo),DI(l2i+1),lenreci,ifg+irec0,0)
      else
        call DMTX2(DI,DI(L2I+1),NAI,L1I,L1I,NBI)
      end if
C
      CALL ESDNHSS(NATI,FCM,X(liaglob),natfmo)
C
c     IF(MASWRK) write(*,*) "testtesttest00",IFG,L1I,NAI
c     IF(MASWRK) write(*,'(5f12.8)') (DI(iii+L2I),iii=1,l3i)
c     IF(MASWRK) write(*,*) "testtesttest10",JFG,L1J,NAJ
c     IF(MASWRK) write(*,'(5f12.8)') (DJ(iii+L2J),iii=1,l3j)
c     write(*,*) "INFO IFG NAT=",NAT
C
C    allocate memory 
      CALL VALFM(LOADFM)
      LEG  = LOADFM + 1
      LEH  = LEG    + 3 *  NATFMO
      LFDI = LEH    + 9 * (NATFMO*NATFMO+NATFMO)/2
      LFDJ = LFDI   + 3 *  NAT * L2I 
      LAST = LFDJ   + max(3 *  NAT * L2J, 6 * L2I * NATJ)
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C 
      NFD  = 3 * NAT    * (L2I + L2J)
      NEGH = 3 * NATFMO + 9 * (NATFMO * (NATFMO+1))/2
C
      call vclr(x(leg),1,NEGH)
      call vclr(x(lfdi),1,NFD)
C
C     Second order derivative for 1e integral 
      CALL ESDIMhss1a(IFG,l1I,DI,LFDI,NATI,
     *                JFG,l1J,DJ,LFDJ,NATJ,
     *                LEG,LEH)
c
C
c     Second derivative for two-electron terms
      call ESDIMhss2a(IFG,L1I,nai,nbi,nati,DI,LFDI,ILAY,
     *                JFG,L1J,naj,nbj,natj,DJ,LFDJ,JLAY,
     *                X(LIAGLOB),X(LEG), X(LEH),NQMTFG,
     *                x(LLAYFRG),FCM,SCFFRG)
c
C
c
      IF(GOPARR) CALL DSCAL(natfmo*natfmo*9,1.0D+00/NPROC,FCM,1)
C
      call addhss(natfmo,natfmo,X(LEH),FCM,0,x(liaglob))
C
      CALL RETFM(NEED)
C
      call monbsr(nat0,ich0,mul0,num0,nqmt0,ne0,na0,nb0,ncursh,ngau0,
     *           enucr0,nat,ich,mul,num,nqmt,ne,na,nb,nshell,ngau,enucr)
C


      RETURN
      END
c
C*MODULE FMOHSS  *DECK ESDNHSS
C>    @brief Second order derivatiev of ES-DIM for nuclear coordinate
C>
C>    @details  Contribution of nuclear coordinate for ES-DIM
C>
C>    @author Hiroya Nakata
C>    - APR, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param  NATI     number of atom 
C>    @param    iaglob global label for atom
C>    @param    natfmo total number of atoms in the system
C>           --- OUTPUT ---
C>    @param    FCMWRK Foce constant matrix
      SUBROUTINE ESDNHSS(nati,FCMWRK,iaglob,natfmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER (MXATM=5000)
      PARAMETER (TWO=2.0D+00,THREE=3.0D+00)
c     logical GOPARR,DSKWRK,MASWRK
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      DIMENSION FCMWRK(natfmo*3,*),iaglob(*)
      DIMENSION SDR(9)

C
      DO 40 IAT = NATI+1,NAT
        ZAI = ZAN(IAT)
      DO 40 JAT = 1,NATI
        IF(IAT.eq.JAT) GO TO 40
        ZAJ = ZAN(JAT)
C
        RX = C(1,IAT) - C(1,JAT)
        RY = C(2,IAT) - C(2,JAT)
        RZ = C(3,IAT) - C(3,JAT)
        RIJ= SQRT(RX*RX+RY*RY+RZ*RZ)
        RD = (RIJ**5)
        RXX = RX * RX
        RYY = RY * RY
        RZZ = RZ * RZ
C
C
        SDR(1) = ( TWO * RXX - RYY - RZZ )/RD
        SDR(5) = ( TWO * RYY - RZZ - RXX )/RD
        SDR(9) = ( TWO * RZZ - RXX - RYY )/RD
        SDR(2) = ( THREE * RX * RY )/RD
        SDR(4) = SDR(2)
        SDR(3) = ( THREE * RZ * RX )/RD
        SDR(7) = SDR(3)
        SDR(6) = ( THREE * RY * RZ )/RD
        SDR(8) = SDR(6)
C
        ZAIJ = ZAI * ZAJ
C
C
        DO 42 I = 1,9
   42     SDR(I) = ZAIJ * SDR(I)
C
C       write(*,*) "RD00 =",SDR(1),SDR(5),SDR(9)
C
        IZAT   = iaglob(IAT)
        JZAT   = iaglob(JAT)
        IX     = IZAT * 3 - 2
        IY     = IZAT * 3 - 1
        IZ     = IZAT * 3    
        JX     = JZAT * 3 - 2
        JY     = JZAT * 3 - 1
        JZ     = JZAT * 3    
C
        FCMWRK(IX,IX) = FCMWRK(IX,IX) + SDR(1) 
        FCMWRK(IY,IX) = FCMWRK(IY,IX) + SDR(2) 
        FCMWRK(IZ,IX) = FCMWRK(IZ,IX) + SDR(3) 
        FCMWRK(IX,IY) = FCMWRK(IX,IY) + SDR(4) 
        FCMWRK(IY,IY) = FCMWRK(IY,IY) + SDR(5) 
        FCMWRK(IZ,IY) = FCMWRK(IZ,IY) + SDR(6) 
        FCMWRK(IX,IZ) = FCMWRK(IX,IZ) + SDR(7) 
        FCMWRK(IY,IZ) = FCMWRK(IY,IZ) + SDR(8) 
        FCMWRK(IZ,IZ) = FCMWRK(IZ,IZ) + SDR(9) 
C
C
        FCMWRK(IX,JX) = FCMWRK(IX,JX) - SDR(1) 
        FCMWRK(IY,JX) = FCMWRK(IY,JX) - SDR(2) 
        FCMWRK(IZ,JX) = FCMWRK(IZ,JX) - SDR(3) 
        FCMWRK(IX,JY) = FCMWRK(IX,JY) - SDR(4) 
        FCMWRK(IY,JY) = FCMWRK(IY,JY) - SDR(5) 
        FCMWRK(IZ,JY) = FCMWRK(IZ,JY) - SDR(6) 
        FCMWRK(IX,JZ) = FCMWRK(IX,JZ) - SDR(7) 
        FCMWRK(IY,JZ) = FCMWRK(IY,JZ) - SDR(8) 
        FCMWRK(IZ,JZ) = FCMWRK(IZ,JZ) - SDR(9) 
C
C
        FCMWRK(JX,IX) = FCMWRK(JX,IX) - SDR(1) 
        FCMWRK(JY,IX) = FCMWRK(JY,IX) - SDR(2) 
        FCMWRK(JZ,IX) = FCMWRK(JZ,IX) - SDR(3) 
        FCMWRK(JX,IY) = FCMWRK(JX,IY) - SDR(4) 
        FCMWRK(JY,IY) = FCMWRK(JY,IY) - SDR(5) 
        FCMWRK(JZ,IY) = FCMWRK(JZ,IY) - SDR(6) 
        FCMWRK(JX,IZ) = FCMWRK(JX,IZ) - SDR(7) 
        FCMWRK(JY,IZ) = FCMWRK(JY,IZ) - SDR(8) 
        FCMWRK(JZ,IZ) = FCMWRK(JZ,IZ) - SDR(9) 
C
C
        FCMWRK(JX,JX) = FCMWRK(JX,JX) + SDR(1) 
        FCMWRK(JY,JX) = FCMWRK(JY,JX) + SDR(2) 
        FCMWRK(JZ,JX) = FCMWRK(JZ,JX) + SDR(3) 
        FCMWRK(JX,JY) = FCMWRK(JX,JY) + SDR(4) 
        FCMWRK(JY,JY) = FCMWRK(JY,JY) + SDR(5) 
        FCMWRK(JZ,JY) = FCMWRK(JZ,JY) + SDR(6) 
        FCMWRK(JX,JZ) = FCMWRK(JX,JZ) + SDR(7) 
        FCMWRK(JY,JZ) = FCMWRK(JY,JZ) + SDR(8) 
        FCMWRK(JZ,JZ) = FCMWRK(JZ,JZ) + SDR(9) 
C
      
      
   40 CONTINUE
C

      RETURN
      END
C
C*MODULE FMOHSS  *DECK ESDIMhss1a
C>    @brief Second order derivatiev of ES-DIM for one electron integral
C>
C>    @details  Contribution of one electron integral for ES-DIM
C>
C>    @author Hiroya Nakata
C>    - Apr, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   L1I     Number of atomic orbital in IFG
C>    @param   DI      Density for IFG
C>    @param   LFDI    Derivative of Fock matrix elements in IFG
C>    @param  NATI     number of atom in IFG
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   L1J     Number of atomic orbital in JFG
C>    @param   DJ      Density for JFG
C>    @param   LFDJ    Derivative of Fock matrix elements in JFG
C>    @param  NATJ     number of atom in JFG
C>    --- OUTPUT ---
C>    @param   LEG     Derivative of energy 
C>    @param   LEH     Second Derivative of energy 
      SUBROUTINE ESDIMhss1a(IFG,l1I,DI,LFDI,NATI,
     *                      JFG,l1J,DJ,LFDJ,NATJ,
     *                      LEG,LEH)

      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C
      PARAMETER (MXATM=5000,TWO=2.0D+00,HALF=0.5D+00)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)

      COMMON /FMCOM / X(1)

      DIMENSION DI(*),DJ(*)
C
      if(IFG.eq.0) write(6,*) "JFG=",JFG,NATJ
C
      L2I = (L1I + L1I * L1I) / 2
      L2J = (L1J + L1J * L1J) / 2
c     L2  =  L2I + L2J
      NFD = (L2I + L2J) * NAT * 3
C
C     HELMANN-FEYNMAN TERMS
      call ESDIM_HLF(x(LEG),x(LEH),
     *               DI,l1I,l2I,x(LFDI),NATI, 
     *               DJ,l2J,x(LFDJ)) 
c
C
C
C     Coupling terms
      call ESDIM_HFD(x(LEH),DI,l1I,NATI,DJ) 
C
C     Nuclear atraction
      call ESDIM_TVD(X(LEG),X(LEH),
     *               DI,l1I,l2I,x(LFDI),NATI,
     *               DJ,l2J,x(LFDJ))
c
C
C
      CALL DSCAL(NFD,two,x(LFDI),1)
      do i = 1,nat*3
         II=0
         DO JJ=1,L1I
           II = II+JJ
           x(LFDI+II-1+l2i*(i-1)) = x(LFDI+II-1+l2i*(i-1)) * half
         ENDDO
         II=0
         DO JJ=1,L1J
           II = II+JJ
           x(LFDJ+II-1+l2j*(i-1)) = x(LFDJ+II-1+l2j*(i-1)) * half
         ENDDO
      end do
C
C
      RETURN
      END

C
C
C*MODULE FMOHSS  *DECK ESDIMhss2a
C>    @brief Second order derivatiev of ES-DIM for two electron integral
C>
C>    @details  Contribution of two-electron integral for ES-DIM
C>
C>    @author Hiroya Nakata
C>    - Apr, 2013- Subroutine writte
C>           --- INPUT ---
C>    @param   IFG     Fragment indice in current for monomer
C>    @param   L1I     Number of atomic orbital in IFG
C>    @param   nai     number of alpha electron for ifg
C>    @param   nbi     number of beta  electron for ifg
C>    @param  NATI     number of atom in IFG
C>    @param   DI      Density for IFG
C>    @param   LFDI    Derivative of Fock matrix elements in IFG
C>    @param   ILAY    layer for ifg 
C>    @param   JFG     Fragment indice in current for dimer
C>    @param   L1J     Number of atomic orbital in JFG
C>    @param   naj     number of alpha electron in jfg
C>    @param   nbj     number of beta  electron in jfg
C>    @param  NATJ     number of atom in JFG
C>    @param   DJ      Density for JFG
C>    @param   LFDJ    Derivative of Fock matrix elements in JFG
C>    @param   JLAY    layer for ifg 
C>    @param    iaglob global label for atom
C>    @param   NQMTFG  number of orbital for fragments
C>    @param LAYFRG    Layer information for respective fragments
C>    @param SCFFRG    SCFTYP for fragment (for UHF or ROHF)
C>    --- OUTPUT ---
C>    @param    EG     Derivative of energy 
C>    @param    EH     Second Derivative of energy 
C>    @param   FCM     Foce constant matrix
      subroutine ESDIMhss2a(IFG,L1I,nai,nbi,nati,DI,LFDI,ILAY,
     *                      JFG,L1J,naj,nbj,natj,DJ,LFDJ,JLAY,
     *                IAGLOB,EG, EH, NQMTFG,
     *                LAYFRG,FCM,SCFFRG)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (HALF=0.5D+00,thrush=1.0D+04)
      PARAMETER (MXGSH=30,MXG2=MXGSH*MXGSH,MAXL=5)
      PARAMETER (MXGTOT=5000, MXSH=1000, MXATM=5000)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,UROHF
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
c     COMMON /INTFIL/ NINTMX,NHEX,NTUPL,PACK2E,INTTYP,IGRDTYP
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
c     COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
c    *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
c    *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
c    *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
c    *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
c    *                MODLMO,NOPDEN,MOFOCK,modfd,modfmm,ncentm
      COMMON /FMOPNT/ LICHFG,LMULFG,LIDMREC,LFRGNAM,LLAYFRG,LINDAT,
     *                LNCBS,LFMOZAN,LFMOC,LFMOMAS,LIZBAS,LIAGLOB,LIBDGH,
     *                LIABDFG,LJABDFG,LNCAO,LIDXCAO,LIAPRJO,LJAPRJO,
     *                LCOREAO,LOCCCOR,LSHIFTB,LIODFMO,LFMODA,LFMODB,
     *                LFMOESPA,LFMOESPB,LLOCFMO,LSCFFRG,LFMOSCF,LRIJ,
     *                LPOPMUL,LPOPMAT,LIALOC,LINDBD,LIATFRG,LINDFRG,
     *                LINDGFRG,LNATFRG,LNAT0FRG,LIANFRG,LZANFRG,LCFRG,
     *                LLIBISH,LLIBNSH,LLIBNG,LINDATG,LFMOBUF(3),LFMODE,
     *                LNUMFRG,LLOCTAT,LIAOGLOB,LLOADM,LFMOGE,LDGRID,
     *                LIODCFMO,LJOB2GRP,LFMOPG,LEMOCDR,LUNTXYZ,LUNTROT,
     *                LSTONEP,LMAPSU,LFRGMUL,LCLMO,LIALMO,LINDLMO,
     *                LATCLMO,LLMOBDF,LFGFLMO,LNFGLMO,LLFGLMO,LPFGLMO,
     *                LPOPDMAT,LIDMPNT,LIDDPNT,LIVMPNT,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /RESTAR/ TIMLIM,IREST,NREC,INTLOC,IST,JST,KST,LST
C
      COMMON /SCYVEC/ IDFYVEC,LIPTYVEC,LIPTYA
      COMMON /SCZLAG/ LZVLAG,LZVWRK,LYALAG,LYAWRK
      DIMENSION KARTEN(0:MAXL-1)
      DATA KARTEN/1,4,6,10,15/ 
      DATA  UHF/8HUHF     /
      DATA ROHF/8HROHF    /
C
      DIMENSION DI(*),DJ(*),FCM(natfmo*3,*)
      DIMENSION IAGLOB(*),EG(*),EH(*),NQMTFG(*) 
      DIMENSION LAYFRG(*),SCFFRG(*)
C
      IF(NBI.eq.0) write(iw,*) "LAYFRG=",LAYFRG(1),NBI,NBJ,thrush
c     IF(MASWRK) write(*,*) "Entering 2 electron integrals in ES-DIM"
C   For I fragment
      L2I   = (L1I + L1I * L1I) / 2
      L3I   =  L1I * L1I
      NQI   = IAND(NQMTFG(IFG),65535) 
      IF(NQI.EQ.0) NQI=L1I
      NOCCI = NAI
      NOCCIB= NBI
C
C   HOP treatment
      leneig  = L2I + L3I
      if(scffrg(ifg).eq.uhf) leneig = L2I + L3I * 2
      ICOUNT  = 0
      DO IORB = 1,NQI
        IF(DI(leneig+IORB) .gt. thrush) ICOUNT = ICOUNT + 1
      END DO
      NVIRI = NQI - NOCCI  - ICOUNT
      NVIRIB= NQI - NOCCIB - ICOUNT
C
c     write(6,'("L1I =",4I4)') IFG,L1I,NQI,NVIRI
C   For J fragment
      L2J   = (L1J + L1J * L1J) / 2
      L3J   =  L1J * L1J
      NQJ   = IAND(NQMTFG(JFG),65535) 
      IF(NQJ.EQ.0) NQJ=L1J
      NOCCJ = NAJ
      NOCCJB= NBJ
C
C   HOP treatment
      leneig  = L2J + L3J
      if(scffrg(jfg).eq.uhf) leneig = L2J + L3J * 2
      ICOUNT  = 0
      DO IORB = 1,NQJ
        IF(DJ(leneig+IORB) .gt. thrush) ICOUNT = ICOUNT + 1
      END DO
      NVIRJ = NQJ - NOCCJ - ICOUNT
      NVIRJB= NQJ - NOCCJB- ICOUNT
C
c     write(6,'("L1J =",4I4)') JFG,L1J,NQJ,NVIRJ
C
      CALL BASCHK(LMAX)
      IF(LMAX.GE.5) THEN
         IF(MASWRK) WRITE(IW,*) 'FMO HAS NOT BEEN REVIEWED FOR H,I'
         CALL ABRT
      END IF
      NANGM= KARTEN(MAX(LMAX,1))
      MAXG = NANGM**4
C   
c     write(*,*) "TESTTEST =",NOCCI,NVIRI,NOCCJ,NVIRJ
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
C
      NSH2    = (NSHELL + NSHELL * NSHELL)/ 2
      LDSI    = LOADFM  + 1
      LDSJ    = LDSI    + l2I * nati  * 3 
      LWRK2   = LDSJ    + l2J * natj  * 3 * 2   ! for pure 2-electron terms
      LXCHNG  = LWRK2   + max(L3I,L3J) * 4 + max(l2I,l2J)*2  + num*8
      LGHOND  = LXCHNG  + NSH2
      LDDIJ   = LGHOND  + MAXG
      LAST    = LDDIJ   + 49 * MXG2  
      LWRK3   = LAST
      UROHF   =          SCFFRG(IFG).EQ.UHF .OR.SCFFRG(JFG).EQ.UHF
      UROHF   = UROHF.OR.SCFFRG(IFG).EQ.ROHF.OR.SCFFRG(JFG).EQ.ROHF
      IF(UROHF) THEN
        LAST  = LWRK3   + max(L3I,L3J) * 2
      END IF
C
      NEEDK   =  LAST   - LOADFM -1
      if(NEEDK.gt.NGOTMX) then
          write(iw,*) "Can not allocate  memory in fmohss"
          write(iw,*) "NEED = ",NEEDK,"MAX =",NGOTMX
          call abrt
          if(lfmobuf(3).ne.0) call abrt
      end if
      CALL GETFM(NEEDK)
C
      IST=1
      JST=1
      KST=1
      LST=1
      CALL JANDK
C
      CALL DAREAD(IDAF,IODA,X(LXCHNG),NSH2,54,0)
C
c     write(6,*) "ESD 2eHSS"
C
      call ESD_2eHSS(IFG,L1I,L2I,DI,X(LFDI),
     *               JFG,L1J,L2J,DJ,X(LFDJ),
     *               IAGLOB,EG, EH,X(LWRK2),X(LXCHNG)) 
C
C
c     write(6,*) "ESD 2eHSS END?"
C   DBG
c     NEGH = 3*NATFMO+9*(NATFMO*(NATFMO+1))/2
c     IF(GOPARR) CALL DDI_GSUMF(1625,EG,NEGH)
c     IF(MASWRK) THEN
c        WRITE(*,*) "checkcheckcheck01"
c        CALL HSSPRT(NATFMO,EG,EH)
c     END IF
c     IF(GOPARR) CALL DSCAL(negh,1.0D+00/NPROC,EG,1)
c     RESTORE THE PRISTINE MONOMER(DIMER) CONFIGURATION
      IF (GOPARR) THEN
          CALL DDI_GSUMF(1605,X(LFDI),3*NAT*(L2I+L2J))
      END IF
C
      CALL DSCAL(3*NAT*L2I,half,X(LFDI),1)
      CALL DSCAL(3*NAT*L2J,half,X(LFDJ),1)
      do i = 1,nat*3
         II=0
         DO JJ=1,L1I
           II = II+JJ
           X(LFDI+II-1+l2I*(i-1)) 
     *   = X(LFDI+II-1+l2I*(i-1)) + X(LFDI+II-1+l2I*(i-1)) 
         ENDDO
         II=0
         DO JJ=1,L1J
           II = II+JJ
           X(LFDJ+II-1+L2J*(i-1)) 
     *   = X(LFDJ+II-1+L2J*(i-1)) + X(LFDJ+II-1+L2J*(i-1)) 
         ENDDO
c        val = TRACEP(DI,x(LFDI+l2I*(i-1)),L1I) 
c        val = val + TRACEP(DJ,x(LFDJ+l2J*(i-1)),L1J) 
c        write(*,*) i,val
      end do
C
C     summing up contribution (\Delta D * S * D * (ii | uv)
c     write(6,*) "ESD 2eHSSR"
C
      CALL ESD_2ehssR(IFG,L1I,NQI,NOCCI,NVIRI,DI,X(LFDI),X(LDSI),nati,
     *                JFG,L1J,NQJ,NOCCJ,NVIRJ,DJ,X(LFDJ),X(LDSJ),natj,
     *                IAGLOB,FCM,X(LXCHNG),X(LGHOND),X(LWRK2),L2I,L2J,
     *                X(LIPTYA),X(LYALAG),NOCCIB,NVIRIB,NOCCJB,NVIRJB,
     *                X(LSCFFRG),X(LWRK3),ILAY,JLAY)
C
CC
      CALL RETFM(NEEDK)
C
      RETURN
      END
C
