C 29 Sep 14 - YN  - Implement Density-Functional Tight-Binding Method
C
C*MODULE DFTBHS    *DECK DFTB_HESSIAN
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate Hessian of DFTB.
C>             This is totally a preliminary version.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>    @todo - Arrange code
C>          - Performance improvement
C>          - Further check
C>
C
      SUBROUTINE DFTB_HESSIAN
C
C     CONVERT DEBYE**2/AMU-ANGSTROM**2 UNIT TO KM/MOLE WITH 42.255
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=5000, MXSPE=10, MXTAB=1500, MXINT=150)
      PARAMETER (ONE=1.0D+00)
      INTEGER, PARAMETER :: DDI_WORLD=0
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      LOGICAL :: ISGDDI,PAROUT,INITGDDI,WASGDDI
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      COMMON /DFTBSK/ SKHTAB(10,MXTAB,MXSPE,MXSPE),
     &                SKSTAB(10,MXTAB,MXSPE,MXSPE),SKSELF(3,MXSPE),
     &                SKGRID(MXSPE,MXSPE),SKDIM(MXSPE,MXSPE),
     *                SKSPIN(MXSPE),REPCOEFF(6,MXINT,MXSPE,MXSPE),
     *                REPINTV(2,MXINT,MXSPE,MXSPE),
     &                REPSHORT(3,MXSPE,MXSPE),REPCUT(MXSPE,MXSPE),
     &                QREFL(3,MXSPE),HUBBL(3,MXSPE),QREF(MXSPE),
     &                HUBB(MXSPE),SKCUT2,ZREF(MXATM),SPNCST(6,MXSPE),
     *                NUMREP(MXSPE,MXSPE)
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      COMMON /OPTSCF/ DIRSCF,FDIFF
      LOGICAL DIRSCF,FDIFF
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
C
      DATA CHECK/8HCHECK   /, DEBUG/8HDEBUG   /, DBUGME/8HRHFCL   /
      DATA ROHFC/8HROHF    /
      DATA UHFC/8HUHF     /
C
      CHARACTER(3) :: CHARA
      LOGICAL :: DC,DISK,FON(3),DSKSAV,REDUCE,ROHF,UHF,DIRECT,ISGDDI0,
     *  SOME
      INTEGER :: IORA(3*NAT*5),INDSH(NAT),INDSAO(NUM+1),NDOCC(2),
     *  NPART(2),NVIRT(2)
C     DOUBLE PRECISION :: HESTMP(3*NAT*3*NAT)
C
      IF(MASWRK) THEN
        SOME   = NPRINT.NE.-5 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME
      END IF
C
      FON(1) = .FALSE.
      FON(2) = .FALSE.
      FON(3) = .FALSE.
      ROHF   = .FALSE.
      UHF    = .FALSE.
      DIRECT = DIRSCF
      ISGDDI0= ISGDDI
      IF (EXETYP.EQ.CHECK) ISGDDI0 = .FALSE.
C
      IF (SCFTYP.EQ.UHFC) THEN
        UHF = .TRUE.
        IF (.NOT.SCC) THEN
          IF (MASWRK)
     *      WRITE (IW,*) "UNRESTRICTED NCC-DFTB IS NOT SUPPORTED"
          CALL ABRT
        END IF
      END IF
      IF (GOPARR) THEN
        IF (MASWRK) THEN
          WRITE (IW,*) "THIS PARALLEL RUN IS NOT ALLOWED NOW"
        END IF
        CALL ABRT
      END IF
C
      NSPIN = 1
      IF (UHF) NSPIN = 2
      NSHELL = 0
      DO I = 1, NAT
        NSHELL = NSHELL + MAXANG(ISPE(I))
      END DO
      IF (UHF.OR.SRSCC) THEN
        INDSH(1) = 0
        DO I = 1, NAT-1
          INDSH(I+1) = INDSH(I) + MAXANG(ISPE(I))
        END DO
        ISH = 0
        INDSAO(1) = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            IF (J.EQ.1) INDSAO(ISH+1) = INDSAO(ISH) + 1
            IF (J.EQ.2) INDSAO(ISH+1) = INDSAO(ISH) + 3
            IF (J.EQ.3) INDSAO(ISH+1) = INDSAO(ISH) + 5
          END DO
        END DO
      END IF
C
      IF (MASWRK.AND.SOME) THEN
        WRITE (IW,*)
        WRITE (IW,'(5X,"--------------------------",5X)')
        WRITE (IW,'(5X,"SECOND DERIVATIVE FOR DFTB",5X)')
        WRITE (IW,'(5X,"--------------------------",5X)')
        WRITE (IW,*)
C       WRITE (IW,'(5X,"AVAILABLE FUNCTIONS")')
C       WRITE (IW,'(5X," |- R-DFTB1, R-DFTB2, R-DFTB3")')
C       WRITE (IW,'(5X," |- RO-DFTB1, RO-DFTB2, RO-DFTB3")')
C       WRITE (IW,'(5X," |- U-DFTB2, U-DFTB3")')
C       WRITE (IW,'(5X," |- H-X DAMPING FOR DFTB2 AND DFTB3")')
C       WRITE (IW,'(5X," |- FRACTIONAL OCCUPATION FOR DFTB1, DFTB2, ",
C    *                 "AND DFTB3")')
C       WRITE (IW,'(5X," |- UFF-TYPE (AND SK-TYPE) DISPERSION")')
C       WRITE (IW,'(5X," |- ANALYTIC DIFFERENTIATION UP TO D SHELLS")')
C       WRITE (IW,*)
        WRITE (IW,'(5X," NOTE: PLEASE CHECK WHETHER ATOMIC WEIGHTS ARE",
     *                 " CORRECT.")')
        WRITE (IW,'(5X,"       DFTB MAY NOT CONSISTENT SOMETIMES.")')
        IF (.NOT.SCC) THEN
        WRITE (IW,'(5X," NOTE: DIPOLE DERIVATIVE OF NCC-DFTB IS NOT
     * RELIABLE.")')
        WRITE (IW,'(5X,"       IR INTENSITY MAY BE MEANINGLESS.")')
        END IF
      END IF
      CALL CPU_TIME(T0)
C
      L0 = NQMT
      L1 = NUM
      L2 = NUM*(NUM+1)/2
      L3 = NUM*NUM
C
C     CHECK THE NUMBERS OF DOUBLY AND PARTLY (PARTIALLY?) OCCUPIED AND
C     UNOCCUPIED ORBITALS
C
      CALL GOTFM(NGOTMX)
      CALL VALFM(LOADFM)
      LOCC = LOADFM + 1
      LEIG = LOCC   + L1*NSPIN
      LAST = LEIG   + L1*NSPIN
      IF (SCFTYP.EQ.ROHFC) THEN
        LWRK = LAST
        LAST = LWRK + L1
      END IF
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
      IF (EXETYP.NE.CHECK) THEN
        CALL DAREAD(IDAF,IODA,X(LOCC),L1,562,0)
        CALL DAREAD(IDAF,IODA,X(LEIG),L1,17,0)
        IF (UHF) THEN
          CALL DAREAD(IDAF,IODA,X(LOCC+L1),L1,563,0)
          CALL DAREAD(IDAF,IODA,X(LEIG+L1),L1,21,0)
        END IF
        CALL DFTB_HESS_CHKOCC(X(LOCC),X(LEIG),NDOCC,NPART,
     *    NVIRT,NSPIN,L1,IW,FON,ROHF,MASWRK,SOME,SCFTYP)
        IF (FON(1).OR.FON(2)) FON(3) = .TRUE.
C
        IF (MASWRK) THEN
          WRITE (IW,*)
          DO ISPIN = 1, NSPIN
            IF (NSPIN.EQ.2) THEN
              IF (ISPIN.EQ.1) WRITE (IW,'(" *** ALPHA ***")')
              IF (ISPIN.EQ.2) WRITE (IW,'(/" *** BETA  ***")')
            END IF
            WRITE (IW,'(" NUMBER OF        OCCUPIED ORBITALS = ", I5)')
     *        NDOCC(ISPIN)
            IF (FON(ISPIN))
     *       WRITE (IW,'(" NUMBER OF PARTLY OCCUPIED ORBITALS = ", I5)')
     *          NPART(ISPIN)
            WRITE (IW,'(" NUMBER OF        VIRTUAL  ORBITALS = ", I5)')
     *        NVIRT(ISPIN)
          END DO
          WRITE (IW,'(" ------------------------------------------")')
         WRITE (IW,'(" NUMBER OF TOTAL BASIS FUNCTIONS    = ", I5)') NUM
          IF (FON(3).AND.ROHF) THEN
            WRITE
     *      (IW,'(" ... FRACTIONAL OCCUPATION NUMBERS (FON) ARE USED")')
          WRITE (IW,'(" BUT ZERO ELECTRONIC TEMPERATURE. ASSUME ROHF")')
          END IF
          WRITE (IW,*)
        END IF
      ELSE
        !! THESE VARIABLES ARE ONLY GUESS, BECAUSE WE DON'T KNOW THESE
        !! VALUES UNLESS SCF IS DONE
        NDOCC(1) = NA
        NPART(1) = 0
        NVIRT(1) = NUM - NA
        IF (UHF) THEN
          NDOCC(2) = NB
          NPART(2) = 0
          NVIRT(2) = NUM - NB
        END IF
      END IF
      CALL RETFM(NEED)
C
C     CHOOSE HOW TO STORE AO AND MO DERIVATIVES.
C
C     FULLY INCORE
C       STORE EVERYTHING IN MEMORY, INCLUDING AO/MO DERIVATIVES
C     DISK-BASED ALGORITHM
C       AO/MO DERIVATIVES ARE STORED ON DISK
C     DDI
C       AO/MO DERIVATIVES ARE STORED ON SHARED MEMORY
C
      NDIM = NAT
      IF (SRSCC) NDIM = NSHELL
C
      MEMNCC = NAT*NAT*9 + NAT*9 + L1*2 + L2*4 + L3*4 +
     *  NAT*(NAT+1)/2 + NDIM*(NDIM+1)/2*2
      MEMNCC = MEMNCC + NAT !! LMULA ... is it needed for NCC?
C
      IF (DIRECT.OR.ISGDDI0) THEN
        MEMMAT = 0
      ELSE
        MEMMAT = L2*NAT*3*2 !! (H-V), S IN MO
      END IF
C
      IF (SCC) THEN
        MEMSCC = NDIM + NDIM*(NDIM+1)/2*2
        IF (NSPIN.EQ.2) MEMSCC = MEMSCC + L1*2 + L2*2 + L3*3
        IF (UHF) MEMSCC = MEMSCC + 5*NSHELL
        IF (SRSCC.AND..NOT.UHF) MEMSCC = MEMSCC + NSHELL
        IF (.NOT.DIRECT.AND..NOT.ISGDDI0) THEN
          MEMMAT = MEMMAT + L2*NAT*3 !! S IN AO
          IF (UHF) MEMMAT = MEMMAT + L2*NAT*3*2 !! BETA (H-V), S IN MO
        END IF
        !! ESTIMATED MEMORY USED FOR BROYDEN MIXING
        LL = NAT*100 !! MXITER = 50
        LMX1 = 100
        LMX2 = (LMX1*LMX1+LMX1)/2
        LMX3 = LMX1*LMX1
        MEMBR = 7*NAT+2*LL+2*LMX1+2*LMX2+2*LMX3
      ELSE
        MEMSCC = 0
        MEMBR  = 0
      END IF
C
      !! MEMORY FOR CP-DFTB
      IF (SRSCC.OR.UHF) THEN
        NDIMSH = NSHELL
      ELSE
        NDIMSH = NAT
      END IF
      MEMCP = (L1+L2*6+NDIM*2)*NSPIN + L2*3 + L3*3 + L1*L1*NDIM*NSPIN
     *  + L1*L1*NSPIN + (NDOCC(1)+NPART(1))*L1*NSPIN
      IF (SCC) MEMCP = MEMCP + NDIMSH*(2+NSPIN) + L2*2
      IF (FON(3)) MEMCP = MEMCP + L1*2
      IF (UHF) MEMCP = MEMCP + NDIM
C
      IF (DFTB3) THEN
        MEMDFTB3 = NDIM*NDIM*2
      ELSE
        MEMDFTB3 = 0
      END IF
C
      MEMCORE = MEMNCC + MEMBR + MEMCP + MEMSCC + MEMDFTB3 + MEMMAT
      MEMDISK = MEMNCC + MEMBR + MEMCP + MEMSCC + MEMDFTB3
      MEMCP_REDUCE = MEMCP - L1*L1*(NDIM-1)*NSPIN
C
      IF (MASWRK) THEN
        WRITE(IW,'(" ESTIMATED MEMORY REQUIREMENT (UNIT IN WORD)")')
        WRITE(IW,'("   FOR DFTB1                  = ",I12)') MEMNCC
        IF (SCC) THEN
        WRITE(IW,'("   FOR DFTB2                  = ",I12)') MEMSCC
        IF (DFTB3)
     *  WRITE(IW,'("   FOR DFTB3                  = ",I12)') MEMDFTB3
        END IF
        IF (.NOT.DIRECT.AND..NOT.ISGDDI0)
     *    WRITE(IW,'("   FOR AO/MO DERIVATIVES      = ",I12)') MEMMAT
        WRITE(IW,'("   FOR COUPLED PERTURBED DFTB = ",I12)') MEMCP
        WRITE(IW,'("   FOR BROYDEN MIXING         = ",I12)') MEMBR
        WRITE(IW,'(" -------------------------------------------")')
        WRITE(IW,'("   FOR FULLY INCORE ALGORITHM = ",I12)') MEMCORE
        IF (.NOT.DIRECT.AND..NOT.ISGDDI0)
     *    WRITE(IW,'("   FOR DISK-BASED   ALGORITHM = ",I12)') MEMDISK
        WRITE(IW,'("   AVAILABLE CURRENT MEMORY   = ",I12,
     *             " WORDS")') NGOTMX
      END IF
C
      DISK = .FALSE.
      REDUCE = .FALSE.
C     IF (MEMCORE.GE.NGOTMX.AND.MEMDISK.LT.NGOTMX) DISK = .TRUE.
C
      IF (ISGDDI0) THEN
        DISK = .FALSE.
        DIRECT = .FALSE.
        IF (MASWRK) WRITE (IW,*)
        IF (MASWRK) WRITE (IW,'(" STORE AO/MO DERIVATIVES ON DDI
     * MEMORY POOL")')
        MEMMAT = L2*NAT*3*2
        IF (SCC) MEMMAT = MEMMAT + L2*NAT*3
        IF (UHF) MEMMAT = MEMMAT + L2*NAT*3*2
        IF (MASWRK) WRITE (IW,'(" MEMORY FOR DDI = ",I12," WORDS")')
     *    MEMMAT
C       MEMCORE = MEMCORE - MEMMAT
        IF (MEMCORE.GT.NGOTMX) THEN
          REDUCE = .TRUE.
          IF (MASWRK) THEN
        WRITE (IW,'("   CP-DFTB TRIES TO SAVE MEMORY OF",I10," WORDS")')
     *      L1*L1*(NDIM-1)*NSPIN
          WRITE(IW,'("   MEMORY FOR REDUCED CP-DFTB = ",I12)')
     *      MEMCP_REDUCE
          END IF
          IF (MEMCORE-MEMCP+MEMCP_REDUCE.LT.NGOTMX) THEN
            IF (MASWRK) WRITE(IW,*) "REDUCED MEMORY RUN"
          ELSE
            IF (MASWRK) WRITE(IW,*) "NOT ENOUGH MEMORY"
            CALL ABRT
          END IF
        END IF
      ELSE IF (DIRECT) THEN
        DISK = .FALSE.
        IF (MASWRK)  WRITE(IW,*)
        IF (MASWRK)  WRITE (IW,'(" SUPPRESS ALL I/O STORAGE, BECAUSE
     * $SCF DIRSCF=.TRUE. $END EXISTS.")')
        IF (MEMCORE.GT.NGOTMX) THEN
          REDUCE = .TRUE.
          IF (MASWRK) THEN
        WRITE (IW,'("   CP-DFTB TRIES TO SAVE MEMORY OF ",I9," WORDS")')
     *      L1*L1*(NDIM-1)*NSPIN
          WRITE(IW,'("   MEMORY FOR REDUCED CP-DFTB = ",I12)')
     *      MEMCP_REDUCE
          END IF
          IF (MEMCORE-MEMCP+MEMCP_REDUCE.LT.NGOTMX) THEN
            IF (MASWRK) WRITE(IW,*) "DIRECT ALGORITHM WITH REDUCED
     * MEMORY RUN"
          ELSE
            IF (MASWRK) WRITE(IW,*) "NOT ENOUGH MEMORY"
            CALL ABRT
          END IF
        END IF
      ELSE
        IF (MASWRK)  WRITE(IW,*)
        IF (MEMCORE.LT.NGOTMX) THEN
          DISK = .FALSE.
          REDUCE = .FALSE.
          IF (MASWRK) WRITE(IW,'(" FULLY INCORE ALGORITHM IS PROBABLY",
     *                           " THE BEST CHOICE")')
        ELSE IF (MEMDISK.LT.NGOTMX) THEN
          DISK = .TRUE.
          REDUCE = .FALSE.
          IF (MASWRK) WRITE(IW,'(" DISK-BASED ALGORITHM IS PROBABLY",
     *                           " THE BEST CHOICE")')
        ELSE
          DISK = .TRUE.
          REDUCE = .TRUE.
          IF (MASWRK) THEN
        WRITE (IW,'("   CP-DFTB TRIES TO SAVE MEMORY OF ",I9," WORDS")')
     *      L1*L1*(NDIM-1)*NSPIN
          WRITE(IW,'("   MEMORY FOR REDUCED CP-DFTB = ",I12)')
     *      MEMCP_REDUCE
          END IF
          IF (MEMDISK-MEMCP+MEMCP_REDUCE.LT.NGOTMX) THEN
            IF (MASWRK) WRITE(IW,*) "DISK-BASED ALGORITHM WITH REDUCED
     * MEMORY RUN"
          ELSE IF (MEMDISK.GT.NGOTMX) THEN
            IF (MASWRK) WRITE(IW,*) "NOT ENOUGH MEMORY"
            CALL ABRT
          END IF
        END IF
      END IF
C
      CALL VALFM(LOADFM)
      NDIM = NAT
      IF (SRSCC) NDIM = NSHELL
      LHESSIAN     = LOADFM   + 1
      LDIPDER      = LHESSIAN + NAT*NAT*9
      LOCC         = LDIPDER  + NAT*9
      LEIG         = LOCC     + L1*NSPIN
      LD           = LEIG     + L1*NSPIN
      LD2          = LD       + L2*NSPIN
      LS           = LD2      + L2*NSPIN
      LVEC         = LS       + L2
      LWRK         = LVEC     + L3*NSPIN
      LWRK1        = LWRK     + L3*NSPIN !! U MATRIX
      LWRK2        = LWRK1    + L3*NSPIN !! UINIT
      LWRK3        = LWRK2    + L3
      LDIST        = LWRK3    + L2
      LGRAD        = LDIST    + NAT*(NAT+1)/2
      LHESS        = LGRAD    + NDIM*(NDIM+1)/2
      LAST         = LHESS    + NDIM*(NDIM+1)/2
      IF (UHF) THEN
        LSHIFTS    = LAST
        LSHIFTSH   = LSHIFTS  + NSHELL
        LSHIFTSA   = LSHIFTSH + NSHELL
        LSHIFTSB   = LSHIFTSA + NSHELL
        LMULS      = LSHIFTSB + NSHELL
        LAST       = LMULS    + NSHELL
      END IF
      IF (DISK.OR.DIRECT) THEN
        LPS        = LAST
        LHDERIJ    = LAST
        LSDERIJ    = LAST
      ELSE IF (ISGDDI0) THEN
        LHDERIJ    = LAST
        LSDERIJ    = LHDERIJ  + L2*NSPIN
        LAST       = LSDERIJ  + L2*NSPIN
        IF (SCC) THEN
          LPS      = LAST
          LAST     = LPS      + L2
        ELSE
          LPS      = LAST
        END IF
      ELSE
        LHDERIJ    = LAST
        LSDERIJ    = LHDERIJ  + L2*NAT*3*NSPIN
        LAST       = LSDERIJ  + L2*NAT*3*NSPIN
        IF (SCC) THEN
          LPS      = LAST
          LAST     = LPS      + L2*NAT*3
        ELSE
          LPS      = LAST
        END IF
      END IF
      LMULA        = LAST
      LAST         = LMULA    + NAT
C
      IF (SCC) THEN
        LGAMMA     = LAST
        LGAMDER    = LGAMMA   + NDIM*(NDIM+1)/2
        LSHIFT     = LGAMDER  + NDIM*(NDIM+1)/2
        LAST       = LSHIFT   + NAT
        IF (SRSCC.AND..NOT.UHF) THEN
          LSHIFTSH = LAST
          LSHIFTSA = LSHIFTSH + NSHELL
          LSHIFTSB = LSHIFTSA + NSHELL
          LMULS    = LSHIFTSB + NSHELL
          LAST     = LMULS    + NSHELL
          LSHIFTS  = LAST
        END IF
        IF (DFTB3) THEN
          LGAMMA3  = LAST
          LGAMDER3 = LGAMMA3  + NDIM*NDIM
          LAST     = LGAMDER3 + NDIM*NDIM
        ELSE
          LGAMMA3  = LAST
          LGAMDER3 = LAST
        END IF
      ELSE
        LGAMMA     = LAST
        LGAMDER    = LAST
        LSHIFT     = LAST
        LGAMMA3    = LAST
        LGAMDER3   = LAST
      END IF
      NEED         = LAST - LOADFM - 1
C
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
      IF (MASWRK) THEN
        WRITE (IW,'(" ...... ALLOCATED MEMORY = ",I10," WORDS")') NEED
        WRITE (IW,*)
      END IF
C
      IF (EXETYP.EQ.CHECK) THEN
        IF (MASWRK) THEN
          WRITE (IW,'(" W/O DDI MEMORY POOL")')
          WRITE (IW,'(" SUGGESTED MWORDS FOR FULLY INCORE = ",I5)')
     *      INT(MEMCORE/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS WITH AO/MO STORE = ",I5)')
     *      INT(MEMDISK/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS WITH MIN. MEMORY = ",I5)')
     *      INT((MEMDISK-MEMCP+MEMCP_REDUCE)/DBLE(1.0D+06))+1
          WRITE (IW,'(" -----------------------------------------")')
          WRITE (IW,'(" W/  DDI MEMORY POOL")')
          WRITE (IW,'(" SUGGESTED MEMDDI                  = ",I5)')
     *      INT(MEMMAT/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS FOR FULLY INCORE = ",I5)')
     *      INT((MEMCORE-MEMMAT)/DBLE(1.0D+06))+1
          WRITE (IW,'(" SUGGESTED MWORDS WITH MIN. MEMORY = ",I5)')
     *      INT((MEMDISK-MEMCP+MEMCP_REDUCE)/DBLE(1.0D+06))+1
        END IF
        GO TO 10
      END IF
C
C     ----- RESTORE VECTORS AND ARRAYS OBTAINED IN SCF -----
C
      !! EIGENVECTORS
      CALL DAREAD(IDAF,IODA,X(LVEC),L3,15,0)
      !! DENSITY MATRIX
      CALL DAREAD(IDAF,IODA,X(LD),L2,16,0)
      IF (ROHF.OR.SCFTYP.EQ.ROHFC) THEN
        CALL DAREAD(IDAF,IODA,X(LWRK1),L2,20,0)
        CALL VADD(X(LD),1,X(LWRK1),1,X(LD),1,L2)
      END IF
      !! EIGENVALUES
      CALL DAREAD(IDAF,IODA,X(LEIG),L1,17,0)
      !! OCCUPATION NUMBER
      CALL DAREAD(IDAF,IODA,X(LOCC),L1,562,0)
      !! CALCULATE EIGENVALUE WEIGHTED DENSIT YMATRIX
      CALL VCLR(X(LD2),1,L2)
      CALL DFTB_DMTEIG(X(LD2),X(LVEC),X(LOCC),X(LEIG),NA,L1,L1)
      !! OVERLAP
      CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
      !! ATOMIC MULLIKEN POPULATION
      CALL DAREAD(IDAF,IODA,X(LMULA),NAT,556,0)
      !! SHIFT MATRIX
      IF (SCC) THEN
        CALL DAREAD(IDAF,IODA,X(LSHIFT),NAT,559,0)
        IF (SRSCC) CALL DAREAD(IDAF,IODA,X(LSHIFTSH),NSHELL,560,0)
      END IF
      IF (UHF.OR.SRSCC) THEN
        CALL DAREAD(IDAF,IODA,X(LMULS),NSHELL,557,0)
        ISH = 0
        DO I = 1, NAT
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            X(LMULS+ISH-1) = X(LMULS+ISH-1) - QREFL(J,ISPE(I))
          END DO
        END DO
      END IF
      IF (UHF) THEN
        CALL DAREAD(IDAF,IODA,X(LVEC+L3),L3,19,0)
        CALL DAREAD(IDAF,IODA,X(LD+L2),L2,20,0)
        CALL DAREAD(IDAF,IODA,X(LEIG+L1),L1,21,0)
        CALL DAREAD(IDAF,IODA,X(LOCC+L1),L1,563,0)
        CALL VCLR(X(LD2+L2),1,L2)
        CALL DFTB_DMTEIG(X(LD2+L2),X(LVEC+L3),X(LOCC+L1),X(LEIG+L1),
     *    NB,L1,L1)
        CALL DAREAD(IDAF,IODA,X(LSHIFTS),NSHELL,561,0)
      END IF
C
      DC = .FALSE.
      IF (IDFTBD.EQ.1.OR.IDFTBD.EQ.2) DC = .TRUE.
C
      CALL VCLR(X(LDIST),1,NAT*(NAT+1)/2)
      CALL VCLR(X(LGRAD),1,NAT*(NAT+1)/2)
      CALL VCLR(X(LHESS),1,NAT*(NAT+1)/2)
      CALL VCLR(X(LHESSIAN),1,3*NAT*3*NAT)
      CALL VCLR(X(LDIPDER),1,9*NAT)
C
C     ----- CALCULATE INTER-ATOMIC DISTANCES -----
C
      NSEQ = 0
      DO I = 1, NAT
        DO J = 1, I
          NSEQ = NSEQ + 1
          DIST = SQRT( (C(1,I)-C(1,J))**2
     &               + (C(2,I)-C(2,J))**2
     &               + (C(3,I)-C(3,J))**2 )
          X(LDIST+NSEQ-1) = DIST
        END DO
      END DO
CD    CALL CPU_TIME(T1)
C
C     ----- CALCULATE GAMMA AND ITS DERIVATIVE OF DFTB2 AND DFTB3 -----
C
      IF (SCC) THEN
        CALL DFTB_GAMMA(DAMPXHE,HUBBL,X(LGAMMA),X(LDIST),NAT,NSPE,
     *    ISPE,MAXANG,SPE,DAMPXH,SRSCC)
        !! CALCULATE GAMMA DERIVATIVES
        IF (SRSCC) THEN
          NN = 0
          DO I = 1, NSPE
            NN = NN + MAXANG(I)
          END DO
        ELSE
          NN = NSPE
        END IF
        CALL DFTB_GAMDER(NAT,NSPE,HUBBL,ISPE,X(LGAMDER),DAMPXH,
     *    DAMPXHE,SPE,X(LDIST),DFTB3,X(LGAMDER3),HUBDER,SRSCC,MAXANG,
     *    NSHELL,NN)
        IF (DFTB3) THEN
          !! DFTB_GAMDER GIVES GAMDER3 VALUES SCALED BY 1/3
          CALL DSCAL(NAT*NAT,3.0D+00,X(LGAMDER3),1)
          !! NOW, GAMMA3 VALUES ARE NOT SCALED>
          CALL DFTB_GAMMA3(NAT,HUBBL,X(LGAMMA3),X(LDIST))
        END IF
      END IF
C
C     ----- OPEN RANDOM ACCESS FILE (.F20) -----
C     FOR THE DISK-BASED ALGORITHM, H_{IJ}^a, S_{IJ}^a, V_{IJ}^a
C     (=\OMEGA*dS/da), and dS/da WILL BE STORED.  H_{IJ}^a, S_{IJ}^a,
C     V_{IJ}^a ARE DERIVATIVES OF NCC-HAMILTONIAN, OVERLAP, AND OVERLAP
C     WITH GAMMA MATRICES IN MO EXPRESSION.  The dS/da MATRIX IS JUST A
C     DERIVATIVE OF OVERLAP MATRIX IN AO EXPRESSION.  THE POSITIONS OF
C     FOUR MATRICES WILL BE FOLLOWING:
C
C               1 ~ 1*(NAT*3) :: H_{IJ}^a + V_{IJ}^a
C     1*(NAT*3)+1 ~ 2*(NAT*3) :: S_{IJ}^a
C     2*(NAT*3)+1 ~ 3*(NAT*3) :: dS/da   (NOT NEEDED FOR DFTB1)
C     3*(NAT*3)+1 ~ 4*(NAT*3) :: H_{IJ}^a + V_{IJ}^a (BETA)
C     4*(NAT*3)+1 ~ 5*(NAT*3) :: S_{IJ}^a (BETA)
C
C     IN DFTB_EXHSDER SUBROUTINE, dH/da AND dS/da MATRICES ARE PUT AS
C     H_{IJ}^a AND S_{IJ}^a, AND LATER THEY WILL BE OVERWRITTEN BY
C     H_{IJ}^a AND S_{IJ}^a IN DFTB_HSDERIJ SUBROUTINE.
C     NOTE THAT V_{IJ}^a IS ONLY FOR DFTB2 AND DFTB3.
C
C     FOR PARALLEL RUNS, REPLICATE .F20 FILE ON EACH PROCESSORS.  IS IT
C     POSSIBLE TO DISTRIBUTE AFTER THE CALCULATION OF HAMILTONIAN AND
C     OVERLAP DERIVATIVES?
C
10    IF (DISK) THEN
        IRAF = 20
        IF (SCC) THEN
          NN = 3*3*NAT
          IF (UHF) NN = NN + 2*3*NAT
        ELSE
          NN = 2*3*NAT
        END IF
        IF (GOPARR) THEN
          DSKSAV = DSKWRK
          DSKWRK = .TRUE.
        END IF
        CALL RAOPEN(IRAF,IORA,0,NN,L2,0)
      ELSE IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL DDI_CREATE(L2*NSPIN,3*NAT,ID_HDERMO)
        IF (ID_HDERMO.EQ.-1) CALL ABRT
        CALL DDI_CREATE(L2*NSPIN,3*NAT,ID_SDERMO)
        IF (ID_SDERMO.EQ.-1) CALL ABRT
        CALL DDI_CREATE(L2      ,3*NAT,ID_SDERAO)
        IF (ID_SDERAO.EQ.-1) CALL ABRT
        WRITE (IW,*)
      END IF
      IF (EXETYP.EQ.CHECK) GO TO 20
CD    CALL CPU_TIME(T2)
C
      DO I = 1, NAT
        X(LMULA+I-1) = X(LMULA+I-1) - ZREF(I)
      END DO
C
C     ----- CONVERT ATOM-RESOLVED SHIFT TO SHELL-RESOLVED SHIFT -----
C
C     IF (SRSCC.OR.UHF) THEN
      IF (.NOT.SRSCC.AND.UHF) THEN
        CALL DFTB_SHIFT_ATOSH(X(LSHIFT),X(LSHIFTSH),NAT,NSHELL,NSPE,
     *    ISPE,MAXANG)
      END IF
C
C     ----- MAKE SHIFT MATRICES INCLUDING SPIN CONTRIBUTION -----
C     SHIFTSA = (SHELL-RESOLVED SHIFT) + (SPIN SHIFT)
C     SHIFTSB = (SHELL-RESOLVED SHIFT) - (SPIN SHIFT)
C
      IF (UHF) THEN
        CALL DCOPY(NSHELL,X(LSHIFTSH),1,X(LSHIFTSA),1)
        CALL DCOPY(NSHELL,X(LSHIFTSH),1,X(LSHIFTSB),1)
        CALL DAXPY(NSHELL, ONE,X(LSHIFTS),1,X(LSHIFTSA),1)
        CALL DAXPY(NSHELL,-ONE,X(LSHIFTS),1,X(LSHIFTSB),1)
      ELSE IF (SRSCC) THEN
        CALL DCOPY(NSHELL,X(LSHIFTSH),1,X(LSHIFTSA),1)
        CALL VCLR(X(LSHIFTSB),1,NSHELL)
      END IF
C
C     ----- CALCULATE HAMILTONIAN AND OVELAP DERIVATIVES IN AO -----
C     ----- CALCULATE HAMILTONIAN AND OVELAP DERIVATIVES IN MO -----
C
      IF (DIRECT) THEN
        IF (MASWRK) WRITE (IW,'(" SKIP AO AND MO DERIVATIVES
     * PREPARATION"/)')
      ELSE
        IF (MASWRK) WRITE (IW,'(" PREPARE AO AND MO DERIVATIVES ...")')
CD      CALL CPU_TIME(T3)
CD      CALL SYSTEM_CLOCK(ICLOCK_COUNTS_3,ICLOCK_RATE)
        NN = NAT
        IF (SRSCC.OR.UHF) NN = NSHELL
        CALL DFTB_HSDERIJ(NAT,L0,L1,L2,IND,IRAF,IORA,NN,C,X(LHDERIJ),
     *    X(LSDERIJ),X(LPS),X(LSHIFT),X(LSHIFTSA),X(LSHIFTSB),X(LVEC),
     *    X(LWRK),X(LWRK1),X(LWRK2),X(LWRK3),SCC,DISK,UHF,SRSCC,NSPIN,
     *    INDSH,INDSAO,MAXANG,NSPE,ISPE,ID_HDERMO,ID_SDERMO,ID_SDERAO)
CD      CALL CPU_TIME(T4)
CD      CALL SYSTEM_CLOCK(ICLOCK_COUNTS_4,ICLOCK_RATE)
CD      IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * CPU TIME" )')
CD   *    T4-T3
CD      IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * WALL-CLOCK TIME"/)')
CD   *    (ICLOCK_COUNTS_4-ICLOCK_COUNTS_3)/DBLE(ICLOCK_RATE)
      END IF
C     IF (ISGDDI) THEN
C       CALL DDI_ACC(ID_HDERMO,1,L2*NSPIN,1,3*NAT,HDERMO)
C       CALL DDI_ACC(ID_HDERMO,1,L2*NSPIN,1,3*NAT,SDERMO)
C       CALL DDI_ACC(ID_HDERMO,1,L2      ,1,3*NAT,SDERAO)
C       IR0 = 0
C       DO NI = 1, NAT
C         DO KI = 1, 3
C           IR0 = IR0 + 1
C           write (iw,*) "array for ir0 = ", ir0
C           CALL DDI_GET(ID_HDERMO,1,L2*NSPIN,IR0,IR0,X(LHDERIJ))
C         END DO
C       END DO
C     END IF
C
C     ----- CALCULATE HAMILTONIAN AND OVELAP DERIVATIVES IN MO -----
C
C     IF (MASWRK) WRITE (IW,'(" PREPARE MO DERIVATIVES ..."/)')
C     CALL DFTB_HSDERIJ(NAT,L0,L1,L2,IND,IRAF,IORA,X(LSHIFT),X(LVEC),
C    *  X(LHDERIJ),X(LSDERIJ),X(LPS),X(LWRK),
C    *  X(LWRK1),X(LWRK2),SCC,DISK)
C
   20 CONTINUE
      NGAM = NAT
      IF (SRSCC) NGAM = NSHELL
      NDIM = NAT
      IF (SRSCC.OR.UHF) NDIM = NSHELL
C     CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
      CALL DFTB_CP(L0,L1,L2,IRAF,IORA,NDOCC,NVIRT,NPART,X(LWRK),
     *  X(LVEC),X(LPS),X(LEIG),X(LOCC),X(LSHIFT),
     *  X(LGAMMA),X(LGAMDER),X(LS),X(LMULA),X(LDIST),X(LWRK1),
     *  X(LHESSIAN),X(LD),X(LHDERIJ),X(LSDERIJ),X(LGAMMA3),
     *  X(LGAMDER3),X(LDIPDER),DISK,FON,REDUCE,ROHF,UHF,NGAM,
     *  X(LSHIFTSA),X(LSHIFTSB),INDSH,
     *  INDSAO,NSPIN,X(LMULS),NDIM,SPNCST,DIRECT,ID_HDERMO,
     *  ID_SDERMO,ID_SDERAO)
      IF (EXETYP.EQ.CHECK) GO TO 100
C
      IF (ISGDDI) THEN
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL DDI_DESTROY(ID_SDERAO)
        CALL DDI_DESTROY(ID_SDERMO)
        CALL DDI_DESTROY(ID_HDERMO)
      END IF
C     WRITE (*,*) "AFTER DFTB_CP"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)
C     END DO
C     WRITE (*,*) "DFTB_CP CONTRIBUTION"
C     DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C     END DO
CD    CALL CPU_TIME(T5)
CD    CALL SYSTEM_CLOCK(ICLOCK_COUNTS_5,ICLOCK_RATE)
CD    IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * CPU TIME" )') T5-T4
CD    IF (MASWRK) WRITE (IW,'(3X,"FINISHED IN ",F8.2," SECONDS IN
CD   * WALL-CLOCK TIME"/)')
CD   *  (ICLOCK_COUNTS_5-ICLOCK_COUNTS_4)/DBLE(ICLOCK_RATE)
C
      IF (MASWRK) THEN
C     CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
        CALL DFTB_D2HS(X(LWRK),X(LWRK1),X(LD),X(LD2),
     *    X(LSHIFT),X(LSHIFTSA),X(LSHIFTSB),
     *    C,X(LHESSIAN),NAT,L2,NSPIN,IND,NSHELL,NSPE,ISPE,MAXANG,
     *    INDSAO,SCC,SRSCC,UHF)
C       WRITE (*,*) "AFTER D2HS"
C       DO I = 1, 3*3*NAT*NAT
C         WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)
C       END DO
C       WRITE (*,*) "D2HS CONTRIBUTION"
C       DO I = 1, 3*3*NAT*NAT
C       WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C       END DO
CD      CALL CPU_TIME(T6)
C
C       CALL DCOPY(3*NAT*3*NAT,X(LHESSIAN),1,HESTMP,1)
        IF (SCC) THEN
          IF (SRSCC) THEN
C           NN = 0
C           DO I = 1, NSPE
C             NN = NN + MAXANG(I)
C           END DO
            CALL DFTB_GAM_DER2(NAT,NSPE,HUBBL,C,X(LDIST),X(LGRAD),
     *        X(LHESS),X(LWRK),X(LWRK1),X(LMULS),X(LHESSIAN),DFTB3,
     *        HUBDER,DAMPXHE,ISPE,MAXANG,NSHELL,NSHELL,SPE,SRSCC,
     *        DAMPXH)
          ELSE
            NN = NSPE
            CALL DFTB_GAM_DER2(NAT,NSPE,HUBBL,C,X(LDIST),X(LGRAD),
     *        X(LHESS),X(LWRK),X(LWRK1),X(LMULA),X(LHESSIAN),DFTB3,
     *        HUBDER,DAMPXHE,ISPE,MAXANG,NSHELL,NAT,SPE,SRSCC,
     *        DAMPXH)
          END IF
        END IF
C       WRITE (*,*) "GAM_DER2 CONTRIBUTION"
C       DO I = 1, 3*3*NAT*NAT
C         WRITE (*,'(i3,x,f20.10)') i,x(lhessian+i-1)-hestmp(i)
C       END DO
C
C       ----- ADD EREP CONTRIBUTION -----
C
        CALL DFTB_EREP_HESSIAN(X(LDIST),X(LGRAD),X(LHESS),X(LHESSIAN))
C       goto 100
C
C       ----- ADD DISPERSION CONTRIBUTION -----
C
        IF (DC) THEN
          CALL DFTB_DISP_HESS(NAT,NSPE,ISPE,DFTBDP,ZREF,QREF,C,X(LDIST),
     *    X(LGRAD),X(LHESS),X(LHESSIAN),IDFTBD)
        END IF
      END IF
C
CD    IF (MASWRK) THEN
CD    WRITE (*,'(A,F10.5)') "TIME FOR PREPARATION       ",T0-T1
CD    WRITE (*,'(A,F10.5)') "TIME FOR DFTB_EREP_HESSIAN ",T2-T1
CD    WRITE (*,'(A,F10.5)') "TIME FOR DFTB_GAM_DER2     ",T3-T2
CD    WRITE (*,'(A,F10.5)') "TIME FOR EXTHSDER_DFTB     ",T4-T3
CD    WRITE (*,'(A,F10.5)') "TIME FOR CP-DFTB           ",T5-T4
CD    WRITE (*,'(A,F10.5)') "TIME FOR DFTB_D2HS         ",T6-T5
CD    END IF
C     open (372,file="hessian")
C     do i = 1, 3*3*nat*nat
C       write (372,'(F20.10)') X(LHESSIAN+I-1)
C     end do
C     close (372)
C
  100 CONTINUE
      IF (EXETYP.EQ.CHECK) THEN
        CALL VCLR(X(LHESSIAN),1,3*NAT*3*NAT)
        CALL VCLR(X(LDIPDER),1,9*NAT)
      END IF
      CALL DAWRIT(IDAF,IODA,X(LHESSIAN),3*NAT*3*NAT,4,0)
      CALL DAWRIT(IDAF,IODA,X(LDIPDER),9*NAT,34,0)
C
C     ---- CLOSE RANDOM ACCESS FILE (.F20) -----
C
      IF (DISK) THEN
        CALL RACLOS(IRAF,'DELETE')
        IF (GOPARR) DSKWRK = DSKSAV
      END IF
C
      CALL RETFM(NEED)
C
      IF(MASWRK) THEN
        CHARA(1:3) = "   "
        IF (.NOT.SCC) CHARA(1:1) = "1"
        IF (SCC.AND..NOT.DFTB3) CHARA(1:1) = "2"
        IF (SCC.AND.DFTB3) CHARA(1:1) = "3"
        IF (DC) CHARA(2:3) = "-D"
        WRITE(IW,'(" ...... END OF DFTB",A3," SECOND DERIVATIVE ",
     * "......")') CHARA
      END IF
C
      CALL TIMIT(1)
C
      END SUBROUTINE DFTB_HESSIAN
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate Hessian contribution of \Delta q terms
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NJ Index of atom to be displaced
C>    @param KJ Index of axis to be displaced
C>    @param NAT Number of atoms
C>    @param C Coordinates
C>    @param QDER Delta Q
C>    @param GAMDER Derivative of DFTB2 gamma
C>    @param GAMDER3 Derivative of DFTB3 gamma
C>    @param CHAMUL Mulliken charges
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param DFTB3 Whether DFTB3 or not
C>    @parma SRSCC Whether Shell-resolved SCC or not
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian matrix
C>
C
      SUBROUTINE DFTB_QDER(NJ,KJ,NAT,C,QDER,GAMDER,GAMDER3,CHAMUL,
     * DISTMAT,HESSIAN,DFTB3,SRSCC,NDIMSH,NSPE,ISPE,MAXANG)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION :: QDER(NAT),GAMDER(*),CHAMUL(NDIMSH),DISTMAT(*),
     *  HESSIAN(3*NAT,3*NAT),C(3,*),GAMDER3(NDIMSH,NDIMSH)
      INTEGER :: NSPE,ISPE(NAT),MAXANG(NSPE)
      LOGICAL :: DFTB3,SRSCC
C
      DOUBLE PRECISION,PARAMETER :: ONE=1.0D+00,ONE_THIRD=ONE/3.0D+00
      DOUBLE PRECISION :: V(3)
C
      JR = 3*(NJ-1)+KJ
      IF (SRSCC) THEN
        ISH0 = 0
        DO NI = 1, NAT
          DO I = 1, MAXANG(ISPE(NI))
            ISH = ISH0 + I
            CHAMUL1 = CHAMUL(ISH)
            KSH0 = 0
            DO NK = 1, NAT
              IF (NI.EQ.NK) THEN
                KSH0 = KSH0 + MAXANG(ISPE(NK))
                CYCLE
              END IF
              CALL DFTB_CNVSQ(NI,NK,NSEQ)
              DIST = DISTMAT(NSEQ)
              DISTI = ONE/DIST
              DO K = 1, MAXANG(ISPE(NK))
                KSH = KSH0 + K
                CHAMUL2 = CHAMUL(KSH)
                CALL DFTB_CNVSQ(ISH,KSH,NSEQ)
                GAMMAV = GAMDER(NSEQ)
                IF (DFTB3) THEN
                  GAMMAV3A = GAMDER3(ISH,KSH)
                  GAMMAV3B = GAMDER3(KSH,ISH)
                END IF
                DO KI = 1, 3
                  V(KI) = C(KI,NI) - C(KI,NK)
                  V(KI) = V(KI)*DISTI
                  IR = 3*(NI-1)+KI
                  GAMTMP = GAMMAV*V(KI)
                  HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *              + GAMTMP*(QDER(ISH)*CHAMUL2 + CHAMUL1*QDER(KSH))
C                 write (*,*) "val = ", GAMTMP*(QDER(ISH)*CHAMUL2+
C    *            CHAMUL1*QDER(KSH))
                  IF (DFTB3) THEN
                    GAMTMP3A = GAMMAV3A*V(KI)
                    GAMTMP3B = GAMMAV3B*V(KI)
                    HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                + ONE_THIRD
     *                  *(CHAMUL2*CHAMUL2*QDER(ISH)*GAMTMP3B
     *                  + CHAMUL1*CHAMUL1*QDER(KSH)*GAMTMP3A
     *                  + 2.0D+00*CHAMUL1*CHAMUL2*(QDER(KSH)*GAMTMP3B
     *                                           + QDER(ISH)*GAMTMP3A))
                  END IF
                END DO
              END DO
              KSH0 = KSH0 + MAXANG(ISPE(NK))
            END DO
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NI))
        END DO
      ELSE
        DO NI = 1, NAT !! A
          CHAMUL1 = CHAMUL(NI)
          DO NK = 1, NAT !! C
            IF (NI.EQ.NK) CYCLE
            CHAMUL2 = CHAMUL(NK)
            CALL DFTB_CNVSQ(NI,NK,NSEQ)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            GAMMAV = GAMDER(NSEQ)
            IF (DFTB3) THEN
              GAMMAV3A = GAMDER3(NI,NK)
              GAMMAV3B = GAMDER3(NK,NI)
            END IF
            DO KI = 1, 3
              V(KI) = C(KI,NI) - C(KI,NK)
              V(KI) = V(KI)*DISTI
              IR = 3*(NI-1)+KI
              GAMTMP = GAMMAV*V(KI)
              HESSIAN(IR,JR) = HESSIAN(IR,JR) + GAMTMP*(QDER(NI)*CHAMUL2
     +          + CHAMUL1*QDER(NK))
C             write (*,*) "val = ", GAMTMP*(QDER(NI)*CHAMUL2+
C    *        CHAMUL1*QDER(NK))
              IF (DFTB3) THEN
                GAMTMP3A = GAMMAV3A*V(KI)
                GAMTMP3B = GAMMAV3B*V(KI)
                HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *            + ONE_THIRD
     *              *(CHAMUL2*CHAMUL2*QDER(NI)*GAMTMP3B
     *              + CHAMUL1*CHAMUL1*QDER(NK)*GAMTMP3A
     *              + 2.0D+00*CHAMUL1*CHAMUL2*(QDER(NK)*GAMTMP3B
     *                                       + QDER(NI)*GAMTMP3A))
              END IF
            END DO
          END DO
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_QDER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DERSHIFT
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate non-response terms in d(Omega)/dR
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param KI Index of axis to be displaced
C>    @param C Coordinates
C>    @param GAMDER Derivative of DFTB2 gamma
C>    @param GAMDER3 Derivative of DFTB3 gamma
C>    @param CHAMUL Mulliken charges
C>    @param DFTB3 Whether DFTB3 or not
C>           --- OUTPUT ---
C>    @param DERSHIFT Shift contribution
C
      SUBROUTINE DFTB_CALC_DERSHIFT(NAT,NI,KI,C,DISTMAT,GAMDER,GAMDER3,
     *  CHAMUL,DERSHIFT,DFTB3)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,KI
      DOUBLE PRECISION, INTENT(IN) :: C(3,*),DISTMAT(*),GAMDER(*),
     *  GAMDER3(NAT,NAT),CHAMUL(NAT)
      DOUBLE PRECISION, INTENT(OUT) :: DERSHIFT(NAT)
      LOGICAL, INTENT(IN) :: DFTB3
C
      INTEGER :: NC,ND,NSEQ
      DOUBLE PRECISION :: V(3),CHAMULI,CHAMULJ,VAL,GAMMAV,GAMMAV3,VAL1,
     *  VAL2,DIST
      DOUBLE PRECISION, PARAMETER :: ONE_THIRD=1.0D+00/3.0D+00,
     *  ONE_SIX=1.0D+00/6.0D+00,TWO=2.0D+00
C
      CALL VCLR(DERSHIFT,1,NAT)
C
C     CALCULATE NON-RESPONSE TERMS IN d(OMEGA)/dR.
C     -NI- CORRESPONDS TO da IN EQUATIONS.
C     -NC- CORRESPONDS TO C IN EQUATIONS.
C     -ND- CORRESPONDS TO C IN EQUATIONS WHEN NI.EQ.NC
C
      DO NC = 1, NAT
        CHAMULI = CHAMUL(NC) !! \Delta q_A
        IF (NI.EQ.NC) THEN
          DO ND = 1, NAT
C           ND = C, NI = NC = a (A)
            IF (NC.EQ.ND) CYCLE
            CHAMULJ = CHAMUL(ND) !! \Delta q_C
            CALL DFTB_CNVSQ(NC,ND,NSEQ)
            V(1) = C(1,NC) - C(1,ND) !! A-C
            V(2) = C(2,NC) - C(2,ND)
            V(3) = C(3,NC) - C(3,ND)
            DIST = DISTMAT(NSEQ)
            GAMMAV = GAMDER(NSEQ)
            VAL = GAMMAV / DIST
            DERSHIFT(NC) = DERSHIFT(NC) + V(KI)*VAL*CHAMULJ
            IF (DFTB3) THEN
              GAMMAV3 = GAMDER3(NC,ND)
              VAL1 = GAMMAV3 / DIST
              GAMMAV3 = GAMDER3(ND,NC)
              VAL2 = GAMMAV3 / DIST
              DERSHIFT(NC) = DERSHIFT(NC)
     *          + ONE_THIRD*VAL1*CHAMULI*CHAMULJ*V(KI)*TWO
     *          + ONE_SIX*VAL2*CHAMULJ*CHAMULJ*V(KI)*TWO
            END IF
          END DO
        ELSE
C         d(gamma)/dR is not zero only when ni=a
C         NC = a (A), NI = C
          CHAMULJ = CHAMUL(NI) !! \Delta q_C
          CALL DFTB_CNVSQ(NC,NI,NSEQ)
          V(1) = C(1,NI) - C(1,NC) !! C-A
          V(2) = C(2,NI) - C(2,NC)
          V(3) = C(3,NI) - C(3,NC)
          DIST = DISTMAT(NSEQ)
          GAMMAV = GAMDER(NSEQ)
          VAL = GAMMAV / DIST
          DERSHIFT(NC) = DERSHIFT(NC) + V(KI)*VAL*CHAMULJ
          IF (DFTB3) THEN
            GAMMAV3 = GAMDER3(NC,NI)
C           GAMMAV3 = GAMDER3(NI,NC)
            VAL1 = GAMMAV3 / DIST
            GAMMAV3 = GAMDER3(NI,NC)
C           GAMMAV3 = GAMDER3(NC,NI)
            VAL2 = GAMMAV3 / DIST
            DERSHIFT(NC) = DERSHIFT(NC)
     *        + ONE_THIRD*VAL1*CHAMULI*CHAMULJ*V(KI)*TWO
     *        + ONE_SIX*VAL2*CHAMULJ*CHAMULJ*V(KI)*TWO
          END IF
        END IF
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_DERSHIFT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DERSHIFT_SHELL
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate non-response terms in d(Omega)/dR for SRSCC
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param KI Index of axis to be displaced
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param GAMDER Derivative of DFTB2 gamma
C>    @param GAMDER3 Derivative of DFTB3 gamma
C>    @param CHAMUL Mulliken charges
C>    @param DFTB3 Whether DFTB3 or not
C>    @param NSHELL Number of shells
C>    @param INDSH Index of shell for each atom
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param DERSHIFT Shift contribution
C>
C>    @todo merged into DFTB_CALC_DERSHIFT
C
      SUBROUTINE DFTB_CALC_DERSHIFT_SHELL(NAT,NI,KI,C,DISTMAT,GAMDER,
     *  GAMDER3,CHAMUL,DERSHIFT,DFTB3,NSHELL,INDSH,NSPE,ISPE,MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,KI,NSHELL,INDSH(NAT),NSPE,ISPE(NAT),
     *  MAXANG(NSPE)
      DOUBLE PRECISION, INTENT(IN) :: C(3,*),DISTMAT(*),GAMDER(*),
     *  GAMDER3(NSHELL,NSHELL),CHAMUL(NSHELL)
      DOUBLE PRECISION, INTENT(OUT) :: DERSHIFT(NSHELL)
      LOGICAL, INTENT(IN) :: DFTB3
C
      INTEGER :: ISH0,ISH,JSH0,JSH,KSH0,KSH,I,J,NC,ND,NSEQ
      DOUBLE PRECISION :: V(3),DIST,DISTI,GAMMAV,CHAMULI,CHAMULJ,VAL,
     *  VAL1,VAL2,GAMMAV3
      DOUBLE PRECISION, PARAMETER :: ONE_THIRD=1.0D+00/3.0D+00,
     *  ONE_SIX=1.0D+00/6.0D+00,ONE=1.0D+00,TWO=2.0D+00
C
      CALL VCLR(DERSHIFT,1,NSHELL)
C
C     CALCULATE SHELL-RESOLVED NON-RESPONSE TERMS IN d(OMEGA)/dR.
C
      ISH0 = INDSH(NI)
      DO I = 1, MAXANG(ISPE(NI)) !! SHELL OF NI
        ISH = ISH0 + I
        JSH0 = 0
        DO NC = 1, NAT
          CHAMULI = CHAMUL(ISH) !! \Delta q_A
          IF (NI.EQ.NC) THEN
            KSH0 = 0
            DO ND = 1, NAT
C             ND = C, NI = NC = a (A)
              IF (NC.EQ.ND) THEN
                KSH0 = KSH0 + MAXANG(ISPE(ND))
                CYCLE
              END IF
              V(1) = C(1,NC) - C(1,ND) !! A-C
              V(2) = C(2,NC) - C(2,ND)
              V(3) = C(3,NC) - C(3,ND)
              CALL DFTB_CNVSQ(NC,ND,NSEQ)
              DIST = DISTMAT(NSEQ)
              DISTI = ONE/DIST
              DO J = 1, MAXANG(ISPE(ND)) !! SHELL OF ND
                KSH = KSH0 + J
                CALL DFTB_CNVSQ(ISH,KSH,NSEQ)
                GAMMAV = GAMDER(NSEQ)
                CHAMULJ = CHAMUL(KSH) !! \Delta q_C
                VAL = GAMMAV*DISTI
                DERSHIFT(ISH) = DERSHIFT(ISH) + V(KI)*VAL*CHAMULJ
                IF (DFTB3) THEN
                  GAMMAV3 = GAMDER3(NC,ND)
                  VAL1 = GAMMAV3 / DIST
                  GAMMAV3 = GAMDER3(ND,NC)
                  VAL2 = GAMMAV3 / DIST
                  DERSHIFT(NC) = DERSHIFT(NC)
     *              + ONE_THIRD*VAL1*CHAMULI*CHAMULJ*V(KI)*TWO
     *              + ONE_SIX*VAL2*CHAMULJ*CHAMULJ*V(KI)*TWO
                END IF
              END DO
              KSH0 = KSH0 + MAXANG(ISPE(ND))
            END DO
          ELSE
            CHAMULJ = CHAMUL(ISH) !! \Delta q_A
            V(1) = C(1,NI) - C(1,NC) !! C-A
            V(2) = C(2,NI) - C(2,NC)
            V(3) = C(3,NI) - C(3,NC)
            CALL DFTB_CNVSQ(NI,NC,NSEQ)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DO J = 1, MAXANG(ISPE(NC)) !! SHELL OF NC
              JSH = JSH0 + J
              CHAMULI = CHAMUL(JSH) !! \Delta q_C
              CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
              GAMMAV = GAMDER(NSEQ)
              VAL = GAMMAV*DISTI
              DERSHIFT(JSH) = DERSHIFT(JSH) + V(KI)*VAL*CHAMULJ
              IF (DFTB3) THEN
                GAMMAV3 = GAMDER3(NC,NI)
                VAL1 = GAMMAV3 / DIST
                GAMMAV3 = GAMDER3(NI,NC)
                VAL2 = GAMMAV3 / DIST
                DERSHIFT(NC) = DERSHIFT(NC)
     *            + ONE_THIRD*VAL1*CHAMULI*CHAMULJ*V(KI)*TWO
     *            + ONE_SIX*VAL2*CHAMULJ*CHAMULJ*V(KI)*TWO
              END IF
            END DO
          END IF
          JSH0 = JSH0 + MAXANG(ISPE(NC))
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_DERSHIFT_SHELL
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CP_NR
C>
C>    @brief Hessian of DFTB
C>
C>    @details Caculate non-response terms in CP-DFTB equation
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param EIG Eigenvalues of each orbital
C>    @param OCC Occupation number of each orbital
C>    @param HDERIJ H_{ij}^a + V_{ij}^a
C>    @param SDERIJ S_{ij}^a
C>    @param SOMGDIJ \sum_{\mu \nu} c*c*S*(omega), where omega only
C>           contains non-response terms
C>           --- OUTPUT ---
C>    @param U U matrix (geometrical derivative of MO coefficients)
C>
C
      SUBROUTINE DFTB_CP_NR(L1,L2,EIG,OCC,U,HDERIJ,
     *  SDERIJ,SOMGDIJ)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2
      DOUBLE PRECISION, INTENT(IN) :: EIG(L1),OCC(L1),HDERIJ(L2),
     *  SDERIJ(L2),SOMGDIJ(L2)
      DOUBLE PRECISION, INTENT(OUT) :: U(L1,L1)
C
      INTEGER :: IO,JO,NSEQ
      DOUBLE PRECISION :: EI,EJ,EIJ,OCCI,OCCJ,VAL,VALI,VALJ
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00,
     *  HALF=0.5D+00
C
      NSEQ = 0
      DO IO = 1, L1
        EI = EIG(IO)
        OCCI = OCC(IO)
        DO JO = 1, IO !! L1
          NSEQ = NSEQ + 1
          EJ = EIG(JO)
          OCCJ = OCC(JO)
C         IF (OCCI.EQ.OCCJ) CYCLE !! FOR FON
          IF (IO.EQ.JO) THEN
            U(IO,JO) = -HALF*SDERIJ(NSEQ)
          ELSE
            VAL = HDERIJ(NSEQ)+SOMGDIJ(NSEQ)
            VALI = VAL - EJ*SDERIJ(NSEQ)
            VALJ = VAL - EI*SDERIJ(NSEQ)
            IF (ABS(EJ-EI).LE.1.0D-06) THEN
              IF (OCCI.EQ.OCCJ) THEN
                U(IO,JO) = -HALF*SDERIJ(NSEQ)
                U(JO,IO) = -HALF*SDERIJ(NSEQ)
              ELSE
                !! AVOID NEARLY DEGENERATED P.O-P.O COUPLING ELEMENTS
                EIJ = (OCCJ-OCCI)/((EJ-EI)*OCCJ)
                U(IO,JO) = -SDERIJ(NSEQ) + VALI*EIJ
                U(JO,IO) = ZERO
              END IF
            ELSE
              EIJ = ONE/(EJ-EI)
              U(IO,JO) = VALI*EIJ
              U(JO,IO) = -VALJ*EIJ
            END IF
          END IF
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CP_NR
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_DER_CLEAR
C>
C>    @brief Hessian of DFTB
C>
C>    @details VCLR only for values NI-th atom concerns
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of aotms
C>    @param NI Atom to differentiated
C>    @param L2 L1*(L1+1)/2
C>    @param IND Index of AO
C>           --- IN/OUTPUT ---
C>    @param OUTPUT Output (all zero matrix)
C>
C
      SUBROUTINE SHIFT_TRIANGLE_DER_CLEAR(NAT,NI,L2,IND,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NJ,M,L,MU,NU,NSEQ
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00
C
      IF (NI.EQ.1) GO TO 100
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO M = 1, IND(NI+1)-IND(NI)
        DO NJ = 1, NI-1
          DO L = 1, IND(NJ+1) - IND(NJ)
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = ZERO
          END DO
        END DO
        NSEQ = NSEQ + M
      END DO
C
100   IF (NI.EQ.NAT) RETURN

      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1)-IND(NI)
            MU = IND(NI)+M
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = ZERO
          END DO
C         MU = IND(NI+1)+1
          NSEQ = NSEQ + IND(NI) + NU - MU
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_DER_CLEAR
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_DER_SHELL
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a derivative matrix
C>             in AO basis.  Because derivative matrix is sparse
C>             (only columns of NI is non-trivial), this is faster
C>             than simple multiplication.  SHIFT should be
C>             shell-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND AO index of each atom
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param SHIFT Shift contribution (NSHELL size)
C>    @param INPUT Input matrix, should be AO derivative matrix
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C>
C
      SUBROUTINE SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,INDSAO,
     *  NSPE,ISPE,MAXANG,SHIFT,INPUT,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*),INDSH(*),INDSAO(*),NSPE,
     *  ISPE(NAT),MAXANG(NSPE)
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(*),INPUT(L2)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NSEQ,I,J,ISH,JSH,L,M,MU,NU,NJ
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      IF (NI.EQ.1) GO TO 200
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO I = 1, MAXANG(ISPE(NI))
        ISH = INDSH(NI)+I
        SHIFTI = SHIFT(ISH)
        DO M = 1, INDSAO(ISH+1)-INDSAO(ISH)
          MU = INDSAO(ISH)+M
          DO NJ = 1, NI-1
            DO J = 1, MAXANG(ISPE(NJ))
              JSH = INDSH(NJ)+J
              SHIFTJ = SHIFT(JSH)
              SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
              DO L = 1, INDSAO(JSH+1) - INDSAO(JSH)
                NU = INDSAO(JSH)+L
                NSEQ = NSEQ + 1
                OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
              END DO
            END DO
          END DO
          NSEQ = NSEQ + MU - NU
        END DO
      END DO
C
200   IF (NI.EQ.NAT) RETURN
C
      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        DO J = 1, MAXANG(ISPE(NJ))
          JSH = INDSH(NJ)+J
          SHIFTJ = SHIFT(JSH)
          DO L = 1, INDSAO(JSH+1)-INDSAO(JSH)
            NU = INDSAO(JSH)+L
            DO I = 1, MAXANG(ISPE(NI))
              ISH = INDSH(NI)+I
              SHIFTI = SHIFT(ISH)
              SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
              DO M = 1, INDSAO(ISH+1)-INDSAO(ISH)
                MU = INDSAO(ISH)+M
                NSEQ = NSEQ + 1
                OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
              END DO
            END DO
            NSEQ = NSEQ + IND(NI) + NU - MU
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_DER_SHELL
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_DER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a derivative matrix
C>             in AO basis.  Because derivative matrix is sparse
C>             (only columns of NI is non-trivial), this is faster
C>             than simple multiplication.  SHIFT should be
C>             atom-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Index of atom to be displaced
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND AO index of each atom
C>    @param SHIFT Shift contribution (NAT size)
C>    @param INPUT Input matrix, should be AO derivative matrix
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C
      SUBROUTINE SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,SHIFT,INPUT,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(*),INPUT(L2)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NSEQ,NJ,L,M,MU,NU
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      SHIFTI = SHIFT(NI)
C
      IF (NI.EQ.1) GO TO 200
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO M = 1, IND(NI+1)-IND(NI)
        DO NJ = 1, NI-1
          SHIFTJ = SHIFT(NJ)
          SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
          DO L = 1, IND(NJ+1) - IND(NJ)
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
          END DO
        END DO
        NSEQ = NSEQ + M
      END DO
C
200   IF (NI.EQ.NAT) RETURN

      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        SHIFTJ = SHIFT(NJ)
        SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1)-IND(NI)
            MU = IND(NI)+M
            NSEQ = NSEQ + 1
            OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
          END DO
          NSEQ = NSEQ + IND(NI) + NU - MU
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_DER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE_SHELL
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a matrix in AO basis.
C>             SHIFT should be shell-resolved.
C>
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SHIFT Shift contribution (NSHELL size)
C>    @param INPUT Input matrix, should be AO matrix
C>    @param NAT Number of atoms
C>    @param NSPE Number of species
C>    @param NSHELL Number of shells
C>    @param L2 Size of upper triangular AO matrix
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C
      SUBROUTINE SHIFT_TRIANGLE_SHELL(SHIFT,INPUT,OUTPUT,
     *  NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L2,NSHELL
      DOUBLE PRECISION, INTENT(IN) :: INPUT(L2),SHIFT(NSHELL)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(NAT),MAXANG(NSPE)
C
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
      INTEGER :: NSEQ,MU,NU,I,II,III,J,JJ,JJJ,M,N,ISH,JSH
C
      NSEQ = 0
      MU = 0
      ISH = 0
      DO I = 1, NAT
        DO II = 1, MAXANG(ISPE(I))
          ISH = ISH + 1
          SHIFTI = SHIFT(ISH)
          IF (II.EQ.1) III = 1
          IF (II.EQ.2) III = 3
          IF (II.EQ.3) III = 5
          DO M = 1, III
            MU = MU + 1
            JSH = 0
            NU = 0
            DO J = 1, I
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH + 1
                SHIFTJ = SHIFT(JSH)
                SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
                IF (JJ.EQ.1) JJJ = 1
                IF (JJ.EQ.2) JJJ = 3
                IF (JJ.EQ.3) JJJ = 5
                DO N = 1, JJJ
                  NU = NU + 1
                  IF (NU.GT.MU) EXIT
                  CALL DFTB_CNVSQ(MU,NU,NSEQ)
C                 write (*,*) mu, nu
C                 write (*,*) shifti,shiftj,shiftij
                  OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
C                 write (*,*) input(nseq),"->", output(nseq)
                END DO
              END DO
            END DO
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE_SHELL
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK SHIFT_TRIANGLE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Multiply shift contribution with a matrix in AO basis.
C>             SHIFT should be atom-resolved.
C>
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND Index of AOs
C>    @param SHIFT Shift contribution (NSHELL size)
C>    @param INPUT Input matrix, should be AO matrix
C>           --- OUTPUT ---
C>    @param OUTPUT Output
C
      SUBROUTINE SHIFT_TRIANGLE(NAT,L2,IND,SHIFT,INPUT,OUTPUT)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L2,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: SHIFT(*),INPUT(L2)
      DOUBLE PRECISION, INTENT(OUT) :: OUTPUT(L2)
C
      INTEGER :: NSEQ,MU,NU,L,M,NM,NN
      DOUBLE PRECISION :: SHIFTI,SHIFTJ,SHIFTIJ
      DOUBLE PRECISION, PARAMETER :: HALF=0.5D+00
C
      NSEQ = 0
      NU = 0
      DO NM = 1, NAT
        SHIFTI = SHIFT(NM)
        DO L = 1, IND(NM+1) - IND(NM)
          NU = NU + 1
          MU = 0
          DO NN = 1, NM
            SHIFTJ = SHIFT(NN)
            SHIFTIJ = HALF*(SHIFTI+SHIFTJ)
            DO M = 1, IND(NN+1) - IND(NN)
              MU = MU + 1
              IF (MU.GT.NU) EXIT
              NSEQ = NSEQ + 1
              OUTPUT(NSEQ) = INPUT(NSEQ)*SHIFTIJ
            END DO
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE SHIFT_TRIANGLE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_RESPONSE_REDUCE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare response terms in CP-DFTB iterations.  This will
C>             reduce computation.  This subroutine is used in reduced
C>             memory run and store only L1*L1*NSPIN values.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param L2 Size of upper triangular AO matrix
C>    @param VEC MO coefficients
C>    @param S Overlap matrix
C>    @param SSQ Working array for square overlap matrix
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>           --- OUTPUT ---
C>    @param RESP Response terms
C
      SUBROUTINE DFTB_PREP_RESPONSE_REDUCE(L1,L2,VEC,S,RESP,SSQ,NSPIN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2,NSPIN
      DOUBLE PRECISION, INTENT(IN) :: VEC(L1,L1,NSPIN),S(L2)
      DOUBLE PRECISION, INTENT(OUT) :: RESP(L1,L1,NSPIN),SSQ(L1,L1)
C
      INTEGER :: ISPIN,MO,MU
      DOUBLE PRECISION :: DDOT,XDOT
C
C     RESP(MU,MO) = \SUM_{\MU} S_{\MU \NU} C_{\NU MO}
C
      CALL CPYTSQ(S,SSQ,L1,1)
      DO ISPIN = 1, NSPIN
        DO MO = 1, L1
          DO MU = 1, L1
            RESP(MU,MO,ISPIN) = DDOT(L1,SSQ(1,MU),1,VEC(1,MO,ISPIN),1)
          END DO
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_RESPONSE_REDUCE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_RESPONSE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare response terms in CP-DFTB iterations.  This will
C>             reduce computation.  This subroutine requires much
C>             memory and store only L1*L1*NSPIN*(NAT or NSHELL) values.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functios
C>    @param L2 Size of upper triangular AO matrix
C>    @param IND Index of AO
C>    @param VEC MO coefficients
C>    @param S Overlap matrix
C>    @param SRSCC Shell-resolved SCC or not
C>    @param UHF U-DFTB or not
C>    @param INDSAO AO index of each shell
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NSHELL Number of shells
C>    @param SSQ Working array for square overlap matrix
C>    @param WRK Working array for MRARBR
C>           --- OUTPUT ---
C>    @param RESP Response terms
C
      SUBROUTINE DFTB_PREP_RESPONSE(NAT,L1,L2,IND,
     *  VEC,S,RESP,SRSCC,UHF,INDSAO,NSPIN,NDIMSH,NSHELL,SSQ,WRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,L2,IND(*),INDSAO(*),NSPIN,NDIMSH,
     *  NSHELL
      DOUBLE PRECISION, INTENT(IN) :: VEC(L1,L1,NSPIN),S(L2)
      DOUBLE PRECISION, INTENT(OUT) :: RESP(L1,L1,NDIMSH,NSPIN),
     *  SSQ(L1,L1),WRK(L1,L1)
      LOGICAL, INTENT(IN) :: SRSCC,UHF
C
      INTEGER :: ISPIN,NN,II,I,J
      DOUBLE PRECISION :: TMP
C
C     RESP(IO,JO,A)
C       = \sum_{\mu \in A} \sum_{\nu} c_{\mu i} c_{\nu j} S_{\mu \nu}
C
      CALL CPYTSQ(S,SSQ,L1,1)
      DO ISPIN = 1, NSPIN
        CALL MRARBR(SSQ,L1,L1,L1,VEC(1,1,ISPIN),L1,L1,WRK,L1)
        IF (SRSCC.OR.UHF) THEN
          DO NN = 1, NSHELL
            II = INDSAO(NN+1)-INDSAO(NN)
            CALL MRTRBR(VEC(INDSAO(NN)+1,1,ISPIN),L1,II,L1,
     *      WRK(INDSAO(NN)+1,1),L1,L1,RESP(1,1,NN,ISPIN),L1)
C
C           ----- SYMMETRIZE RESP MATRIX -----
C
            DO I = 1, L1
              DO J = I, L1
                TMP = RESP(J,I,NN,ISPIN) + RESP(I,J,NN,ISPIN)
                RESP(J,I,NN,ISPIN) = TMP
                RESP(I,J,NN,ISPIN) = TMP
              END DO
            END DO
          END DO
        ELSE
          DO NN = 1, NAT
            II = IND(NN+1)-IND(NN)
            CALL MRTRBR(VEC(IND(NN)+1,1,ISPIN),L1,II,L1,
     *        WRK(IND(NN)+1,1),L1,L1,RESP(1,1,NN,ISPIN),L1)
C
C           ----- SYMMETRIZE RESP MATRIX -----
C
            DO I = 1, L1
              DO J = I, L1
                TMP = RESP(J,I,NN,ISPIN) + RESP(I,J,NN,ISPIN)
                RESP(J,I,NN,ISPIN) = TMP
                RESP(I,J,NN,ISPIN) = TMP
              END DO
            END DO
          END DO
        END IF
      END DO
C
C       write (*,*) "response"
C       do i = 1, l1
C         do j = 1, l1
C           do nn = 1, nshell
C             write (*,'(3i3,3(x,f20.10))') i,j,nn,
C    *  resp(i,j,nn,1),resp(i,j,nn,2), resp(i,j,nn,1)-resp(i,j,nn,2)
C           end do
C         end do
C       end do
C     else
C       write (*,*) "response"
C       do i = 1, l1
C         do j = 1, l1
C           do nn = 1, nshell
C             write (*,'(3i3,1(x,f20.10))') i,j,nn,
C    *  resp(i,j,nn,1)
C           end do
C         end do
C       end do
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_RESPONSE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_INDEX
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare index used in DFTB_DEDB.  This will be helpful in
C>             reducing the call of DFTB_CNVSQ
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param OCC Occupation number of each orbital
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param L1 Number of basis functios
C>    @param NDIMSH L1*(NDOCC(1)+NPART(1))
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>           --- OUTPUT ---
C>    @param INDP Index of AOs for independent pairs
C
      SUBROUTINE DFTB_HESS_INDEX(OCC,INDP,NDOCC,NPART,L1,NDIM,NSPIN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,NDIM,NSPIN
      DOUBLE PRECISION, INTENT(IN) :: OCC(L1,NSPIN)
      INTEGER, INTENT(INOUT) :: INDP(NDIM,NSPIN)
      INTEGER, INTENT(IN) :: NDOCC(2),NPART(2)
C
      DOUBLE PRECISION :: OCCI
      INTEGER :: ISPIN,N2,IO,MO,NSEQ
C
C     PREPARE INDEXING ... I'M NOT SURE THIS IS MEANINGFUL.
C
      DO ISPIN = 1, NSPIN
        N2 = 1
        DO IO = 1, NDOCC(ISPIN)+NPART(ISPIN)
          OCCI = OCC(IO,ISPIN)
          IF (OCCI.LT.1.0D-10) CYCLE
          IF (IO.LE.NDOCC(ISPIN)) THEN
            DO MO = NDOCC(ISPIN)+1, L1
              CALL DFTB_CNVSQ(MO,IO,NSEQ)
              INDP(N2,ISPIN) = NSEQ
              N2 = N2 + 1
            END DO
          ELSE
            DO MO = 1, L1
              CALL DFTB_CNVSQ(MO,IO,NSEQ)
              INDP(N2,ISPIN) = NSEQ
              N2 = N2 + 1
            END DO
          END IF
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_INDEX
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CP
C>
C>    @brief Hessian of DFTB
C>
C>    @details Solve CP-DFTB equation for each vectors.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L0 LQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IRAF 20
C>    @param IORA Status of .F20
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NVIRT Number of virtual orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param U U matrix (derivative of MO coefficients)
C>    @parma VEC MO coefficients
C>    @param SDER Overlap derivative matrix
C>    @param EIG Eigenvalue of each MO
C>    @param OCC Occupation number of each MO
C>    @param SHIFT Shift contribution of each atom
C>    @param GAMMA Matrix of DFTB2 gamma
C>    @param GAMDER Derivative matrix of DFTB2 gamma
C>    @param S Overlap matrix
C>    @param CHAMUL Mulliken charges of each atom
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param UINIT Initial U matrix (only with non-response terms)
C>    @param D Density matrix
C>    @param HDERIJ H_{ij}^a + V_{ij}^a
C>    @param SDERIJ S_{ij}^a
C>    @param GAMMA3 Matrix of DFTB3 gamma
C>    @param GAMDER3 Derivative matrix of DFTB3 gamma
C>    @param DISK Whether disk-based algorithm or not
C>    @param FON Whether fractional occupation is used or not
C>    @param REDUCE Whether reduced memory CP-DFTB or not
C>    @param ROHF Whether (same-electron) RO-DFTB or not
C>           RO-DFTB with canonicalization has not been implemented
C>    @param UHF Whether U-DFTB or not
C>    @param NGAMMA Dimension of gamma matrices (NAT or NSHELL)
C>    @param SHIFTSA Shift contribution for alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution for beta  orbitals (shell-res.)
C>    @param INDSH Shell index of each atom
C>    @param INDSAO AO index of each shell
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param CHAMULS shell-resolved Mulliken charges
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param SPNCST Spin constants
C>    @param DIRECT Integral direct ... meaningless option now
C>    @param ID_HDERMO,ID_SDERMO,ID_SDERAO IDs of HDERIJ,SDERIJ,SDER
C>           stored on DDI memory pool.
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>    @param DIPDER Dipole derivative
C>
C
      SUBROUTINE DFTB_CP(L0,L1,L2,IRAF,IORA,NDOCC,NVIRT,NPART,U,VEC,
     *  SDER,EIG,OCC,SHIFT,GAMMA,GAMDER,S,CHAMUL,DISTMAT,UINIT,
     *  HESSIAN,D,HDERIJ,SDERIJ,GAMMA3,GAMDER3,DIPDER,DISK,FON,REDUCE,
     *  ROHF,UHF,NGAMMA,SHIFTSA,SHIFTSB,INDSH,INDSAO,
     *  NSPIN,CHAMULS,NDIMSH,SPNCST,DIRECT,ID_HDERMO,ID_SDERMO,
     *  ID_SDERAO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=5000,MXSPE=10)
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /FMCOM / X(1)
      COMMON /IOFILE/ IR,IW,IP,IS,IPK,IDAF,NAV,IODA(950)
      DOUBLE PRECISION :: U(L1,L1,NSPIN),VEC(L1,L1,NSPIN),
     *  SDER(L2,3,NAT),EIG(L1,NSPIN),OCC(L1,NSPIN),SHIFT(NAT),
     *  UINIT(L1,L1,NSPIN),GAMMA(*),GAMDER(*),S(L2),CHAMUL(NAT),
     *  DISTMAT(*),HESSIAN(3*NAT,3*NAT),HDERIJ(L2,3,NAT,NSPIN),
     *  SDERIJ(L2,3,NAT,NSPIN),DIPDER(3,3,NAT),D(L2,NSPIN),
     *  GAMMA3(NGAMMA,NGAMMA),GAMDER3(NGAMMA,NGAMMA),
     *  SHIFTSA(NDIMSH),SHIFTSB(NDIMSH),CHAMULS(NDIMSH),SPNCST(6,*)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL3
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      LOGICAL :: MYJOB,ISGDDI,PAROUT,INITGDDI,WASGDDI
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      DATA  CHECK/8HCHECK   /
C
      INTEGER :: IRAF,IORA(3*NAT*5),O,INDSH(*),INDSAO(*),NDOCC(2),
     *  NPART(2),NVIRT(2)
      INTEGER, PARAMETER :: DDI_WORLD=0,DDI_GROUP=1
      DOUBLE PRECISION,PARAMETER ::
     *  ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,
     *  DEBYE_ANGSTROM=2.541746675D+00*1.889725989D+00
      DOUBLE PRECISION, PARAMETER :: ONE_THIRD=1.0D+00/3.0D+00
      DOUBLE PRECISION :: V(3),AUP(9,9),BUP(9,9)
C
      LOGICAL :: DISK,FON(3),REDUCE,ROHF,UHF,DIRECT!!,FIRST
      LOGICAL SKP
C
      IF (MASWRK) WRITE (IW,*) "START COUPLED-PERTURBED DFTB"
      IF (ISGDDI) CALL GDDI_SCOPE(DDI_GROUP)
      L3 = L1*L1
      CALL VALFM(LOADFM)
      CALL GOTFM(NGOTMX)
C
      LDEDB        = LOADFM     + 1
      LSDER        = LDEDB      + L1*NSPIN
      LHDERIJ      = LSDER      + L2
      LSDERIJ      = LHDERIJ    + L2*NSPIN
      LFDERIJ      = LSDERIJ    + L2*NSPIN
      LSOMGDIJ     = LFDERIJ    + L2*NSPIN
      LQDER_INIT   = LSOMGDIJ   + L2*NSPIN
      LDOMEGA      = LQDER_INIT + NDIMSH*NSPIN
      LWRK         = LDOMEGA    + L2*NSPIN
      LWRK1        = LWRK       + L3
      LWRK2        = LWRK1      + L3
      LWRK3        = LWRK2      + L3
      LQDER        = LWRK3      + L2
      LSDSHIJ      = LQDER      + NDIMSH*NSPIN
      LINDEX       = LSDSHIJ    + L2
      LDTMP        = LINDEX     + (NDOCC(1)+NPART(1))*L1*NSPIN
      LRESPONSE    = LDTMP      + L2*NSPIN
      IF (.NOT.SCC) THEN
        LAST       = LRESPONSE  + L1*L1
      ELSE IF (REDUCE) THEN
        IF (MASWRK) WRITE (IW,*) "THIS IS A REDUCED MEMORY RUN"
        LAST       = LRESPONSE  + L1*L1*NSPIN
      ELSE
        LAST       = LRESPONSE  + L1*L1*NDIMSH*NSPIN
      END IF
C
      IF (SCC) THEN
        LDERSHIFT  = LAST
        LDSH       = LDERSHIFT  + NDIMSH
        LQDER_PREV = LDSH       + NDIMSH
        LDERSH     = LQDER_PREV + NDIMSH*NSPIN
        LSDEROMG   = LDERSH     + L2
        LAST       = LSDEROMG   + L2
      END IF
C
      IF (FON(3)) THEN
        LDEDB_INIT = LAST
        LDNDR      = LDEDB_INIT + L1
        LAST       = LDNDR      + L1
      ELSE
        LDEDB_INIT = LAST
        LDNDR      = LAST
      END IF
      IF (UHF) THEN
        LSHIFTSP   = LAST
        LAST       = LSHIFTSP   + NDIMSH
      ELSE
        LSHIFTSP   = LAST
      END IF
      NEED         = LAST - LOADFM - 1
C
C     ----- GET MEMORY -----
C
      CALL GETFM(NEED)
      IF (EXETYP.EQ.CHECK) GO TO 1000
      IF (UHF.OR.SRSCC) NSHELL = NDIMSH
      IF (MASWRK) THEN
        WRITE (IW,'(" ...... ALLOCATED MEMORY IN DFTB_CP",
     * " = ",I10," WORDS")') NEED
        WRITE (IW,*)
      END IF
C
C     PREPARE FOR RESPONSE TERMS
C
      IF (SCC) THEN
        IF (REDUCE) THEN
          CALL DFTB_PREP_RESPONSE_REDUCE(L1,L2,VEC,S,X(LRESPONSE),
     *      X(LWRK),NSPIN)
        ELSE
          CALL DFTB_PREP_RESPONSE(NAT,L1,L2,IND,VEC,
     *      S,X(LRESPONSE),SRSCC,UHF,INDSAO,NSPIN,NDIMSH,NDIMSH,X(LWRK),
     *      X(LWRK1))
C         do i = 1, l1*l1*ndimsh*nspin
C           write (*,*) i,x(lresponse+i-1)
C         end do
        END IF
      END IF
      CALL VCLR(X(LDEDB),1,L1*NSPIN)
      IF (FON(3)) THEN
        CALL VCLR(X(LDEDB_INIT),1,L1)
        CALL VCLR(X(LDNDR),1,L1)
      END IF
C
      IF (FON(3)) THEN
        !! CALCULATE PARTIAL DENSITY MATRIX
        !! D'_{\mu \nu} = \sum_i^{NDOCC} n_i c_{\mu i} c_{\nu i}
        DO ISPIN = 1, NSPIN
          CALL DFTB_DPART(L1,L2,NDOCC(ISPIN),OCC(1,ISPIN),
     *      X(LDTMP+L2*(ISPIN-1)),VEC(1,1,ISPIN))
        END DO
      ELSE
        CALL DCOPY(L2*NSPIN,D,1,X(LDTMP),1)
      END IF
C
CD    tt0 = zero
CD    tt1 = zero
CD    tt2 = zero
CD    tt3 = zero
CD    tt4 = zero
CD    tt5 = zero
CD    tti = zero
CD    ttq = zero
CD    ttnr = zero
CD    ttqder = zero
CD    ttbr = zero
CD    ttittftri = zero
CD    ttdedb=zero
CD    ttpdedb=zero
CD    tttftri=zero
CD    tfon = zero
C
      MXITER = 100
      ALPHA = 1.0D+00
      THRES = 1.0D-06
C     IF (SRSCC.OR.UHF) THRES = 1.0D-08
      NITER = 0
      IF (MASWRK.AND.SCC) THEN
        WRITE (IW,'(" CONVERGENCE THRESHOLD IN CP-DFTB = ",E10.2)')THRES
        WRITE (IW,'(" MAX ITERATION OF CP-DFTB         = ",I5)') MXITER
        WRITE (IW,'(" INITIAL MIX PARAMETER IN BROYDEN = ",F8.5)') ALPHA
      END IF
C
C     PREPARE INDEX FOR DFTB_DEDB
C
      NDIM = (NDOCC(1)+NPART(1))*L1
      CALL DFTB_HESS_INDEX(OCC,X(LINDEX),NDOCC,NPART,L1,NDIM,NSPIN)
C
      PARALL3 = GOPARR
      IPCOUNT = ME - 1
      IF (PARALL3.AND..NOT.ISGDDI) THEN
        GOPARR = .FALSE. !! AVOID PARALLEL CALCULATION IN TFTRI0
        IF (MASWRK) THEN
          WRITE (IW,'(" PARALLEL CALCULATION WITH ",I3," CORES")')NPROC
        ELSE
          DSKWRK = .FALSE.
        END IF
      END IF
      IF (ISGDDI) THEN
        IF (MASWRK) THEN
          WRITE (IW,'(" PARALLEL (GDDI) CALCULATION WITH ",
     *      I3," CORES")') NGROUPS
        END IF
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL DDI_COMMID(DDI_WORLD,IDWORLD)
        IDW = IDWORLD
        CALL GDDICOUNT(-1,LGROUP,MYJOB)
      END IF
      IRA1 = 0            !! HDERIJ
      IRA2 = IRA1 + NAT*3 !! SDERIJ
      IRA3 = IRA2 + NAT*3 !! SDER
      IRA4 = IRA3 + NAT*3 !! HDERIJ (BETA)
      IRA5 = IRA4 + NAT*3 !! SDERIJ (BETA)
C     write (*,*) "disk = ", disk
CD    CALL CPU_TIME(TIT0)
CD    CALL SYSTEM_CLOCK(ICLOCK_COUNTS_1,ICLOCK_RATE)
CD    FIRST = .TRUE.
      FONCON = ZERO
      IR0 = 0
      DO NI = 1, NAT
        IF(PARALL3.AND..NOT.ISGDDI) THEN
          IPCOUNT = IPCOUNT + 1
          IF (MOD(IPCOUNT,NPROC).NE.0) THEN
            IF (DISK) THEN
              IRA1 = IRA1 + 3
              IRA2 = IRA2 + 3
              IRA3 = IRA3 + 3
              IRA4 = IRA4 + 3
              IRA5 = IRA5 + 3
            END IF
            CYCLE
          END IF
        END IF
        IF (ISGDDI) THEN
          call GDDICOUNT(0,LGROUP,MYJOB)
          IF (.NOT.MYJOB) THEN
            IR0 = IR0 + 3
            CYCLE
          END IF
        END IF
        DO KI = 1, 3
C         write (*,*) "eigenvalues"
C         do i = 1, l1
C           write (*,'(i3,x,f20.10)') i,eig(i,1)
C         end do
CD        call cpu_time(t0)
          IR0 = IR0 + 1
          IF (DISK) THEN
            IRA1 = IRA1 + 1
            IRA2 = IRA2 + 1
            IRA3 = IRA3 + 1
            IRA4 = IRA4 + 1
            IRA5 = IRA5 + 1
            CALL RAREAD(IRAF,IORA,X(LHDERIJ) ,L2,IRA1,0)
            CALL RAREAD(IRAF,IORA,X(LSDERIJ) ,L2,IRA2,0)
            IF (SCC) THEN
              CALL RAREAD(IRAF,IORA,X(LSDER) ,L2,IRA3,0)
              IF (UHF) THEN
                CALL RAREAD(IRAF,IORA,X(LHDERIJ+L2),L2,IRA4,0)
                CALL RAREAD(IRAF,IORA,X(LSDERIJ+L2),L2,IRA5,0)
              END IF
            END IF
          ELSE IF (DIRECT) THEN
            CALL DFTB_HESS_DIRECT(X(LHDERIJ),X(LSDERIJ),X(LSDER),C,
     *        VEC,SHIFT,SHIFTSA,SHIFTSB,X(LWRK),X(LWRK1),X(LWRK2),
     *        X(LWRK3),NI,KI,NAT,L0,L1,L2,IND,NSHELL,NSPE,NSPIN,INDSH,
     *        INDSAO,ISPE,MAXANG,SCC,SRSCC,UHF)
          ELSE IF (ISGDDI) THEN
C           write (iw,*) "going to read", ni,ki
C           write (iw,*) "ir0 = ", ir0
C           CALL DDI_GET(ID_HDERMO,1,L2*NSPIN,IR0,IR0,X(LHDERIJ))
C           CALL DDI_GET(ID_SDERMO,1,L2*NSPIN,IR0,IR0,X(LSDERIJ))
C           CALL DDI_GET(ID_SDERAO,1,L2      ,IR0,IR0,X(LSDER))
          CALL DDI_GET_COMM(ID_HDERMO,1,L2*NSPIN,IR0,IR0,X(LHDERIJ),IDW)
          CALL DDI_GET_COMM(ID_SDERMO,1,L2*NSPIN,IR0,IR0,X(LSDERIJ),IDW)
          CALL DDI_GET_COMM(ID_SDERAO,1,L2      ,IR0,IR0,X(LSDER),IDW)
C           call prtril (x(lhderij),l1)
C           call prtril (x(lsderij),l1)
C           call prtril (x(lsder),l1)
          ELSE
            CALL DCOPY(L2,HDERIJ(1,KI,NI,1),1,X(LHDERIJ),1)
            CALL DCOPY(L2,SDERIJ(1,KI,NI,1),1,X(LSDERIJ),1)
            IF (SCC) THEN
              CALL DCOPY(L2,SDER(1,KI,NI),1,X(LSDER),1)
              IF (UHF) THEN
                CALL DCOPY(L2,HDERIJ(1,KI,NI,2),1,X(LHDERIJ+L2),1)
                CALL DCOPY(L2,SDERIJ(1,KI,NI,2),1,X(LSDERIJ+L2),1)
              END IF
            END IF
C           call prtril (x(lhderij),l1)
C           call prtril (x(lsderij),l1)
C           call prtril (x(lsder),l1)
          END IF
C         write (*,*) "ni,ki = ", ni,ki
C         write (*,*) "hderij"
C         call prtril(x(lhderij),l1)
C         write (*,*) "sderij"
C         call prtril(x(lsderij),l1)
C         write (*,*) "sder"
C         call prtril(x(lsder),l1)
CD        call cpu_time(ti)
C
C         CALCULATE GAMDER_SHIFT FIRST
C
          IF (SCC) THEN
            IF (SRSCC) THEN
              CALL DFTB_CALC_DERSHIFT_SHELL(NAT,NI,KI,C,DISTMAT,GAMDER,
     *          GAMDER3,CHAMULS,X(LDSH),DFTB3,NSHELL,INDSH,NSPE,ISPE,
     *          MAXANG)
              CALL SHIFT_TRIANGLE_SHELL(X(LDSH),S,X(LDERSH),NAT,NSPE,
     *          NSHELL,L2,ISPE,MAXANG)
            ELSE
              CALL DFTB_CALC_DERSHIFT(NAT,NI,KI,C,DISTMAT,GAMDER,
     *          GAMDER3,CHAMUL,X(LDSH),DFTB3)
              CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LDSH),S,X(LDERSH))
            END IF
C           write (*,*) "dsh"
C           do i = 1, ndimsh
C             write (*,'(i3,x,f20.10)') i,x(ldsh+i-1)
C           end do
CD          call cpu_time(ttftri0)
C           write (*,*) "ndocc = ", ndocc(1)
C           write (*,*) "npart = ", npart(1)
C           write (*,*) "dersh"
C           call prtril(X(Ldersh),l1)
C           call vclr(x(lsomgdij),1,l2)
            DO ISPIN = 1, NSPIN
C             write (*,*) "ndocc(ispin ) = ", ndocc(ispin)
C             write (*,*) "npart(ispin ) = ", npart(ispin)
              CALL DFTB_TFTRI0(NDOCC(ISPIN),NPART(ISPIN),
     *          X(LSOMGDIJ+L2*(ISPIN-1)),X(LDERSH),VEC(1,1,ISPIN),
     *          X(LWRK),L0,L1,L1)
            END DO
CD          call cpu_time(ttftri1)
C           write (*,*) "somgdij"
C           call prtril(x(lsomgdij),l1)
CD          tttftri = tttftri + ttftri1-ttftri0
C
C         CALCULATE NON-RESEPONT TERMS FOR QDER
C
            IF (SRSCC.OR.UHF) THEN
              DO ISPIN = 1, NSPIN
                CALL DFTB_PREP_QDER(NDIMSH,L0,L1,L2,
     *            INDSAO,X(LQDER_INIT+NDIMSH*(ISPIN-1)),
     *            D(1,ISPIN),X(LDTMP+L2*(ISPIN-1)),S,X(LSDER),X(LWRK),
     *            X(LWRK1),X(LWRK2),X(LWRK3),UHF)
              END DO
C             CALL DCOPY(NDIMSH,X(LQDER_INIT),1,X(LWRK),1)
C             CALL DFTB_SHIFT_SHTOA(X(LWRK),X(LWRK2),NAT,NSHELL,NSPE,
C    *          ISPE,MAXANG)
C             CALL DFTB_SHIFT_SHTOA(X(Lqder_init+ndimsh),X(LWRK3),NAT,
C    *          NSHELL,NSPE,ISPE,MAXANG)
C             call
C    *        vadd(x(lwrk),1,x(lqder_init+ndimsh),1,x(lwrk),1,ndimsh)
C             CALL DFTB_SHIFT_SHTOA(X(LWRK),X(LWRK1),NAT,NSHELL,NSPE,
C    *          ISPE,MAXANG)
C           write (*,*) "QDER_INIT"
C           do i = 1, ndimsh
C             tmp = x(lqder_init+i-1)
C             if (uhf) tmp = tmp + x(lqder_init+i-1+ndimsh)
C             write (*,'(i3,x,f20.10)') i,tmp
C           end do
C           do i = 1, nat
C             tmp = x(lwrk1+i-1)
C             tmp2 = x(lwrk2+i-1)
C             tmp3 = x(lwrk3+i-1)
C             write (*,'(i3,3(x,f20.10))') i,tmp,tmp2,tmp3
C           end do
            ELSE
              CALL DFTB_PREP_QDER(NAT,L0,L1,L2,IND,
     *          X(LQDER_INIT),D,X(LDTMP),S,X(LSDER),X(LWRK),X(LWRK1),
     *          X(LWRK2),X(LWRK3),UHF)
C           write (iw,*) "QDER_INIT"
C           do i = 1, ndimsh
C             tmp = x(lqder_init+i-1)
C             if (uhf) tmp = tmp + x(lqder_init+i-1+ndimsh)
C             write (iw,'(i3,x,f20.10)') i,tmp
C           end do
            END IF
          ELSE
            CALL VCLR(X(LSOMGDIJ),1,L2)
          END IF
CD        call cpu_time(tq)
C
C         CALCULATE NON-RESEPONT TERMS
C
          DO ISPIN = 1, NSPIN
C           WRITE (*,*) "UINIT OF ISPIN = ", ispin
            CALL DFTB_CP_NR(L1,L2,
     *        EIG(1,ISPIN),OCC(1,ISPIN),UINIT(1,1,ISPIN),
     *        X(LHDERIJ+L2*(ISPIN-1)),X(LSDERIJ+L2*(ISPIN-1)),
     *        X(LSOMGDIJ+L2*(ISPIN-1)))
C           write (*,*) "hderij"
C           call prtril(x(lhderij),l1)
C           write (*,*) "sderij"
C           call prtril(x(lsderij),l1)
C           write (*,*) "lsomgdij"
C           call prtril(x(lsomgdij),l1)
C      write (iw,*) "Ki, ni = ", ki, ni
C      call prsq(uinit(1,1,ispin),l1,l1,l1)
          END DO
          CALL DCOPY(L1*L1*NSPIN,UINIT,1,U,1)
CD        call cpu_time(tnr)
C
C         PREPARE FOR DE/DR CALCULATION
C
CD        call cpu_time(fon0)
          IF (FON(3).AND..NOT.ROHF) THEN
            CALL DFTB_CALC_DNDR(0,L1,L2,NDOCC(1),NPART(1),ETEMP,
     *        X(LDEDB_INIT),X(LDEDB),X(LDNDR),OCC,EIG,X(LHDERIJ),
     *        X(LSDERIJ),X(LSOMGDIJ),FEDER,SCC)
          END IF
CD        call cpu_time(fon1)
          IF (.NOT.SCC)  then
CD          t1 = zero
CD          t3 = zero
CD          t4 = zero
CD          t5 = zero
CD          t45 = zero
            IF (FON(3).AND..NOT.ROHF) THEN
                CALL DFTB_CALC_DNDR(1,L1,L2,NDOCC(1),NPART(1),ETEMP,
     *            X(LDEDB_INIT),X(LDEDB),X(LDNDR),OCC,EIG,X(LHDERIJ),
     *            X(LSDERIJ),X(LSDSHIJ),FEDER,SCC)
            END IF
            GO TO 100
          END IF
C
C         START CP-DFTB ITERATION
C
          MEMMIX = 0
CD        call cpu_time(t1)
          CALL DCOPY(NDIMSH*NSPIN,X(LQDER_INIT),1,X(LQDER_PREV),1)
          DO ITER = 1, MXITER
            VMAX = ZERO
CD          VMXT = ZERO
CD          call cpu_time(qder0)
            IF (REDUCE) THEN
              DO ISPIN = 1, NSPIN
                CALL DFTB_CALC_QDER_REDUCE(NAT,L1,IND,NDOCC(ISPIN),
     *          NPART(ISPIN),X(LQDER+NDIMSH*(ISPIN-1)),
     *          U(1,1,ISPIN),OCC(1,ISPIN),
     *          X(LQDER_INIT+NDIMSH*(ISPIN-1)),
     *          X(LRESPONSE+L1*L1*(ISPIN-1)),X(LDNDR+L1*(ISPIN-1)),
     *          VEC(1,1,ISPIN),FON(ISPIN),SRSCC,NSPE,
     *          ISPE,MAXANG,NSHELL)
              END DO
            ELSE
              DO ISPIN = 1, NSPIN
                CALL DFTB_CALC_QDER(NAT,L1,NDOCC(ISPIN),NPART(ISPIN),
     *            NVIRT(ISPIN),X(LQDER+NDIMSH*(ISPIN-1)),U(1,1,ISPIN),
     *            OCC(1,ISPIN),X(LQDER_INIT+NDIMSH*(ISPIN-1)),
     *            X(LRESPONSE),X(LDNDR+L1*(ISPIN-1)),FON(ISPIN),NSPIN,
     *            SRSCC,UHF,NDIMSH,NSPE,ISPE,MAXANG,ISPIN)
              END DO
            END IF
C           if (iter.eq.1) then
C           write (*,*) "QDER IN THE FIRST CYCLE"
C           do i = 1, nat
C             tmp = qder(i,1)
C             if (uhf) tmp = tmp + qder(i,2)
C             write (*,'(i3,x,f20.10)') i,qder(i,1)
C           end do
C           end if
CD          call cpu_time(qder1)
CD          ttqder = ttqder + qder1-qder0
C
C           CALCULATE CHANGE OF QDER FROM PREVIOUS ITERATION
C
CD          call cpu_time(br0)
            N = 0
            DO ISPIN = 1, NSPIN
              DO I = 1, NDIMSH
                N = N + 1
                TMP = ABS(X(LQDER+N-1)-X(LQDER_PREV+N-1))
                VMAX = MAX(VMAX,TMP)
              END DO
            END DO
C
C           BROYDEN MIXING FOR QDER
C
C           write (iw,*) "current and previous qder"
C           do j = 1, nspin
C           do i = 1, ndimsh
C             write (iw,'(i3,x,f20.10,x,f20.10)')
C    *        i,qder(i,j),qder_prev(i,j)
C           end do
C           end do
            CALL DFTB_MIX_BROYDEN(ITER,NDIMSH*NSPIN,MXITER,MEMMIX,
     *        ALPHA,X(LQDER_PREV),X(LQDER),ERDIIS)
            CALL DCOPY(NDIMSH*NSPIN,X(LQDER),1,X(LQDER_PREV),1)
CD          call cpu_time(br1)
CD          ttbr = ttbr + br1-br0
C
            CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK),1)
            IF (UHF) THEN
              CALL VADD(X(LWRK),1,X(LQDER+NDIMSH),1,X(LWRK),1,NDIMSH)
              IF (.NOT.SRSCC) THEN
                CALL DFTB_SHIFT_SHTOA(X(LWRK),X(LWRK1),NAT,NSHELL,NSPE,
     *            ISPE,MAXANG)
                CALL DCOPY(NAT,X(LWRK1),1,X(LWRK),1)
              END IF
            END IF
C
            CALL VCLR(X(LDERSHIFT),1,NGAMMA)
            DO NN = 1, NGAMMA
              DO NC = 1, NGAMMA
                CALL DFTB_CNVSQ(NN,NC,NSEQ)
C               DERSHIFT(NN) = DERSHIFT(NN)+GAMMA(NSEQ)*QDER(NC)
                X(LDERSHIFT+NN-1)
     *            = X(LDERSHIFT+NN-1) + GAMMA(NSEQ)*X(LWRK+NC-1)
              END DO
            END DO
C
            IF (DFTB3) THEN
              DO NN = 1, NGAMMA
                DO NC = 1, NGAMMA
                  X(LDERSHIFT+NN-1) = X(LDERSHIFT+NN-1) + TWO*(
     *             + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NN)*X(LWRK+NC-1)
     *             + ONE_THIRD*GAMMA3(NC,NN)*CHAMUL(NC)*X(LWRK+NC-1)
     *             + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NC)*X(LWRK+NN-1))
C    *             + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NN)*QDER(NC)*2.0D+00
C    *             + ONE_THIRD*GAMMA3(NC,NN)*CHAMUL(NC)*QDER(NC)*2.0D+00
C    *             + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NC)*QDER(NN)*2.0D+00
                END DO
              END DO
            END IF
C
C           CONVERT ATOM-RESOLVED SHIFT TO SHELL-RESOLVED SHIFT,
C           AND CALCULATE SPIN CONTRIBUTION
C
            IF (UHF) THEN
              IF (.NOT.SRSCC) THEN
                CALL DCOPY(NAT,X(LDERSHIFT),1,X(LWRK),1)
                CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LDERSHIFT),NAT,NSHELL,
     *            NSPE,ISPE,MAXANG)
              END IF
C             FORM d(q^a-q^b)/dR (DERIVATIVE OF SPIN DENSITY) AS X(LWRK)
              CALL DCOPY(NSHELL,X(LQDER),1,X(LWRK),1)
              CALL VSUB(X(LQDER+NDIMSH),1,X(LWRK),1,
     *          X(LWRK),1,NSHELL)
C
              CALL VCLR(X(LSHIFTSP),1,NDIMSH)
              CALL DFTB_SPIN_SHIFT(X(LSHIFTSP),X(LWRK),SPNCST,NAT,
     *          NSHELL,NSPE,ISPE,MAXANG)
              CALL DCOPY(NDIMSH,X(LDERSHIFT),1,X(LWRK1),1)
            END IF
C
C           CALCULATE RESPONSE PART OF S*d(OMEGA)/dR AS SDSHIJ
C
            IF (KI.EQ.1) CALL VCLR(X(LSDEROMG),1,L2)
            DO ISPIN = 1, NSPIN
              IF (SRSCC.OR.UHF) THEN
                IF (UHF) THEN
                  IF (ISPIN.EQ.1) THEN
                   CALL VADD(X(LSHIFTSP),1,X(LDERSHIFT),1,X(LDERSHIFT),
     *               1,NDIMSH)
                  ELSE
                    CALL DCOPY(NDIMSH,X(LWRK1),1,X(LDERSHIFT),1)
                    CALL VSUB(X(LSHIFTSP),1,X(LDERSHIFT),1,X(LDERSHIFT),
     *                1,NDIMSH)
                  END IF
                END IF
                CALL SHIFT_TRIANGLE_SHELL(X(LDERSHIFT),S,X(LSDEROMG),
     *            NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
              ELSE
               CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LDERSHIFT),S,
     *           X(LSDEROMG))
              END IF
CD            call cpu_time(ttftri0)
              CALL DFTB_TFTRI0(NDOCC(ISPIN),NPART(ISPIN),X(LSDSHIJ),
     *          X(LSDEROMG),VEC(1,1,ISPIN),X(LWRK),L0,L1,L1)
CD            call cpu_time(ttftri1)
CD            tttftri = tttftri + ttftri1-ttftri0
CD            ttittftri = ttittftri + ttftri1-ttftri0
C
C             UPDATE de/dR, de_F/dR, and dn/dR VECTORS
C
CD            call cpu_time(fon2)
              IF (FON(3).AND..NOT.ROHF) THEN
                  CALL DFTB_CALC_DNDR(1,L1,L2,NDOCC(1),NPART(1),ETEMP,
     *              X(LDEDB_INIT),X(LDEDB),X(LDNDR),OCC,EIG,
     *              X(LHDERIJ),X(LSDERIJ),X(LSDSHIJ),FEDER,SCC)
              END IF
C             CALL VCLR(X(LDNDR),1,L1)
C             IF (NI.EQ.1.AND.KI.EQ.1.AND.ITER.EQ.1) THEN
C               WRITE (IW,'(//"ZERO OUT DNDR MATRIX !!"//)')
C             END IF
CD            call cpu_time(fon3)
C
C             CONSTRUCT NEW U MATRIX
C
CD            call cpu_time(u0)
              CALL DFTB_HESS_UUPDATE(U(1,1,ISPIN),UINIT(1,1,ISPIN),
     *          X(LSDSHIJ),EIG(1,ISPIN),OCC(1,ISPIN),L1,L2,NDOCC(ISPIN),
     *          NPART(ISPIN))
CD            call cpu_time(u1)
CD            ttu = ttu + u1-u0
            END DO !! END OF SPIN LOOP
C           WRITE (*,'(I3,x,F20.10)') iter,vmax
            IF (ITER.GE.2.AND.VMAX.LE.THRES) THEN
             NITER = NITER + ITER
C             WRITE (*,'(" ROOT",I3," - ",I1," CONVERGED IN", I3,
C    *          " CYCLES: DELTA Q_DER = ",E10.3)') NI,KI,ITER,VMAX
              EXIT
            END IF
          END DO !! END OF CP ITERATION
C         WRITE (*,*) "U MATRIX"
C         CALL PRSQ(U,L1,L1,L1)
C         WRITE (*,*)
C         WRITE (*,*) "SDER MATRIX"
C         CALL PRTRIL(X(LSDERIJ),L1)
C         WRITE (*,*)
C         WRITE (*,*) "DEGENERATED ORBITALS"
C         DO IO = 1, L1
C           DO JO = IO+1, L1
C             IF (ABS(EIG(IO)-EIG(JO)).LE.1.0D-06) THEN
C               CALL DFTB_CNVSQ(IO,JO,NSEQ)
C               WRITE (*,'(I3,X,I3,4(X,F20.10))')
C    *            IO,JO,U(IO,JO),U(JO,IO),U(IO,JO)+U(JO,IO),
C    *            X(LSDERIJ+NSEQ-1)
C             END IF
C           END DO
C         END DO
          CALL RETFM(MEMMIX)
C
C         FOR UHF CALCULATION:
C         QDER(1,1) :: TOTAL CHARGE DERIVATIVE
C         QDER(1,2) :: SPIN DERIVATIVE
C
C           if (uhf) call dscal(ndimsh*nspin,two,qder(1,1),1)
C         WRITE (*,*) "QDER (ALPHA)"
C         DO IO = 1, NDIMSH
C           WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,1)
C         END DO
C         IF (UHF) THEN
C           WRITE (*,*) "QDER (BETA)"
C           DO IO = 1, NDIMSH
C             WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,2)
C           END DO
C         END IF
          IF (UHF) THEN
            CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK),1)
            CALL VADD(X(LQDER+NDIMSH),1,X(LQDER),1,X(LQDER),1,NDIMSH)
            CALL DSCAL(NDIMSH,-ONE,X(LQDER+NDIMSH),1)
            CALL VADD(X(LWRK),1,X(LQDER+NDIMSH),1,
     *        X(LQDER+NDIMSH),1,NDIMSH)
          END IF
C         WRITE (*,*) "QDER (TOTAL)"
C         DO IO = 1, NDIMSH
C           WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,1)
C         END DO
C
C         CALCULATE d(OMEGA)/dR
C         d(OMEGA)/dR IS SYMMETRIC
C
          IF (UHF.AND..NOT.SRSCC) THEN
            CALL DCOPY(NDIMSH,X(LQDER),1,X(LWRK),1)
            CALL DFTB_SHIFT_SHTOA(X(LWRK),
     *        X(LQDER),NAT,NSHELL,NSPE,ISPE,MAXANG)
          END IF
C         WRITE (*,*) "ATOM-RESOLVED QDER (TOTAL)"
C         DO IO = 1, NAT
C           WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,1)
C         END DO
CD        call cpu_time(t2)
          DO NM = 1, NGAMMA
            TMP1 = X(LDSH+NM-1)
            TMP2 = ZERO
            DO NC = 1, NGAMMA
              CALL DFTB_CNVSQ(NM,NC,NSEQ)
              TMP2 = TMP2 + GAMMA(NSEQ)*X(LQDER+NC-1)
            END DO
C           DSH(NM) = TMP1 + TMP2
            X(LDOMEGA+NM-1) = TMP1 + TMP2
          END DO
C
          IF (DFTB3) THEN
            DO NN = 1, NAT
              DO NC = 1, NAT
C               DSH(NN) = DSH(NN) + TWO*(
                X(LDOMEGA+NN-1) = X(LDOMEGA+NN-1) + TWO*(
     *           + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NN)*X(LQDER+NC-1)
     *           + ONE_THIRD*GAMMA3(NC,NN)*CHAMUL(NC)*X(LQDER+NC-1)
     *           + ONE_THIRD*GAMMA3(NN,NC)*CHAMUL(NC)*X(LQDER+NN-1))
              END DO
            END DO
          END IF
C         WRITE (*,*) "x(ldomega)"
C         DO IO = 1, NDIMSH
C           WRITE (*,'(I3,1(X,F20.10))') IO,X(LDOMEGA+IO-1)
C         END DO
C         if (uhf) then
C         WRITE (*,*) "SHELL-RESOLVED QDER (SPIN)"
C         DO IO = 1, NDIMSH
C           WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,2)
C         END DO
C         end if
C
          IF (UHF) THEN
            IF (.NOT.SRSCC) THEN
              CALL DCOPY(NAT,X(LDOMEGA),1,X(LWRK),1)
              CALL DFTB_SHIFT_ATOSH(X(LWRK),X(LDOMEGA),NAT,NSHELL,NSPE,
     *          ISPE,MAXANG)
            END IF
            CALL VCLR(X(LSHIFTSP),1,NDIMSH)
            CALL DFTB_SPIN_SHIFT(X(LSHIFTSP),X(LQDER+NDIMSH),SPNCST,NAT,
     *        NSHELL,NSPE,ISPE,MAXANG)
            CALL DCOPY(NSHELL,X(LDOMEGA),1,X(LDOMEGA+NSHELL),1)
            CALL VADD(X(LSHIFTSP),1,X(LDOMEGA),1,X(LDOMEGA),1,NSHELL)
            CALL VSUB(X(LSHIFTSP),1,X(LDOMEGA+NSHELL),1,
     *        X(LDOMEGA+NSHELL),1,NSHELL)
          END IF
C             ndn = nat*(nat+1)/2
C             write (*,*) "distance matrix, gamder before qder"
C             do i = 1, ndn
C               write (*,'(i3,2f20.10)') i,distmat(i),gamder(i)
C             end do
C
C         WE HAVE OBTAINED U MATRIX AND QDER NOW.
C
C         ADD QDER HESSIAN TERMS
C
CD        call cpu_time(t3)
          IF (SRSCC) THEN
            CALL DFTB_QDER(NI,KI,NAT,C,X(LQDER),GAMDER,GAMDER3,
     *        CHAMULS,DISTMAT,HESSIAN,DFTB3,SRSCC,NDIMSH,NSPE,ISPE,
     *        MAXANG)
          ELSE
            CALL DFTB_QDER(NI,KI,NAT,C,X(LQDER),GAMDER,GAMDER3,
     *        CHAMUL,DISTMAT,HESSIAN,DFTB3,SRSCC,NDIMSH,NSPE,ISPE,
     *        MAXANG)
          END IF
          !! CONVERT FROM SHELL-RESOLVED TO ATOM-RESOLVED QDER
          IF (SRSCC) CALL DFTB_SHIFT_SHTOA(X(LQDER),
     *        X(LQDER),NAT,NSHELL,NSPE,ISPE,MAXANG)
C             ndn = nat*(nat+1)/2
C             write (*,*) "distance matrix, gamder after qder"
C             do i = 1, ndn
C               write (*,'(i3,2f20.10)') i,distmat(i),gamder(i)
C             end do
CD        call cpu_time(t4)
C
C         d(OMEGA)/dR + d(EIG(IO))/dR TERMS
C
          !! X(LDOMEGA) d(OMEGA)/dR ON ATOM BASIS
          DO ISPIN = 1, NSPIN
            IF (SRSCC.OR.UHF) THEN
              CALL SHIFT_TRIANGLE_SHELL(X(LDOMEGA+NDIMSH*(ISPIN-1)),
     *          S,X(LWRK2),NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
            ELSE
              CALL SHIFT_TRIANGLE(NAT,L2,IND,X(LDOMEGA),S,X(LWRK2))
            END IF
CD          call cpu_time(ttftri0)
            CALL TFTRI0(X(LSOMGDIJ+L2*(ISPIN-1)),X(LWRK2),
     *        VEC(1,1,ISPIN),X(LWRK),L0,L1,L1)
CD          call cpu_time(ttftri1)
CD          tttftri = tttftri + ttftri1-ttftri0
          END DO
CD        call cpu_time(t45)
C         do ispin = 1, nspin
C           do i = 1, ndimsh
C             write (*,'(i3,x,f20.10)')
C    *        i,x(ldomega+i-1+ndimsh*(ispin-1))
C           end do
C           write (*,*)
C         end do
C
C         ADD U-DEPENDENT TERM AND DE/DB DEPENDENT TERMS
C
100       CALL DFTB_DEDB(HESSIAN(1,3*(NI-1)+KI),X(LWRK),X(LWRK1),
     *      X(LWRK2),X(LWRK3),X(LFDERIJ),X(LDEDB),
     *      HDERIJ,SDERIJ,SDER,U,VEC,D,EIG,OCC,
     *      X(LDNDR),X(LDOMEGA),
     *      X(LHDERIJ),X(LSDERIJ),X(LSOMGDIJ),SHIFT,SHIFTSA,
     *      SHIFTSB,C,FONCON,
     *      NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC,NPART,
     *      NSPE,ISPE,MAXANG,IND,INDSH,INDSAO,IRAF,IORA,
     *      ID_HDERMO,ID_SDERMO,ID_SDERAO,IDW,X(LINDEX),
     *      SCC,DISK,FON,ROHF,SRSCC,UHF,DIRECT,ISGDDI)
C             ndn = nat*(nat+1)/2
C             write (*,*) "distance matrix, gamder after dedb"
C             do i = 1, ndn
C               write (*,'(i3,2f20.10)') i,distmat(i),gamder(i)
C             end do
C         WRITE (*,*) "U MATRIX (ALPHA)"
C         CALL PRSQ(U,L1,L1,L1)
C         WRITE (*,*)
C         IF (UHF) THEN
C           WRITE (*,*) "U MATRIX (BETA)"
C           CALL PRSQ(U(1,1,2),L1,L1,L1)
C           WRITE (*,*)
C         END IF
C         WRITE (IW,*) "QDER (ALPHA)"
C         DO IO = 1, NDIMSH
C           WRITE (IW,'(I3,1(X,F20.10))') IO,QDER(IO,1)
C         END DO
C         IF (UHF) THEN
C           WRITE (*,*) "QDER (BETA)"
C           DO IO = 1, NDIMSH
C             WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,2)
C           END DO
C           WRITE (*,*) "QDER (TOTAL)"
C           DO IO = 1, NDIMSH
C             WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,1)+QDER(IO,2)
C           END DO
C           WRITE (*,*) "QDER (SPIN)"
C           DO IO = 1, NDIMSH
C             WRITE (*,'(I3,1(X,F20.10))') IO,QDER(IO,1)-QDER(IO,2)
C           END DO
C         END IF
C         WRITE (*,*) "QDER,DEDB,DNDR"
C         DO IO = 1, NAT
C           WRITE (*,'(I3,3(X,F20.10))')
C    *      IO,X(LDEDB+IO-1),X(LDNDR+IO-1),X(LQDER+IO-1)
C         END DO
C         DO IO = NAT+1, L1
C           WRITE (*,'(I3,3(X,F20.10))')
C    *      IO,X(LDEDB+IO-1),X(LDNDR+IO-1),ZERO
C         END DO
C         WRITE (*,'(" CONVERGED DE_F/DR = ",F20.10)') FEDER
CD        call cpu_time(t5)
C
C         CALCULATE QDER IF NCC TO CALCULATE DIPOLE DERIVATIVE
C
          IF (.NOT.SCC) THEN
            IF (FON(3)) THEN
              CALL DFTB_DPART(L1,L2,NDOCC,OCC,X(LDTMP),VEC)
            ELSE
              CALL DCOPY(L2,D,1,X(LDTMP),1)
            END IF
            CALL VCLR(X(LSDER),1,L2)
            !! CALCULATE OVERLAP DERIVATIVE IN AO
            DO NJ = 1, NAT
              IF (NI.EQ.NJ) CYCLE
              CALL DFTB_DISPLACEMENT(NI,NJ,KI,0,V,C,0)
              CALL DFTB_SKODE_HELPA(1,NI,NJ,KI,0,V,AUP,BUP,.FALSE.,
     *          .TRUE.,SKP)
              DO L = 1, IND(NJ+1) - IND(NJ)
                O = IND(NJ)+L
                DO M = 1, IND(NI+1) - IND(NI)
                  N = IND(NI)+M
                  CALL DFTB_CNVSQ(N,O,NSEQ)
                  X(LSDER+NSEQ-1) = BUP(M,L)
                END DO
              END DO
            END DO
            CALL DFTB_PREP_QDER(NAT,L0,L1,L2,IND,
     *        X(LQDER),D,X(LDTMP),S,X(LSDER),X(LWRK),X(LWRK1),
     *        X(LWRK2),X(LWRK3),UHF)
            CALL DFTB_CALC_QDER_NCC(X(LQDER),U,OCC,X(LDNDR),S,X(LWRK),
     *        X(LRESPONSE),VEC,UINIT,NAT,L1,L2,NDOCC,NPART,NVIRT,IND,
     *        FON)
            CALL DSCAL(NAT,2.0D-01,X(LQDER),1) !! WHY?
          END IF
C
C         CALCULATE DIPOLE DERIVATIVE (TENSOR)
C
          DO I = 1, NAT
            DO J = 1, 3
              DIPDER(J,KI,NI) = DIPDER(J,KI,NI) - X(LQDER+I-1)*C(J,I)
            END DO
          END DO
          DIPDER(KI,KI,NI) = DIPDER(KI,KI,NI) - CHAMUL(NI)
          DO I = 1, 3
            DIPDER(I,KI,NI) = DIPDER(I,KI,NI) * DEBYE_ANGSTROM
          END DO
C
CD        call cpu_time(t6)
CD        tt0 = tt0 + t1-t0
CD        tti = tti + ti-t0
CD        ttq = ttq + tq-ti
CD        ttnr = ttnr + tnr-tq
CD        tt1 = tt1 + t2-t1
CD        tt2 = tt2 + t3-t2
CD        tt3 = tt3 + t4-t3
CD        tt4 = tt4 + t5-t4
CD        ttpdedb=ttpdedb+t45-t4
CD        ttdedb=ttdedb+t5-t45
CD        tt5 = tt5 + t6-t5
CD        tfon = tfon + fon3-fon2 + fon1-fon0
CD        IF (FIRST) THEN
CD          CALL CPU_TIME(TIT1)
CD          CALL SYSTEM_CLOCK(ICLOCK_COUNTS_2,ICLOCK_RATE)
CD          FIRST = .FALSE.
CD          TT = TIT1-TIT0
CD          TTW = (ICLOCK_COUNTS_2-ICLOCK_COUNTS_1)/DBLE(ICLOCK_RATE)
CD          IF (MASWRK) THEN
CD            IF (ISGDDI) THEN
CD              NP = NGROUPS
CD            ELSE
CD              NP = NPROC
CD            END IF
CD            WRITE (IW,'(/"   CALCULATION OF THE FIRST VECTOR TOOK
CD   * ",F8.2," CPU TIME (SECONDS)")') TT
CD            WRITE (IW,'("   ESTIMATED TIME FOR ",I4," VECTORS IS ",
CD   *          F10.2," SECONDS (",F7.2," HOURS)")')
CD   *          3*NAT,3*NAT*TT/DBLE(NP),3*NAT*TT/(3.6D+03*DBLE(NP))
CD            WRITE (IW,'( "  CALCULATION OF THE FIRST VECTOR TOOK
CD   * ",F8.2," WALL TIME (SECONDS)")') TTW
CD            WRITE (IW,'("   ESTIMATED TIME FOR ",I4," VECTORS IS ",
CD   *          F10.2," SECONDS (",F7.2," HOURS)")')
CD   *          3*NAT,3*NAT*TTW/DBLE(NP),3*NAT*TTW/(3.6D+03*DBLE(NP))
CD          END IF
CD        END IF
        END DO
      END DO
C
      IF (ISGDDI) THEN
        CALL GDDICOUNT( 1,LGROUP,MYJOB)
        CALL GDDI_SCOPE(DDI_WORLD)
      END IF
C
      IF (PARALL3.OR.ISGDDI) THEN
        CALL DDI_GSUMI(1,NITER,1)
        IF (FON(3)) CALL DDI_GSUMF(1,FONCON,1)
      END IF
      IF (MASWRK) THEN
      WRITE (IW,'(X,I4," ROOTS CONVERGED AFTER ",F5.1," CYCLES ON ",
     * "AVERAGE")')
     * 3*NAT,DBLE(NITER)/DBLE(3*NAT)
      WRITE (IW,*)
      IF (FON(3)) THEN
        FONCON = SQRT(FONCON/DBLE(NAT*NAT*9))
        WRITE (*,'(" RMS OF FON CONTRIBUTION = ",F20.10/)') FONCON
      END IF
C
CD    WRITE (*,'(A)') "CPU TIMES IN DFTB_CP SUBROUTINE"
CD    write (*,'(A,F10.5)') "TIME FOR ALL TFTRI0        ",tttftri
CD    write (*,'(A,F10.5)') "TIME FOR PREPARATION       ",tt0
CD    write (*,'(A,F10.5)') "TIME FOR   INTEGRAL        ",tti
CD    write (*,'(A,F10.5)') "TIME FOR   PREP QDER       ",ttq
CD    write (*,'(A,F10.5)') "TIME FOR   PREP NR         ",ttnr
CD    write (*,'(A,F10.5)') "TIME FOR CP-DFTB ITERATION ",tt1
CD    write (*,'(A,F10.5)') "TIME FOR   QDER            ",ttqder
CD    write (*,'(A,F10.5)') "TIME FOR   TFTRI0          ",ttittftri
CD    write (*,'(A,F10.5)') "TIME FOR   BROYDEN         ",ttbr
CD    write (*,'(A,F10.5)') "TIME FOR   U FORMATION     ",ttu
CD    write (*,'(A,F10.5)') "TIME FOR d(OMEGA)/dR       ",tt2
CD    write (*,'(A,F10.5)') "TIME FOR DFTB_QDER         ",tt3
CD    write (*,'(A,F10.5)') "TIME FOR DFTB_DEDB         ",tt4
CD    write (*,'(A,F10.5)') "TIME FOR   PRE  DEDB       ",ttpdedb
CD    write (*,'(A,F10.5)') "TIME FOR        DEDB       ",ttdedb
CD    write (*,'(A,F10.5)') "TIME FOR DFTB_TEST         ",tt5
CD    write (*,'(A,F10.5)') "TIME FOR FON ITERATION     ",tfon
CD    write (*,*)
      END IF
C
C     ----- RELEASE ALLOCATED MEMORY -----
C
1000  CALL RETFM(NEED)
C
      IF (PARALL3.OR.ISGDDI) THEN
        GOPARR = .TRUE.
        CALL DDI_GSUMF(1,HESSIAN,9*NAT*NAT)
        CALL DDI_GSUMF(1,DIPDER,9*NAT)
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_CP
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_UUPDATE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Update U matrix, by calculating response terms
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param UINIT Initial U matrix (only with non-response terms)
C>    @param SDSHIJ Response contribution in MO basis
C>    @param EIG Eigenvalue of each MO
C>    @param OCC Occupation number of each MO
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>           --- OUTPUT ---
C>    @param U U matrix (derivatives of MO coefficient)
C>
C
      SUBROUTINE DFTB_HESS_UUPDATE(U,UINIT,SDSHIJ,EIG,OCC,L1,L2,NDOCC,
     *  NPART)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2
      DOUBLE PRECISION, INTENT(INOUT) :: U(L1,L1)
      DOUBLE PRECISION, INTENT(IN) :: UINIT(L1,L1),SDSHIJ(L2),EIG(L1),
     *  OCC(L1)
      INTEGER, INTENT(IN) :: NDOCC,NPART
C
      DOUBLE PRECISION :: EI,EJ,OCCI,OCCJ,VAL
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00
      INTEGER :: NN,IO,JO,NSEQ
C
      DO IO = 1, NDOCC+NPART
        EI = EIG(IO)
        OCCI = OCC(IO)
        IF (IO.LE.NDOCC) THEN
          NN = NDOCC+1
        ELSE
          NN = 1
        END IF
        DO JO = NN, L1
          EJ = EIG(JO)
          OCCJ = OCC(JO)
          IF (IO.EQ.JO) THEN
            U(JO,IO) = UINIT(JO,IO)
          ELSE
            CALL DFTB_CNVSQ(IO,JO,NSEQ)
            IF (ABS(EI-EJ).LE.1.0D-06) THEN
              IF (OCCI.EQ.OCCJ) THEN
                VAL = ZERO
              ELSE
                !! THIS IS ONLY FOR (NEAR-)DEGENERATED P.O-P.O PAIRS
                VAL = SDSHIJ(NSEQ)*(OCCI-OCCJ)/((EI-EJ)*OCCI)
                IF (JO.LT.IO) VAL = ZERO
              END IF
            ELSE
              CALL DFTB_CNVSQ(IO,JO,NSEQ)
              VAL = SDSHIJ(NSEQ)/(EI-EJ)
            END IF
            U(JO,IO) = UINIT(JO,IO) + VAL
          END IF
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_UUPDATE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_QDER_NCC
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate derivatives of Mulliken charges at NCC-DFTB
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param U U matrix (derivatives of MO coefficients)
C>    @param OCC Occupation number of each MO
C>    @param DNDR Derivatives of occupation numbers
C>    @param S Overlap matrix
C>    @param SSQ Working array for square overlap matrix
C>    @param RESP Response matrix
C>    @param VEC MO coefficients
C>    @param WRK Working array
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT Number of virtual orbitals
C>    @param IND AO index of each atom
C>    @param FON Whether fractional occupation or not
C>           --- OUTPUT ---
C>    @param QDER Derivatives of Mulliken population
C>
C
      SUBROUTINE DFTB_CALC_QDER_NCC(QDER,U,OCC,DNDR,S,SSQ,RESP,VEC,WRK,
     *  NAT,L1,L2,NDOCC,NPART,NVIRT,IND,FON)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,L2,NDOCC,NPART,NVIRT,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: U(L1,L1),OCC(L1),DNDR(L1),S(L2),
     *  VEC(L1,L1)
      DOUBLE PRECISION, INTENT(INOUT) :: QDER(NAT)
      DOUBLE PRECISION, INTENT(OUT) :: SSQ(L1,L1),RESP(L1,L1),
     *  WRK(L1,L1)
      LOGICAL, INTENT(IN) :: FON
C
      INTEGER :: NN,I,J,IO,II
      DOUBLE PRECISION :: TMP,VAL,VAL2,DDOT,XDOT
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00,
     *  TWO=2.0D+00
C
      CALL CPYTSQ(S,SSQ,L1,1)
      CALL MRARBR(SSQ,L1,L1,L1,VEC,L1,L1,WRK,L1)
      DO NN = 1, NAT
        II = IND(NN+1)-IND(NN)
        CALL MRTRBR(VEC(IND(NN)+1,1),L1,II,L1,WRK(IND(NN)+1,1),L1,L1,
     *    RESP,L1)
        DO I = 1, L1
          DO J = I, L1
            TMP = RESP(J,I) + RESP(I,J)
            RESP(J,I) = TMP
            RESP(I,J) = TMP
          END DO
        END DO
C
        VAL = ZERO
        DO IO = 1, NDOCC
          VAL = VAL + DDOT(NPART+NVIRT,U(NDOCC+1,IO),1,
     *          RESP(NDOCC+1,IO),1)
        END DO
        QDER(NN) = QDER(NN) + VAL*TWO
C
        IF (FON) THEN
          VAL = ZERO
          VAL2 = ZERO
          DO IO = NDOCC+1, NDOCC+NPART
            VAL = VAL
     *       + OCC(IO)*DDOT(L1,U(1,IO),1,RESP(1,IO),1)
            VAL2 = VAL2 + DNDR(IO)*RESP(IO,IO)
          END DO
          QDER(NN) = QDER(NN) + VAL + VAL2*HALF*HALF !! WHY HALF TWICE?
        END IF
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_CALC_QDER_NCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DPART
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate partial density matrix.  The index of "i" runs
C>             over only doubly occupied orbitals.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param OCC Occupation number of each MO
C>    @param VEC MO coefficients
C>           --- OUTPUT ---
C>    @param D Partial density matrix
C>
C
      SUBROUTINE DFTB_DPART(L1,L2,NDOCC,OCC,D,VEC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L1,L2,NDOCC
      DOUBLE PRECISION ,INTENT(IN) :: OCC(L1),VEC(L1,L1)
      DOUBLE PRECISION, INTENT(OUT) :: D(L2)
C
      INTEGER :: I,IJ,K
C
      CALL VCLR(D,1,L2)
C
      DO K = 1, NDOCC
        IJ = 1
        DO I = 1, L1
          CALL DAXPY(I,OCC(K)*VEC(I,K),VEC(1,K),1,D(IJ),1)
          IJ = IJ + I
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_DPART
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_CALC_DNDR
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate derivatives of occupation numbers.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param IMODE See below
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param ETEMP Electronic temperature
C>    @param OCC Occupatio number of each MO
C>    @param EIG Eigenvalues of each MO
C>    @param HDER H_{ij}^b + V_{ij}^b
C>    @param SDER S_{ij}^b
C>    @param SOMGD Either non-response or response contribution of
C>           the derivative of shift contribution
C>    @param VEC MO coefficients
C>           --- OUTPUT ---
C>    @parma DEDB_INIT Non-response contributions of de/db (derivatives
C>           of eigenvalue)
C>    @param DEDB Derivatives of eigenvalue
C>    @param DNDR Derivatiees of occupation number
C>    @param FEDER Derivative of fermi-level
C>
C
      SUBROUTINE DFTB_CALC_DNDR(IMODE,L1,L2,NDOCC,NPART,ETEMP,
     *  DEDB_INIT,DEDB,DNDR,OCC,EIG,HDER,SDER,SOMGD,FEDER,SCC)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: IMODE,L1,L2,NDOCC,NPART
      DOUBLE PRECISION, INTENT(IN) :: ETEMP,OCC(L1),EIG(L1),HDER(L2),
     *  SDER(L2),SOMGD(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: DEDB_INIT(L1),DEDB(L1),
     *  DNDR(L1),FEDER
      LOGICAL, INTENT(IN) :: SCC
C
      INTEGER :: NSEQ,IO
      DOUBLE PRECISION :: EI,OCCI,TMP,BETA
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00,
     *  ONE=1.0D+00,TWO=2.0D+00,BOLTZ=3.1668114D-06
C
C     IMODE = 0
C     USED FOR FON CALCULATION.  JUST ADD NON-RESPONSE CONTRIBUTIONS TO
C     DEDB_INIT MATRIX.
C
C     IMODE = 1
C     USED FOR FON CALCULATION, AND ADD RESPONSE CONTRIBUTIONS
C
      NSEQ = 0
      IF (IMODE.EQ.0) THEN
C       WRITE (*,*) "DEDB_INIT"
        DO IO = 1, L1
          NSEQ = NSEQ + IO
          EI = EIG(IO)
C         WRITE (*,'(I3,2(X,F20.10))') NSEQ,HDER(NSEQ),SDER(NSEQ)
C         WRITE (*,'(3X,2(X,F20.10))') EI,SOMGD(NSEQ)
          IF (SCC) THEN
            TMP = HDER(NSEQ) - EI*SDER(NSEQ) + SOMGD(NSEQ)
          ELSE
            TMP = HDER(NSEQ) - EI*SDER(NSEQ)
          END IF
          DEDB_INIT(IO) = TMP
C         WRITE (*,'(I3,X,F20.10)') IO,DEDB_INIT(IO)
        END DO
        CALL VCLR(DNDR,1,L1)
        RETURN
      ELSE
        DO IO = 1, L1
          NSEQ = NSEQ + IO
          EI = EIG(IO)
          IF (SCC) THEN
            TMP = SOMGD(NSEQ)
          ELSE
            TMP = HDER(NSEQ) - EI*SDER(NSEQ)
          END IF
          DEDB(IO) = DEDB_INIT(IO) + TMP
        END DO
      END IF
C
C       ----- CALCULATE DERVIATIVE OF FERMI ENERGY FIRST -----
C
      CALL VCLR(DNDR,1,L1)
      FEDER = ZERO
      TMP = ZERO
      DO IO = NDOCC+1, NDOCC+NPART
        OCCI = OCC(IO)*HALF
        FEDER = FEDER + OCCI*(ONE-OCCI)*DEDB(IO)
        TMP = TMP + OCCI*(ONE-OCCI)
      END DO
      FEDER = FEDER/TMP
      BETA = ONE/(BOLTZ*ETEMP)
C
C       ----- THEN CALCULATE DERIVATIVE OF OCCUPATION NUMBESR -----
C
      DO IO = NDOCC+1, NDOCC+NPART
        OCCI = OCC(IO)*HALF
        DNDR(IO) = -OCCI*(ONE-OCCI)*(DEDB(IO)-FEDER) !! *BETA
C       DNDR(IO) = DNDR(IO)*TWO
      END DO
      CALL DSCAL(NPART,TWO*BETA,DNDR(NDOCC+1),1)
C
      END SUBROUTINE DFTB_CALC_DNDR
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate non-response contributions to the derivatives
C>             of Mulliken population
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L0 NQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IND Index of AO
C>    @param D1 Normal density matrix
C>    @param D2 Partial density matrix (for FON)
C>    @param S Overlap matrix
C>    @param SDER Matrix of overlap matrix in AO basis
C>    @param UHF Whether U-DFTB or not
C>           --- OUTPUT ---
C>    @param QDER_INIT Non-response contribution to Mulliken derivative
C>    @param WRK,WRK1,W,TMP Working array
C>
C
      SUBROUTINE DFTB_PREP_QDER(NAT,L0,L1,L2,IND,QDER_INIT,
     *  D1,D2,S,SDER,WRK,WRK1,W,TMP,UHF)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      INTEGER :: IND(*)
      DOUBLE PRECISION :: QDER_INIT(NAT),D1(L2),D2(L2),S(L2),SDER(L2),
     *  WRK(L1,L1),WRK1(L1,L1),W(L2),TMP(L1)
      LOGICAL :: UHF
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00
C
C     D1 :: NORMAL DENSITY MATRIX
C     D2 :: PARTIAL DENSITY MATRIX (IF FON)
C
      CALL VCLR(QDER_INIT,1,NAT)
      !! CALCULATE LAGRANGIAN-LIKE TERM
      CALL CPYTSQ(D2,WRK1,L1,1)
      CALL TFTRI0(W,SDER,WRK1,WRK,L0,L1,L1)
      IF (.NOT.UHF) CALL DSCAL(L2,HALF,W,1)
C
C     CALCULATE S*W (BOTH MATRICES ARE SYMMETRIC)
C
C     CALL DFTB_MULLIKEN(L1,L2,S,W,TMP2)
      CALL DFTB_MULLIKEN(L1,L2,S,W,TMP)
C
C     CALCULATE D*(dS/dR), BY DESTROYING W, WHICH IS NO LONGER NEEDED.
C     ONLY DIAGONAL ELEMENT IS NEEDED, AND USE THE NATURE OF
C     SYMMETRY OF D AND dS/dR.
C
C     CALL DFTB_MULLIKEN(L1,L2,D1,SDER,TMP1)
      CALL DFTB_MULLIKEN(L1,L2,D1,SDER,W)
      CALL VSUB(TMP,1,W,1,TMP,1,L1)
C
      DO NC = 1, NAT
        VAL = ZERO
        DO L = 1, IND(NC+1) - IND(NC)
          MU = IND(NC)+L
C         VAL = VAL + TMP1(MU) - TMP2(MU)
          VAL = VAL + TMP(MU)
        END DO
        QDER_INIT(NC) = QDER_INIT(NC) + VAL
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_QDER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER_REDUCE
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate non-response contributions to the derivatives
C>             of Mulliken population.  This is used in reduced-memory
C>             run.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param IND Index of AO
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param U U matrix (derivative of MO coefficients)
C>    @param OCC Occupation number of each MO
C>    @param QDER_INIT Non-response contribution to Mulliken derivative
C>    @param RESP Response terms
C>    @param DNDR Derivative of occupation numbers
C>    @param VEC MO coefficients
C>    @param FON Whether fractional occupation or not
C>    @param SRSCC Whether Shell-resolved SCC or not
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param NSHELL Number of shells
C>           --- OUTPUT ---
C>    @param QDER Derivative of Mulliken charges
C>
C
      SUBROUTINE DFTB_CALC_QDER_REDUCE(NAT,L1,IND,NDOCC,NPART,
     *  QDER,U,OCC,QDER_INIT,RESP,DNDR,VEC,FON,SRSCC,
     *  NSPE,ISPE,MAXANG,NSHELL)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,IND(*),NDOCC,NPART,
     *  NSPE,ISPE(NAT),MAXANG(NSPE),NSHELL
      DOUBLE PRECISION, INTENT(IN)  :: U(L1,L1),OCC(L1),
     *  QDER_INIT(NAT),RESP(L1,L1),VEC(L1,L1),DNDR(L1)
      DOUBLE PRECISION, INTENT(OUT) :: QDER(NAT)
      LOGICAL, INTENT(IN) :: FON,SRSCC
C
      INTEGER :: ISH0,ISH,I,IO,MO,MM,NN,MU
      DOUBLE PRECISION :: VAL,TMP,TMP2,OCCI
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00
C
C     WHEN OCCUPATION NUMBERS ARE FRACTIONAL, ORBITAL SPACE IS DIVIDED
C     INTO THREE, DOUBLE OCCUPIED (NDOCC), PARTIAL OCCUPIED (NPART), AND
C     VIRTUAL ORBITALS (NVIRT).  ONLY DOUBLY-DOUBLY OCCUPIED COUPLINGS
C     CAN BE WRITTEN WITH S_{IJ} MATRIX.
C
      IF (SRSCC) THEN
        CALL DCOPY(NSHELL,QDER_INIT,1,QDER,1)
        ISH0 = 0
        DO NN = 1, NAT
          DO I = 1, MAXANG(ISPE(NN))
            ISH = ISH0 + I
            VAL = ZERO
            DO MM = 1, IND(ISH+1)-IND(ISH)
              MU = IND(ISH)+MM
              DO IO = 1, NDOCC
                OCCI = OCC(IO)
                TMP = ZERO
                TMP2 = ZERO
                DO MO = NDOCC+1, L1
                  TMP = TMP + U(MO,IO)*RESP(MU,MO)
                  TMP2 = TMP2 + U(MO,IO)*VEC(MU,MO)
                END DO
                TMP = TMP*VEC(MU,IO)
                TMP2 = TMP2*RESP(MU,IO)
                VAL = VAL + (TMP+TMP2)*OCCI
              END DO
            END DO
            QDER(ISH) = QDER(ISH) + VAL
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NN))
        END DO
      ELSE
        CALL DCOPY(NAT,QDER_INIT,1,QDER,1)
        DO NN = 1, NAT
          VAL = ZERO
          DO MM = 1, IND(NN+1)-IND(NN)
            MU = IND(NN)+MM
            DO IO = 1, NDOCC
              OCCI = OCC(IO)
              TMP = ZERO
              TMP2 = ZERO
              DO MO = NDOCC+1, L1
                TMP = TMP + U(MO,IO)*RESP(MU,MO)
                TMP2 = TMP2 + U(MO,IO)*VEC(MU,MO)
              END DO
              TMP = TMP*VEC(MU,IO)
              TMP2 = TMP2*RESP(MU,IO)
              VAL = VAL + (TMP+TMP2)*OCCI
            END DO
          END DO
          QDER(NN) = QDER(NN) + VAL
        END DO
      END IF
C
      IF (FON) THEN
        DO NN = 1, NAT
          VAL = ZERO
C         DO IO = NDOCC+1, NDOCC+NPART
C           OCCI = OCC(IO)
C           VAL = VAL
C    *       + OCC(IO)*DDOT(L1,U(1,IO),1,RESP(1,IO),1)
C           !! RESP OF DIAGONAL PART IS MULTIPLIED BY TWO SO RE-SCALE IT
C           VAL = VAL + DNDR(IO)*RESP(IO,IO)!!*HALF
C         END DO
          DO MM = 1, IND(NN+1)-IND(NN)
            MU = IND(NN)+MM
            DO IO = NDOCC+1, NDOCC+NPART
              OCCI = OCC(IO)
              TMP = ZERO
              TMP2 = ZERO
              DO MO = 1, L1
                TMP = TMP + U(MO,IO)*RESP(MU,MO)
                TMP2 = TMP2 + U(MO,IO)*VEC(MU,MO)
              END DO
              TMP = TMP*VEC(MU,IO)
              TMP2 = TMP2*RESP(MU,IO)
              VAL = VAL + (TMP+TMP2)*OCCI
              VAL = VAL + DNDR(IO)*RESP(MU,IO)*VEC(MU,IO)
            END DO
          END DO
          QDER(NN) = QDER(NN) + VAL
        END DO
      END IF
C
      END SUBROUTINE DFTB_CALC_QDER_REDUCE
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate non-response contributions to the derivatives
C>             of Mulliken population.  This is used in reduced-memory
C>             run.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L1 Number of basis functions
C>    @param IND Index of AO
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT NUmber of virtual orbitals
C>    @param U U matrix (derivative of MO coefficients)
C>    @param OCC Occupation number of each MO
C>    @param QDER_INIT Non-response contribution to Mulliken derivative
C>    @param RESP Response terms
C>    @param DNDR Derivative of occupation numbers
C>    @param FON Whether fractional occupation or not
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param SRSCC Whether Shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param ISPIN Index of spin
C>           --- OUTPUT ---
C>    @param QDER Derivative of Mulliken charges
C>
C
      SUBROUTINE DFTB_CALC_QDER(NAT,L1,NDOCC,NPART,NVIRT,QDER,U,
     *  OCC,QDER_INIT,RESP,DNDR,FON,NSPIN,SRSCC,UHF,NDIMSH,NSPE,ISPE,
     *  MAXANG,ISPIN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,L1,NDOCC,NPART,NVIRT,NSPIN,NDIMSH,
     *  NSPE,ISPE(NAT),MAXANG(NSPE),ISPIN
      DOUBLE PRECISION, INTENT(IN) :: U(L1,L1),OCC(L1),
     *  QDER_INIT(NDIMSH),RESP(L1,L1,NDIMSH,NSPIN),DNDR(L1)
      DOUBLE PRECISION, INTENT(OUT) :: QDER(NDIMSH)
      LOGICAL, INTENT(IN) :: FON,SRSCC,UHF
C
      INTEGER :: NSHELL,ISH,ISH0,I,IO,NN
      DOUBLE PRECISION :: VAL,VAL2,DDOT,XDOT
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,HALF=0.5D+00
C
C     WHEN OCCUPATION NUMBERS ARE FRACTIONAL, ORBITAL SPACE IS DIVIDED
C     INTO THREE, DOUBLE OCCUPIED (NDOCC), PARTIAL OCCUPIED (NPART), AND
C     VIRTUAL ORBITALS (NVIRT).  ONLY DOUBLY-DOUBLY OCCUPIED COUPLINGS
C     CAN BE WRITTEN WITH S_{IJ} MATRIX.
C
      NSHELL = NDIMSH
C     write (*,*) "srscc = ", srscc
C     write (*,*) "uhf = ", uhf
      IF (SRSCC.OR.UHF) THEN
        CALL DCOPY(NSHELL,QDER_INIT,1,QDER,1)
        ISH0 = 0
        DO NN = 1, NAT
          DO I = 1, MAXANG(ISPE(NN))
            ISH = ISH0 + I
            VAL = ZERO
            DO IO = 1, NDOCC
              VAL = VAL + DDOT(NPART+NVIRT,U(NDOCC+1,IO),1,
     *              RESP(NDOCC+1,IO,ISH,ISPIN),1)
            END DO
            QDER(ISH) = QDER(ISH) + VAL*OCC(1)
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NN))
        END DO
      ELSE
        CALL DCOPY(NAT,QDER_INIT,1,QDER,1)
        DO NN = 1, NAT
          VAL = ZERO
          DO IO = 1, NDOCC
            VAL = VAL + DDOT(NPART+NVIRT,U(NDOCC+1,IO),1,
     *            RESP(NDOCC+1,IO,NN,ISPIN),1)
          END DO
          QDER(NN) = QDER(NN) + VAL*OCC(1) !! TWO IS OCCUPATION NUMBER
        END DO
      END IF
C
      IF (FON) THEN
        DO NN = 1, NAT
          VAL = ZERO
          VAL2 = ZERO
          DO IO = NDOCC+1, NDOCC+NPART
            VAL = VAL
     *       + OCC(IO)*DDOT(L1,U(1,IO),1,RESP(1,IO,NN,ISPIN),1)
            !! RESP OF DIAGONAL PART IS MULTIPLIED BY TWO SO RE-SCALE IT
            VAL2 = VAL2 + DNDR(IO)*RESP(IO,IO,NN,ISPIN)
          END DO
          QDER(NN) = QDER(NN) + VAL + VAL2*HALF
        END DO
      END IF
C
      END SUBROUTINE DFTB_CALC_QDER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Prepare the calculation of second-order derivative of
C>             gamma values, making TMP matrix
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param HUBA,HUBB Hubbard values of atom A and B
C>    @param DFTB3 Whether DFTB3 or not
C>    @param DAMPXH Whether DAMPXH is true or not
C>           --- OUTPUT ---
C>    @param TMP Constants
C>
C
      SUBROUTINE DFTB_PREP_GAMMA_HESS(HUBA,HUBB,TMP,DFTB3,DAMPXH)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, INTENT(IN) :: HUBA,HUBB
      LOGICAL, INTENT(IN) :: DFTB3,DAMPXH
      DOUBLE PRECISION, INTENT(OUT) :: TMP(11)
C
      DOUBLE PRECISION :: TAUA,TAUA2,TAUA3,TAUA4,TAUA6,TAUB,TAUB2,
     *  TAUB3,TAUB4,TAUB6,TAUAB,TAUABI,TAUABI2,TAUABI3,TAUABI4
      DOUBLE PRECISION,PARAMETER :: HUBTOL=1.0D-04,
     *  HALF=0.5D+00,ONE=1.0D+00,TWO=2.0D+00,THREE=3.0D+00,
     *  TWELVE=1.2D+01,ONE_15=ONE/1.5D+01,ONE_48=ONE/4.8D+01
C
      TAUA  = 3.2D+00*HUBA
      TAUA2 = TAUA**2
      TAUA3 = TAUA*TAUA2
      TAUA4 = TAUA2**2
      TAUA6 = TAUA2*TAUA4
      TAUB = 3.2D+00*HUBB
      TAUB2 = TAUB**2
      TAUB3 = TAUB*TAUB2
      TAUB4 = TAUB2**2
      TAUB6 = TAUB2*TAUB4
      IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
        TMP(1) = 6.875D-01*TAUA  !! 11/16 a
        TMP(2) = 1.875D-01*TAUA2 !! 3/16  a^2
        TMP(3) = ONE_48*TAUA3    !! 1/48  a^3
        TMP(4) = TWO*TMP(3)  !! 1/24  a^3
        TMP(5) = 3.125D-01*TAUA3 !! 5/16  a^3
        IF (DFTB3) THEN
          TMP(5) = -6.0D-01*TAUA
          TMP(6) = 2.0D-01*TAUA2
          TMP(7) = 2.0D-01*TAUA3
          TMP(8) = TAUA4*ONE_15
          IF (DAMPXH) THEN
            TMP(9)  = -TAUA
            TMP(10) = -4.0D-01*TAUA2
            TMP(11) = -TAUA3*ONE_15
          END IF
        END IF
      ELSE
        TAUAB = TAUA2 - TAUB2
        TAUABI = ONE/TAUAB
        TAUABI2 = TAUABI**2
        TAUABI3 = TAUABI**3
        TMP(1) =  (TAUB6-THREE*TAUA2*TAUB4)*TAUABI3
        TMP(2) = HALF*TAUA*TAUB4*TAUABI2
        TMP(3) = -(TAUA6-THREE*TAUB2*TAUA4)*TAUABI3
        TMP(4) = HALF*TAUB*TAUA4*TAUABI2
        IF (DFTB3) THEN
          TAUABI4 = TAUABI**4
          TMP(5) = -HALF*(TAUB6+THREE*TAUA2*TAUB4)*TAUABI3
          TMP(6) = -TWELVE*TAUA3*TAUB4*TAUABI4
          TMP(7) = -TWO*TAUB3*TAUA3*TAUABI3
          TMP(8) =  TWELVE*TAUB4*TAUA3*TAUABI4
        END IF
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_PREP_GAMMA_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Actual function which calculates the second-order
C>             derivative of gamma values
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param HUBA,HUBB Hubbard values of atom A and B
C>    @param HUBDER Hubbard derivatives
C>    @param DIST Inter-atomic distance between atom A and B
C>    @param DAMPXHE Exponent of X-H damping function
C>    @param TMP Constants produced in DFTB_PREP_GAMMA_HESS subroutine
C>    @param DFTB3 Whether DFTB3 or not
C>    @param HDAMP Whether the pair contains H or not
C>           --- OUTPUT ---
C>    @param GRAD2 1st-order derivative of DFTB2 gamma
C>    @param HESS2 2nd-order derivative of DFTB2 gamma
C>    @param GRAD3 1st-order derivative of DFTB3 gamma
C>    @param HESS3 2nd-order derivative of DFTB3 gamma
C>
C
      SUBROUTINE DFTB_GAMHESSF(GRAD2,HESS2,GRAD3,HESS3,HUBA,HUBB,HUBDER,
     *  DIST,DAMPXHE,TMP,DFTB3,HDAMP)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION, INTENT(IN) :: HUBA,HUBB,HUBDER,DIST,DAMPXHE,
     *  TMP(11)
      DOUBLE PRECISION, INTENT(OUT) :: GRAD2,HESS2,GRAD3,HESS3
      LOGICAL, INTENT(IN) :: DFTB3,HDAMP
C
      DOUBLE PRECISION :: TAUA,TAUA2,TAUB,TAUB2,DIST2,DIST3,DISTI,
     *  DISTI2,DISTI3,EXPA,GAMTMP,GAMTMP2,GAMTMP3,GA,DGA_DR,D2GA_DR,S,
     *  DS_DR,D2S_DR,D2S_DR2,HUBMEAN,HUBMEANEXP,EXPH,DH_DR,D2H_DR2,
     *  DGA_DA,D2GA_DADR,D2GA_DR2,D3GA_DADR2,D2S_DUDR,D3S_DUDR2,
     *  HUBMEANEXP1,DS_DU,DH_DU,D2H_DUDR,D3H_DUDR2,EXPB,FAB,FBA,
     *  DFAB_DR,DFBA_DR,D2FAB_DR,D2FBA_DR,DFAB_DA,DFBA_DA,D2FAB_DR2,
     *  D2FAB_DADR,D2FBA_DADR,D3FAB_DADR2,D3FBA_DADR2
      DOUBLE PRECISION, PARAMETER :: DISTTOL=1.0D-08,HUBTOL=1.0D-04,
     *  ZERO=0.0D+00,ONE=1.0D+00,TWO=2.0D+00,HALF=0.5D+00
C
      IF (DIST.LT.DISTTOL) THEN
        GRAD2 = ZERO
        HESS2 = ZERO
        GRAD3 = ZERO
        HESS3 = ZERO
      ELSE
        TAUA = 3.2D+00*HUBA
        TAUA2 = TAUA**2
        TAUB = 3.2D+00*HUBB
        TAUB2 = TAUB**2
        DISTI = ONE/DIST
        DIST2 = DIST**2
        DISTI2 = DISTI**2
        DISTI3 = DISTI**3
        EXPA = EXP(-TAUA*DIST)
        GAMTMP2 = ZERO
        GAMTMP3 = ZERO
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          GA = DISTI+TMP(1)+TMP(2)*DIST+TMP(3)*DIST2
          DGA_DR = -DISTI2+TMP(2)+TMP(4)*DIST
          D2GA_DR = TWO*DISTI3+TMP(4)
          S = EXPA*GA
          DS_DR = EXPA*(DGA_DR-TAUA*GA)
          D2S_DR = EXPA*(D2GA_DR-TWO*TAUA*DGA_DR+TAUA2*GA)
          GAMTMP = -DS_DR
          D2S_DR2 = D2S_DR
          IF (HDAMP) THEN
            HUBMEAN = HUBA
            HUBMEANEXP = HUBMEAN**DAMPXHE
            EXPH = EXP(-HUBMEANEXP*DIST2)
            DH_DR = -TWO*DIST*HUBMEANEXP*EXPH
            D2H_DR2 = -TWO*HUBMEANEXP
     `        *(ONE-TWO*DIST2*HUBMEANEXP)*EXPH
            GAMTMP = GAMTMP*EXPH !! -h*dSg/dR
            GAMTMP2 = -DH_DR*S
            !! D2S_DR = d2S/dR2 + 2*(dS/dR)*(dh/dR)
            D2S_DR = D2S_DR*EXPH+TWO*DS_DR*DH_DR+S*D2H_DR2
          END IF
          GRAD2 = -DISTI2+GAMTMP+GAMTMP2
          HESS2 = TWO*DISTI3-D2S_DR
C         write (*,*) disti2,gamtmp,gamtmp2
C         write (*,*) disti3,d2s_dr
          IF (DFTB3) THEN
            DIST3 = DIST2*DIST
            DGA_DA =
     *        6.875D-01+3.75D-01*TAUA*DIST+6.25D-02*TAUA2*DIST2
            D2GA_DADR = 3.75D-01*TAUA+1.25D-01*TAUA2*DIST
            D2GA_DR2 = TWO*DISTI3+TMP(4)
            D3GA_DADR2 = 1.25D-01*TAUA2
            GAMTMP = (TAUA*DIST-ONE)*GA-TAUA*DGA_DA+D2GA_DADR
     *        - DIST*DGA_DR
            D2S_DUDR = GAMTMP*EXPA*3.2D+00
            GAMTMP = -D2S_DUDR
            GAMTMP3 = -TAUA*(TAUA*DIST-TWO)*GA
     *        +TWO*(TAUA*DIST-ONE)*DGA_DR+TAUA2*DGA_DA
     *        -TWO*TAUA*D2GA_DADR+D3GA_DADR2-DIST*D2GA_DR2
            D3S_DUDR2 = GAMTMP3*EXPA*3.2D+00
            GAMTMP3 = -D3S_DUDR2
            IF (HDAMP) THEN !! damp correction with 3rd
              HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
              DS_DU = EXPA*(-ONE+TMP(9)*DIST
     *          + TMP(10)*DIST2+TMP(11)*DIST3)
              DH_DU = -HALF*DIST2*DAMPXHE*HUBMEANEXP1*EXPH
              D2H_DUDR = DAMPXHE*DIST*HUBMEANEXP1
     *                   *(DIST2*HUBMEANEXP-ONE)*EXPH
              D3H_DUDR2 = DAMPXHE*HUBMEANEXP1*EXPH
     *          *(DIST2*HUBMEANEXP
     *             *(5.0D+00-TWO*DIST2*HUBMEANEXP)-ONE)
C             WRITE (*,*) GAMTMP*EXPH,-DS_DU*DH_DR,-DS_DR*DH_DU
C             WRITE (*,*) -S*D2H_DUDR
              GAMTMP = -D2S_DUDR*EXPH-DS_DU*DH_DR-DS_DR*DH_DU
     *          -S*D2H_DUDR
C             D2S_DR2 = D2S_DR
              GAMTMP3 = -D3S_DUDR2*EXPH-TWO*D2S_DUDR*DH_DR
     *          -TWO*DS_DR*D2H_DUDR-DS_DU*D2H_DR2-D2S_DR2*DH_DU
     *          -S*D3H_DUDR2
            END IF
C           GAMTMP = 3.2D+00*GAMTMP !! /3.0D+00
C           GAMTMP3 = 3.2D+00*GAMTMP3 !! /3.0D+00
            GRAD3 = GAMTMP*HUBDER
            HESS3 = GAMTMP3*HUBDER
C           WRITE (*,*) "i,j = ",i ,j
C           write (*,*) gamtmp*HUBDER(NSP1),GAMTMP3*HUBDER(NSP1)
          END IF
        ELSE
          EXPB = EXP(-TAUB*DIST)
          FAB = TMP(2)-TMP(1)*DISTI
          FBA = TMP(4)-TMP(3)*DISTI
          DFAB_DR = TMP(1)*DISTI2
          DFBA_DR = TMP(3)*DISTI2
          D2FAB_DR = -DFAB_DR*TWO*DISTI
          D2FBA_DR = -DFBA_DR*TWO*DISTI
          S = EXPA*FAB+EXPB*FBA
          DS_DR = EXPA*(DFAB_DR-TAUA*FAB)+EXPB*(DFBA_DR-TAUB*FBA)
          GAMTMP = -DS_DR
          D2S_DR = EXPA*(D2FAB_DR-TWO*TAUA*DFAB_DR+TAUA2*FAB)
     *           + EXPB*(D2FBA_DR-TWO*TAUB*DFBA_DR+TAUB2*FBA)
          D2S_DR2 = D2S_DR
          IF (HDAMP) THEN
            HUBMEAN = HALF*(HUBA+HUBB)
            HUBMEANEXP = HUBMEAN**DAMPXHE
            EXPH = EXP(-HUBMEANEXP*DIST2)
            DH_DR = -TWO*DIST*HUBMEANEXP*EXPH
            D2H_DR2 = -TWO*HUBMEANEXP
     `        *(ONE-TWO*DIST2*HUBMEANEXP)*EXPH
            GAMTMP = GAMTMP*EXPH !! -h*dSg/dR
            GAMTMP2 = -S*DH_DR
            !! D2S_DR = d2S/dR2 + 2*(dS/dR)*(dh/dR)
            D2S_DR = D2S_DR*EXPH+TWO*DS_DR*DH_DR+S*D2H_DR2
          END IF
          GRAD2 = -DISTI2+GAMTMP+GAMTMP2
C         write (*,*) disti2,gamtmp,gamtmp2
          HESS2 = TWO*DISTI3-D2S_DR
C         write (*,*) disti3,d2s_dr
          IF (DFTB3) THEN
            DFAB_DA = TMP(5) + TMP(6)*DISTI
            DFBA_DA = TMP(7) + TMP(8)*DISTI
            D2FAB_DR2 = -DFAB_DR*TWO*DISTI
            D2FAB_DADR = -TMP(6)*DISTI2
            D2FBA_DADR = -D2FAB_DADR
            D3FAB_DADR2 = -D2FAB_DADR*TWO*DISTI
            D3FBA_DADR2 = -D2FBA_DADR*TWO*DISTI
            GAMTMP = EXPA*((TAUA*DIST-ONE)*FAB-TAUA*DFAB_DA
     *        + D2FAB_DADR - DIST*DFAB_DR)
     *        + EXPB*(D2FBA_DADR - TAUB*DFBA_DA)
            D2S_DUDR = GAMTMP*3.2D+00
            GAMTMP = -D2S_DUDR
            GAMTMP3 = EXPA*(-TAUA*(TAUA*DIST-TWO)*FAB
     *        +TWO*(TAUA*DIST-ONE)*DFAB_DR+TAUA2*DFAB_DA
     *        -TWO*TAUA*D2FAB_DADR+D3FAB_DADR2
     *        -DIST*D2FAB_DR2)
     *        +EXPB*(TAUB2*DFBA_DA-TWO*TAUB*D2FBA_DADR
     *        +D3FBA_DADR2)
            D3S_DUDR2 = GAMTMP3*3.2D+00
            GAMTMP3 = -D3S_DUDR2
C           WRITE (*,*) D2S_DUDR
C           WRITE (*,*) "D3S_DUDR2 = ", D3S_DUDR2
            IF (HDAMP) THEN  !! damp correction with 3rd
              HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
              DS_DU = EXPA*(DFAB_DA-DIST*FAB)+EXPB*DFBA_DA
              DS_DU = DS_DU*3.2D+00
              DH_DR = -TWO*DIST*HUBMEANEXP*EXPH
              DH_DU = -HALF*DIST2*DAMPXHE*HUBMEANEXP1*EXPH
              D2H_DUDR = DAMPXHE*DIST*HUBMEANEXP1
     *                   *(DIST2*HUBMEANEXP-ONE)*EXPH
C             WRITE (*,*) D2H_DUDR
              D3H_DUDR2 = DAMPXHE*HUBMEANEXP1*EXPH
     *          *(DIST2*HUBMEANEXP
     *             *(5.0D+00-TWO*DIST2*HUBMEANEXP)-ONE)
C             WRITE (*,*) "D3H_DUDR2 = ", D3H_DUDR2
C             WRITE (*,*) GAMTMP*EXPH,-DS_DU*DH_DR*3.2D+00,
C    *        -DS_DR*DH_DU
C             WRITE (*,*) -S*D2H_DUDR
              GAMTMP = -D2S_DUDR*EXPH-DS_DU*DH_DR
     *          -DS_DR*DH_DU-S*D2H_DUDR
C             D2S_DR2 = D2S_DR
              GAMTMP3 = -D3S_DUDR2*EXPH-TWO*D2S_DUDR*DH_DR
     *          -TWO*DS_DR*D2H_DUDR-DS_DU*D2H_DR2-D2S_DR2*DH_DU
     *          -S*D3H_DUDR2
            END IF
C           GAMTMP = 3.2D+00*GAMTMP !! /3.0D+00
C           GAMTMP3 = 3.2D+00*GAMTMP3 !! /3.0D+00
            GRAD3 = GAMTMP*HUBDER
            HESS3 = GAMTMP3*HUBDER
C           WRITE (*,*) "i,j = ",i ,j
C           write (*,*) gamtmp*HUBDER(NSP1),GAMTMP3*HUBDER(NSP1)
          END IF
        END IF
C       WRITE (*,'(I3,X,I3,X,F12.6,X,F12.6)')
C    *    1,1,GRAD2,HESS2
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_GAMHESSF
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_PREP_QDER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate second-order geometrical derivative of gamma
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param HUBBL Shell-resolved Hubbar values
C>    @param HUBDER Hubbard derivatives
C>    @param DAMPXHE Exponent of X-H damping function
C>    @param ISPE Index of species
C>    @parma MAXANG Maximum angular momentum of each species
C>    @param NAT Number of atoms
C>    @param Number of species
C>    @param Number of shells
C>    @param NN
C>    @param NDIMGAM Dimension of gamma
C>    @param SPE Name of species
C>    @param DFTB3 Whether DFTB3 or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param DAMPXH Whether H-X damping is used or not
C>           --- OUTPUT ---
C>    @param GRAD2 1st-order derivative of DFTB2 gamma
C>    @param HESS2 2nd-order derivative of DFTB2 gamma
C>    @param GRAD3 1st-order derivative of DFTB3 gamma
C>    @param HESS3 2nd-order derivative of DFTB3 gamma
C>
C
      SUBROUTINE DFTB_CALC_GAM_DER2(GRAD2,HESS2,GRAD3,HESS3,DISTMAT,
     *  HUBBL,HUBDER,DAMPXHE,ISPE,MAXANG,NAT,NSPE,NSHELL,NDIMGAM,SPE,
     *  DFTB3,SRSCC,DAMPXH)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NSPE,NSHELL,NDIMGAM
      DOUBLE PRECISION, INTENT(INOUT) :: GRAD2(*),HESS2(*),
     *  GRAD3(NDIMGAM,NDIMGAM),HESS3(NDIMGAM,NDIMGAM)
      DOUBLE PRECISION, INTENT(IN) :: DISTMAT(*),HUBBL(3,NSPE),DAMPXHE,
     *  HUBDER(*),SPE(*)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(NSPE)
      LOGICAL, INTENT(IN) :: DFTB3,SRSCC,DAMPXH
C
      INTEGER :: I,II,ISH,J,JJ,JSH,NSP1,NSP2,NSEQ,ISHELL(NSHELL),
     *  IND(NSPE),ISH0,JSH0
      DOUBLE PRECISION :: HUBA,HUBB,HUBDERTMP,DIST,CHARA1,CHARA2,
     *  TMP(11,NDIMGAM,NDIMGAM)
      LOGICAL :: HDAMP
      DOUBLE PRECISION H/8HH       /
C
      CALL VCLR(TMP,1,11*NDIMGAM*NDIMGAM)
      IF (SRSCC) THEN
        IND(1) = 0
        DO I = 2, NSPE
          IND(I) = IND(I-1) + MAXANG(ISPE(I-1))
        END DO
        ISH = 0
        JSH = 0
        DO I = 1, NAT
          JSH = IND(ISPE(I))
          DO J = 1, MAXANG(ISPE(I))
            ISH = ISH + 1
            ISHELL(ISH) = JSH + J
          END DO
        END DO
        ISH = 0
        DO I = 1, NSPE
          DO II = 1, MAXANG(I)
            ISH = ISH + 1
            HUBA = HUBBL(II,I)
            JSH = 0
            DO J = 1, NSPE
              DO JJ = 1, MAXANG(J)
                JSH = JSH + 1
                HUBB = HUBBL(JJ,J)
                CALL DFTB_PREP_GAMMA_HESS(HUBA,HUBB,TMP(1,ISH,JSH),
     *            DFTB3,DAMPXH)
              END DO
            END DO
          END DO
        END DO
C
        ISH0 = 0
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CHARA1 = SPE(ISPE(I))
          HUBDERTMP = HUBDER(NSP1)
          JSH0 = 0
          DO J = 1, NAT
            NSP2 = ISPE(J)
            CHARA2 = SPE(ISPE(J))
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            DO II = 1, MAXANG(ISPE(I))
              ISH = ISH0 + II
              HUBA = HUBBL(II,ISPE(I))
              NSP1 = ISHELL(ISH)
              DO JJ = 1, MAXANG(ISPE(J))
                JSH = JSH0 + JJ
                HUBB = HUBBL(JJ,ISPE(J))
                NSP2 = ISHELL(JSH)
C               WRITE (*,*) I, J
                CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
                CALL DFTB_GAMHESSF(GRAD2(NSEQ),HESS2(NSEQ),
     *            GRAD3(ISH,JSH),HESS3(ISH,JSH),HUBA,HUBB,HUBDERTMP,
     *            DIST,DAMPXHE,TMP(1,NSP1,NSP2),DFTB3,HDAMP)
C      write (*,'(6i3,f20.10)') i,j,ish,jsh,nsp1,nsp2,gamma(nseq)
C       WRITE (*,'(I3,X,I3,X,I3,F20.10,X,F20.10)')
C    *    ISH,JSH,NSEQ,GRAD2(NSEQ),HESS2(NSEQ)
              END DO
            END DO
            JSH0 = JSH0 + MAXANG(ISPE(J))
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(I))
        END DO
      ELSE
        DO I = 1, NSPE
          HUBA  = HUBBL(1,I)
          DO J = 1, NSPE
            HUBB = HUBBL(1,J)
C           WRITE (*,*) I,J
            CALL DFTB_PREP_GAMMA_HESS(HUBA,HUBB,TMP(1,I,J),DFTB3,DAMPXH)
C             write (*,'(x,f20.10)') tmp(1,i,j)
C             write (*,'(x,f20.10)') tmp(2,i,j)
C             write (*,'(x,f20.10)') tmp(3,i,j)
C             write (*,'(x,f20.10)') tmp(4,i,j)
C             write (*,'(x,f20.10)') tmp(5,i,j)
C             write (*,'(x,f20.10)') tmp(6,i,j)
C             write (*,'(x,f20.10)') tmp(7,i,j)
C             write (*,'(x,f20.10)') tmp(8,i,j)
C             write (*,'(x,f20.10)') tmp(9,i,j)
C             write (*,'(x,f20.10)') tmp(10,i,j)
C             write (*,'(x,f20.10)') tmp(11,i,j)
C             write (*,*)
          END DO
        END DO
C
        DO I = 1, NAT
          NSP1 = ISPE(I)
          HUBA = HUBBL(1,NSP1)
          CHARA1 = SPE(ISPE(I))
          HUBDERTMP = HUBDER(NSP1)
          DO J = 1, NAT !! I
C           WRITE (*,*) I,J
            NSP2 = ISPE(J)
            HUBB = HUBBL(1,NSP2)
            CHARA2 = SPE(ISPE(J))
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            IF (DAMPXH.AND.(CHARA1.EQ.H.OR.CHARA2.EQ.H)) THEN
              HDAMP = .TRUE.
            ELSE
              HDAMP = .FALSE.
            END IF
            CALL DFTB_GAMHESSF(GRAD2(NSEQ),HESS2(NSEQ),GRAD3(I,J),
     *        HESS3(I,J),HUBA,HUBB,HUBDERTMP,DIST,DAMPXHE,
     *        TMP(1,NSP1,NSP2),DFTB3,HDAMP)
C       WRITE (*,'(I3,X,I3,X,F12.6,X,F12.6)')
C    *    I,J,GRAD2(NSEQ),HESS2(NSEQ)
          END DO
        END DO
      END IF
C
      END SUBROUTINE DFTB_CALC_GAM_DER2
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_GAM_DER2
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of the second-order
C>             derivative of gamma values
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NSPE Number of species
C>    @param HUBBL Shell-resolved Hubbar values
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param CHAMUL Atom-reslve mulliken charges
C>    @parma HESSIAN Hessian
C>    @param DFTB3 Whether DFTB3 or not
C>    @param HUBDER Hubbard derivatives
C>    @param DAMPXHE Exponent of X-H damping function
C>    @param ISPE Index of species
C>    @parma MAXANG Maximum angular momentum of each species
C>    @param NSHELL Number of shells
C>    @param NDIMGAM Dimension of gamma
C>    @param SPE Name of species
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param DAMPXH Whether H-X damping is used or not
C>           --- OUTPUT ---
C>    @param GRADMAT 1st-order derivative of DFTB2 gamma
C>    @param HESSMAT 2nd-order derivative of DFTB2 gamma
C>    @param GRADMAT3 1st-order derivative of DFTB3 gamma
C>    @param HESSMAT3 2nd-order derivative of DFTB3 gamma
C>
C
      SUBROUTINE DFTB_GAM_DER2(NAT,NSPE,HUBBL,C,DISTMAT,GRADMAT,HESSMAT,
     *  GRADMAT3,HESSMAT3,CHAMUL,HESSIAN,DFTB3,HUBDER,DAMPXHE,ISPE,
     *  MAXANG,NSHELL,NDIMGAM,SPE,SRSCC,DAMPXH)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(NAT),MAXANG(NSPE),NSHELL,
     *  NDIMGAM
      DOUBLE PRECISION, INTENT(IN) :: HUBBL(3,NSPE),C(3,*),DISTMAT(*),
     *  CHAMUL(*),HUBDER(NSPE),DAMPXHE,SPE(*)
      DOUBLE PRECISION, INTENT(OUT) :: GRADMAT(*),HESSMAT(*),
     *  GRADMAT3(NDIMGAM,NDIMGAM),HESSMAT3(NDIMGAM,NDIMGAM)
      DOUBLE PRECISION, INTENT(INOUT) :: HESSIAN(3*NAT,3*NAT)
      LOGICAL, INTENT(IN) :: DFTB3,SRSCC,DAMPXH
C
      INTEGER :: I,J,K,NI,NJ,NK,ISH,ISH0,JSH,JSH0,KSH,KSH0,KK,KI,KJ,IR,
     *  JR,NSEQ
      DOUBLE PRECISION :: VEC(3),CHAMUL1,CHAMUL2,HESS_TMP,DIST,DISTI,
     *  GRAD,HESS,GRAD3C,GRAD3A,HESS3C,HESS3A,HESS_TMPA,HESS_TMPC
      DOUBLE PRECISION, PARAMETER :: ONE=1.0D+00
C
C     CALL DFTB_CALC_GAM_DER2(HUBBL,DISTMAT,GRADMAT,HESSMAT,GRADMAT3,
C    *  HESSMAT3)
      CALL DFTB_CALC_GAM_DER2(GRADMAT,HESSMAT,GRADMAT3,HESSMAT3,DISTMAT,
     *  HUBBL,HUBDER,DAMPXHE,ISPE,MAXANG,NAT,NSPE,NSHELL,NDIMGAM,SPE,
     *  DFTB3,SRSCC,DAMPXH)
C     do i = 1, nshell
C       do j = 1, nshell
C        call DFTB_CNVSQ(i,j,nseq)
C       write (*,'(3i3,2f20.10)') i,j,nseq,gradmat(nseq),hessmat(nseq)
C     end do
C     end do
C
      IF (SRSCC) THEN
        ISH0 = 0
        DO NI = 1, NAT !! A
          DO I = 1, MAXANG(ISPE(NI))
            ISH = ISH0 + I
            CHAMUL1 = CHAMUL(ISH)
            JSH0 = 0
            DO NJ = 1, NAT !! B
              IF (NI.EQ.NJ) THEN
                KSH0 = 0
                DO NK = 1, NAT !! C
                  IF (NI.EQ.NK) THEN
                    KSH0 = KSH0 + MAXANG(ISPE(NK))
                    CYCLE
                  END IF
                  CALL DFTB_CNVSQ(NI,NK,NSEQ)
                  DIST = DISTMAT(NSEQ)
                  DISTI = ONE/DIST
                  DO K = 1, MAXANG(ISPE(NK))
                    KSH = KSH0 + K
                    CHAMUL2 = CHAMUL(KSH)
                    CALL DFTB_CNVSQ(ISH,KSH,NSEQ)
                    GRAD = GRADMAT(NSEQ)
                    HESS = HESSMAT(NSEQ)
C                   write (*,'(3i3,2f20.10)') ish,ksh,nseq,grad,hess
                    IF (DFTB3) THEN
                      GRAD3C = GRADMAT3(KSH,ISH)
                      GRAD3A = GRADMAT3(ISH,KSH)
                      HESS3C = HESSMAT3(KSH,ISH)
                      HESS3A = HESSMAT3(ISH,KSH)
                    END IF
                    DO KK = 1, 3
                      VEC(KK) = C(KK,NI) - C(KK,NK)
                      VEC(KK) = VEC(KK)*DISTI
                    END DO
                    DO KI = 1, 3
                      IR = 3*(NI-1)+KI
                      DO KJ = 1, 3
                        JR = 3*(NJ-1)+KJ
                        IF (KI.EQ.KJ) THEN
                          HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                      + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                          IF (DFTB3) THEN
                            HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                        + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                            HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                        + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                          END IF
                        ELSE
                          HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                      - VEC(KI)*VEC(KJ)*DISTI*GRAD
                          IF (DFTB3) THEN
                            HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                        - VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                            HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                        - VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                          END IF
                        END IF
                        HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                    + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,dist,grad,hess
                        IF (DFTB3) THEN
                         HESSIAN(IR,JR) = HESSIAN(IR,JR)+CHAMUL1*CHAMUL2
     *                    *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)/3.0D+00
C                         WRITE (*,*) HESS_TMPA,HESS_TMPC
                        END IF
                      END DO
                    END DO
                  END DO
                  KSH0 = KSH0 + MAXANG(ISPE(NK))
                END DO
              ELSE
                CALL DFTB_CNVSQ(NI,NJ,NSEQ)
                DIST = DISTMAT(NSEQ)
                DISTI = ONE/DIST
                DO J = 1, MAXANG(ISPE(NJ))
                  JSH = JSH0 + J
                  CHAMUL2 = CHAMUL(JSH)
                  CALL DFTB_CNVSQ(ISH,JSH,NSEQ)
                  GRAD = GRADMAT(NSEQ)
                  HESS = HESSMAT(NSEQ)
                  IF (DFTB3) THEN
                    GRAD3C = GRADMAT3(JSH,ISH)
                    GRAD3A = GRADMAT3(ISH,JSH)
                    HESS3C = HESSMAT3(JSH,ISH)
                    HESS3A = HESSMAT3(ISH,JSH)
                  END IF
                  DO KK = 1, 3
                    VEC(KK) = C(KK,NI) - C(KK,NJ)
                    VEC(KK) = VEC(KK)*DISTI
                  END DO
                  DO KI = 1, 3
                    IR = 3*(NI-1)+KI
                    DO KJ = 1, 3
                      JR = 3*(NJ-1)+KJ
                      IF (KI.EQ.KJ) THEN
                        HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                           - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                        IF (DFTB3) THEN
                          HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                              - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                          HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                              - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                        END IF
                      ELSE
                        HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                           + VEC(KI)*VEC(KJ)*DISTI*GRAD
                        IF (DFTB3) THEN
                          HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                              + VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                          HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                              + VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                        END IF
                      END IF
                      HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                  + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
                      IF (DFTB3) THEN
                        HESSIAN(IR,JR) = HESSIAN(IR,JR)+CHAMUL1*CHAMUL2
     *                    *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)/3.0D+00
C                         WRITE (*,*) HESS_TMPA,HESS_TMPC
                      END IF
                    END DO
                  END DO
                END DO
              END IF
              JSH0 = JSH0 + MAXANG(ISPE(NJ))
            END DO
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NI))
        END DO
      ELSE
        DO NI = 1, NAT !! A
          CHAMUL1 = CHAMUL(NI)
          DO NJ = 1, NAT !! B
            IF (NI.EQ.NJ) THEN
              DO NK = 1, NAT !! C
                IF (NI.EQ.NK) CYCLE
                CHAMUL2 = CHAMUL(NK)
                CALL DFTB_CNVSQ(NI,NK,NSEQ)
                DIST = DISTMAT(NSEQ)
                GRAD = GRADMAT(NSEQ)
                HESS = HESSMAT(NSEQ)
                IF (DFTB3) THEN
                  GRAD3C = GRADMAT3(NK,NI)
                  GRAD3A = GRADMAT3(NI,NK)
                  HESS3C = HESSMAT3(NK,NI)
                  HESS3A = HESSMAT3(NI,NK)
                END IF
                DISTI = ONE/DIST
                DO KK = 1, 3
                  VEC(KK) = C(KK,NI) - C(KK,NK)
                  VEC(KK) = VEC(KK)*DISTI
                END DO
                DO KI = 1, 3
                  IR = 3*(NI-1)+KI
                  DO KJ = 1, 3
                    JR = 3*(NJ-1)+KJ
                    IF (KI.EQ.KJ) THEN
                      HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                         + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                      IF (DFTB3) THEN
                        HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                            + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                        HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                            + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                      END IF
                    ELSE
                      HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                         - VEC(KI)*VEC(KJ)*DISTI*GRAD
                      IF (DFTB3) THEN
                        HESS_TMPA = VEC(KI)*VEC(KJ)*HESS3A
     *                            - VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                        HESS_TMPC = VEC(KI)*VEC(KJ)*HESS3C
     *                            - VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                      END IF
                    END IF
                    HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *                + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
                    IF (DFTB3) THEN
                      HESSIAN(IR,JR) = HESSIAN(IR,JR) + CHAMUL1*CHAMUL2
     *                  *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)/3.0D+00
C                     WRITE (*,*) HESS_TMPA,HESS_TMPC
                    END IF
                  END DO
                END DO
              END DO
            ELSE
              CHAMUL2 = CHAMUL(NJ)
              CALL DFTB_CNVSQ(NI,NJ,NSEQ)
              DIST = DISTMAT(NSEQ)
              GRAD = GRADMAT(NSEQ)
              HESS = HESSMAT(NSEQ)
              DISTI = ONE/DIST
              IF (DFTB3) THEN
                GRAD3C = GRADMAT3(NJ,NI)
                GRAD3A = GRADMAT3(NI,NJ)
                HESS3C = HESSMAT3(NJ,NI)
                HESS3A = HESSMAT3(NI,NJ)
              END IF
              DO KK = 1, 3
                VEC(KK) = C(KK,NI) - C(KK,NJ)
                VEC(KK) = VEC(KK)*DISTI
              END DO
              DO KI = 1, 3
                IR = 3*(NI-1)+KI
                DO KJ = 1, 3
                  JR = 3*(NJ-1)+KJ
                  IF (KI.EQ.KJ) THEN
                    HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                       - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                    IF (DFTB3) THEN
                      HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                          - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3A
                      HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                          - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD3C
                    END IF
                  ELSE
                    HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                       + VEC(KI)*VEC(KJ)*DISTI*GRAD
                    IF (DFTB3) THEN
                      HESS_TMPA = -VEC(KI)*VEC(KJ)*HESS3A
     *                          + VEC(KI)*VEC(KJ)*DISTI*GRAD3A
                      HESS_TMPC = -VEC(KI)*VEC(KJ)*HESS3C
     *                          + VEC(KI)*VEC(KJ)*DISTI*GRAD3C
                    END IF
                  END IF
                  HESSIAN(IR,JR) = HESSIAN(IR,JR)
     *              + HESS_TMP*CHAMUL1*CHAMUL2
C                       write (*,'(i3,i3,3f20.10)')
C    *                  ir,jr,hess_tmp,chamul1,chamul2
                  IF (DFTB3) THEN
                    HESSIAN(IR,JR) = HESSIAN(IR,JR) + CHAMUL1*CHAMUL2
     *                *(CHAMUL1*HESS_TMPA+CHAMUL2*HESS_TMPC)/3.0D+00
C                     WRITE (*,*) HESS_TMPA,HESS_TMPC
                  END IF
                END DO
              END DO
            END IF
          END DO
        END DO
      END IF
C
      END SUBROUTINE DFTB_GAM_DER2
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DEDB
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of U-dependent terms and
C>             de/db dependent terms
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param TSDERAO Working matrix to store the derivative of overlap
C>           in AO basis
C>    @param THDERMO Working matrix to store H_{ij}^a + V_{ij}^a
C>    @param TSDERMO Working matrix to store S_{ij}^a
C>    @param WRK Working array
C>    @param FDERMO \sum_{\mu \nu} c_{\mu i} c_{\nu j} dF_{\mu \nu}/dB
C>    @param DEDB Derivative of eigenvalues of each MO
C>    @param HDERMO Contains all H_{ij}^a + V_{ij}^a
C>    @param SDERMO Contains all S_{ij}^a
C>    @param SDERAO Contains all S_{\mu \nu}/da
C>    @param U U matrix (derivative of MO coefficients)
C>    @param S Overlap matrix
C>    @param EIG Eigenvalues of each MO
C>    @param OCC Occupation number of each MO
C>    @param FONDER Derivative of occupatin numbers
C>    @param DOMEGA Derivatives of shift contribution in atom basis
C>    @param HDERMOJ H_{ij}^b + V_{ij}^a
C>    @param SDERMOJ S_{ij}^b
C>    @param SOMGDMO \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                     S_{\mu \nu}*(d(Omega)/da)_{\mu \nu}
C>    @parma SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param C Coordinates
C>    @param NAT Number of atoms
C>    @param L0 NQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param NDIMSH If (SRSCC); NDIMSH=NSHELL; else NDIMSH=NAT
C>    @param NDOCC Number of doubly occupied orbitals
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT NUmber of virtual orbitals
C>    @param NJ Atom of "b" in derivative
C>    @param KJ Axis of "b" in derivative
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @parma MAXANG Maximum angular momentum of each species
C>    @param IND AO index of each atom
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param IRAF 20
C>    @param IORA Status of .F20
C>    @param ID_HDERMO,ID_SDERMO,ID_SDERAO IDs of HDERIJ,SDERIJ,SDER
C>           stored on DDI memory pool.
C>    @param IDW ID_WORLD (GDDI)
C>    @param INDP AO index of given independent pair
C>    @param SCC Whether SCC or not
C>    @param DISK Whether disk-based algorithm or not
C>    @param FON Whether fractional occupation or not
C>    @param ROHF Whether (same-electron) RO-DFTB or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>    @param DIRECT Integral direct ... meaningless option now
C>    @param ISGDDI Group DDI or not
C>           --- OUTPUT ---
C>    @param FONCON Square of FON contribution
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_DEDB(HESSIAN,TSDERAO,THDERMO,TSDERMO,WRK,
     *  FDERMO,DEDB,
     *  HDERMO,SDERMO,SDERAO,U,VEC,D,EIG,OCC,
     *  FONDER,DOMEGA,HDERMOJ,SDERMOJ,SOMGDMO,SHIFT,SHIFTSA,
     *  SHIFTSB,C,FONCON,
     *  NAT,L0,L1,L2,NSPIN,NDIMSH,NDOCC,NPART,
     *  NSPE,ISPE,MAXANG,IND,INDSH,INDSAO,IRAF,IORA,ID_HDERMO,
     *  ID_SDERMO,ID_SDERAO,IDW,INDP,
     *  SCC,DISK,FON,ROHF,SRSCC,UHF,DIRECT,ISGDDI)
C
      IMPLICIT NONE
C
      COMMON /FMCOM / X(1)
      DOUBLE PRECISION :: X
C
      INTEGER, INTENT(IN) :: L0,L1,L2,NAT,NSPIN,NDIMSH
      DOUBLE PRECISION, INTENT(INOUT) :: HESSIAN(3*NAT),TSDERAO(L2),
     *  THDERMO(L2),TSDERMO(L2),WRK(L2),FDERMO(L2,NSPIN),DEDB(L1,NSPIN),
     *  FONCON
      DOUBLE PRECISION, INTENT(IN) :: HDERMO(L2,3,NAT,NSPIN),
     *  SDERMO(L2,3,NAT,NSPIN),SDERAO(L2,3,NAT),U(L1,L1,NSPIN),
     *  VEC(L1,L1,NSPIN),D(L2,NSPIN),EIG(L1,NSPIN),OCC(L1,NSPIN),
     *  FONDER(L1,NSPIN),DOMEGA(NDIMSH,NSPIN),
     *  HDERMOJ(L2,NSPIN),SDERMOJ(L2,NSPIN),SOMGDMO(L2,NSPIN),
     *  SHIFT(NAT),SHIFTSA(NDIMSH),SHIFTSB(NDIMSH),C(3,NAT)
      INTEGER, INTENT(IN) :: NDOCC(2),
     *  NPART(2),NSPE,
     *  ISPE(NAT),MAXANG(NSPE),IND(*),INDSH(*),INDSAO(*),IRAF,
     *  IORA(3*NAT*5),ID_HDERMO,ID_SDERMO,ID_SDERAO,IDW,
     *  INDP((NDOCC(1)+NPART(1))*L1,NSPIN)
      LOGICAL, INTENT(IN) :: SCC,DISK,FON(2),ROHF,SRSCC,UHF,DIRECT,
     *  ISGDDI
C
      INTEGER :: IO,JO,MO,NSEQ,ISPIN,
     *  N2,IRA1,IRA2,IRA3,IRA4,IRA5,IR,NI,KI,N,NN,LOADFM,LWRK,LWRK1,
     *  LWRK2,LWRK3,LAST,NEED
      DOUBLE PRECISION :: EI,EJ,OCCI,OCCJ,TMP,TMP2,VAL
      DOUBLE PRECISION :: AAA
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,TWO=2.0D+00
C
      DOUBLE PRECISION :: FONTMP
C
C     CALCULATE CONTRIBUTIONS OF U-DEPENDENT TERMS AND DE/DB DEPENDENT
C     TERMS
C
C     FOR FON, FONDER (LDNDR) SHOULD BE CALCULATED
C     OUTSIDE THIS SUBROUTINE (IN DFTB_CALC_DNDR)
C
C     CALCULATE DEDB (DERIVATIVE OF EIGENVALUES) AND FDERIJ TERMS, WHERE
C     FDERIJ_{IJ} = \SUM_{\MU \NU} C_{\MU I} C_{\NU J} dF_{\MU \NU}/dB
C     HERE WRITES FDERMO.
C     "F" IS A KIND OF FOCK MATRIX (SIMPLY HAMILTONIAN IN DFTB)
C
      DO ISPIN = 1, NSPIN
        NSEQ = 0
        DO IO = 1, L1
          EI = EIG(IO,ISPIN)
          DO JO = 1, IO-1
            EJ = EIG(JO,ISPIN)
            NSEQ = NSEQ + 1
            IF (SCC) THEN
              TMP = HDERMOJ(NSEQ,ISPIN)
     *          -(EI+EJ)*SDERMOJ(NSEQ,ISPIN)+SOMGDMO(NSEQ,ISPIN)
            ELSE
              TMP = HDERMOJ(NSEQ,ISPIN)-(EI+EJ)*SDERMOJ(NSEQ,ISPIN)
            END IF
            FDERMO(NSEQ,ISPIN) = TMP
          END DO
          NSEQ = NSEQ + 1
          FDERMO(NSEQ,ISPIN) = -EI*SDERMOJ(NSEQ,ISPIN)
          IF (SCC) THEN
            TMP = HDERMOJ(NSEQ,ISPIN)
     *        -EI*SDERMOJ(NSEQ,ISPIN)+SOMGDMO(NSEQ,ISPIN)
          ELSE
            TMP = HDERMOJ(NSEQ,ISPIN)-EI*SDERMOJ(NSEQ,ISPIN)
          END IF
          DEDB(IO,ISPIN) = TMP
        END DO
      END DO
C
C     PREPARE INDEXING ... I'M NOT SURE THIS IS MEANINGFUL.
C
C     DO ISPIN = 1, NSPIN
C       N2 = 1
C       DO IO = 1, NDOCC(ISPIN)+NPART(ISPIN)
C         OCCI = OCC(IO,ISPIN)
C         IF (OCCI.LT.1.0D-10) CYCLE
C         IF (IO.LE.NDOCC(ISPIN)) THEN
C           DO MO = NDOCC(ISPIN)+1, L1
C             CALL DFTB_CNVSQ(MO,IO,NSEQ)
C             INDP(N2,ISPIN) = NSEQ
C             N2 = N2 + 1
C           END DO
C         ELSE
C           DO MO = 1, L1
C             CALL DFTB_CNVSQ(MO,IO,NSEQ)
C             INDP(N2,ISPIN) = NSEQ
C             N2 = N2 + 1
C           END DO
C         END IF
C       END DO
C     END DO
C
C     CALCULATE CONTRIBUTIONS.
C     D.O. (NDOCC) = DOUBLE OCCUPIED (OR SINGLY OCCUPIED FOR UHF)
C     P.O. (NPART) = PARTLY OCCUPIED
C     U.O. (NVIRT) = UNOCCUPIED (VIRTUAL ORBITALS)
C
      IRA1 = 0
      IRA2 = IRA1 + NAT*3
      IRA3 = IRA2 + NAT*3
      IRA4 = IRA3 + NAT*3
      IRA5 = IRA4 + NAT*3
      IR = 0
      IF (SCC) CALL VCLR(WRK,1,L2)
      IF (DIRECT) THEN
        CALL VALFM(LOADFM)
        LWRK  = LOADFM + 1
        LWRK1 = LWRK   + L2
        LWRK2 = LWRK1  + L2
        LWRK3 = LWRK2  + L1*L1
        LAST  = LWRK3  + L1*L1
        NEED  = LAST - LOADFM - 1
        CALL GETFM(NEED)
      END IF
C
      DO NI = 1, NAT
        DO KI = 1, 3
          IR = IR + 1
          FONTMP = ZERO
          VAL = ZERO
          !! DO SDERAO WORK FIRST
          IF (SCC) THEN
            IF (DISK) THEN
              IRA1 = IRA1 + 1
              IRA2 = IRA2 + 1
              IRA3 = IRA3 + 1
              IRA4 = IRA4 + 1
              IRA5 = IRA5 + 1
              CALL RAREAD(IRAF,IORA,TSDERAO,L2,IRA3,0)
            ELSE IF (DIRECT) THEN
              CALL DFTB_HESS_DIRECT(THDERMO,TSDERMO,TSDERAO,C,
     *          VEC,SHIFT,SHIFTSA,SHIFTSB,X(LWRK),X(LWRK1),X(LWRK2),
     *          X(LWRK3),NI,KI,NAT,L0,L1,L2,IND,NDIMSH,NSPE,NSPIN,INDSH,
     *          INDSAO,ISPE,MAXANG,SCC,SRSCC,UHF)
            ELSE IF (ISGDDI) THEN
C             CALL DDI_GET(ID_SDERAO,1,L2      ,IR,IR,TSDERAO)
              CALL DDI_GET_COMM(ID_SDERAO,1,L2      ,IR,IR,TSDERAO,IDW)
            ELSE
              CALL DCOPY(L2,SDERAO(1,KI,NI),1,TSDERAO,1)
            END IF
            TMP = ZERO
            !! CALCULATE DELTA OMEGA TERM
            DO ISPIN = 1, NSPIN
              IF (SRSCC.OR.UHF) THEN
                CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *            INDSAO,NSPE,ISPE,MAXANG,DOMEGA(1,ISPIN),TSDERAO,
     *            WRK)
              ELSE
                CALL SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,
     *            DOMEGA(1,ISPIN),TSDERAO,WRK)
              END IF
              CALL DDOT_DER(NAT,NI,L2,IND,TMP,D(1,ISPIN),WRK)
              CALL SHIFT_TRIANGLE_DER_CLEAR(NAT,NI,L2,IND,WRK)
            END DO
            !! INITIALIZE WRK ARRAY
            !! NOTE THAT DIAGONAL PART IS ZERO.
            VAL = TMP * TWO
          END IF
          !! READ ONLY SDERMO
          DO ISPIN = 1, NSPIN
            IF (DISK) THEN
              IF (ISPIN.EQ.1) THEN
                CALL RAREAD(IRAF,IORA,THDERMO,L2,IRA1,0)
                CALL RAREAD(IRAF,IORA,TSDERMO,L2,IRA2,0)
              ELSE
                CALL RAREAD(IRAF,IORA,THDERMO,L2,IRA4,0)
                CALL RAREAD(IRAF,IORA,TSDERMO,L2,IRA5,0)
              END IF
            ELSE IF (ISGDDI) THEN
C             CALL DDI_GET(ID_HDERMO,1,L2*NSPIN,IR,IR,THDERMO)
C             CALL DDI_GET(ID_SDERMO,1,L2*NSPIN,IR,IR,TSDERMO)
              CALL DDI_GET_COMM(ID_HDERMO,1,L2*NSPIN,IR,IR,THDERMO,IDW)
              CALL DDI_GET_COMM(ID_SDERMO,1,L2*NSPIN,IR,IR,TSDERMO,IDW)
            ELSE IF (.NOT.DIRECT) THEN
              CALL DCOPY(L2,HDERMO(1,KI,NI,ISPIN),1,THDERMO,1)
              CALL DCOPY(L2,SDERMO(1,KI,NI,ISPIN),1,TSDERMO,1)
            END IF
            !! CALCULATE DEDB TERM FIRST
            NSEQ = 0
            DO IO = 1, NDOCC(ISPIN)+NPART(ISPIN)
              NSEQ = NSEQ + IO
              VAL = VAL-DEDB(IO,ISPIN)*OCC(IO,ISPIN)*TSDERMO(NSEQ)
            END DO
            !! THEN, CALCULATE CONTRIBUTIONS OF D.O.-D.O. SPACE
            DO IO = 1, NDOCC(ISPIN)
              TMP = ZERO
              NN = IO*(IO-1)/2
              DO N = 1, IO-1
                NN = NN + 1
                TMP = TMP - TSDERMO(NN)*FDERMO(NN,ISPIN)
     *                    - THDERMO(NN)*SDERMOJ(NN,ISPIN)
              END DO
              TMP = TMP * TWO
              NN = NN + 1
              TMP = TMP - TSDERMO(NN)*FDERMO(NN,ISPIN)
     *                  - THDERMO(NN)*SDERMOJ(NN,ISPIN)
              VAL = VAL + TMP*OCC(IO,ISPIN)
            END DO
            !! CALCULATE ALL U-TERMS
            !! FIRST COUPLING BETWEEN D.O.-P.O AND D.O.-U.O
            N2 = 1
            TMP2 = ZERO
            DO IO = 1, NDOCC(ISPIN)
              EI = EIG(IO,ISPIN)
              DO MO = NDOCC(ISPIN)+1, L1
                NSEQ = INDP(N2,ISPIN)
                N2 = N2 + 1
                  TMP2 = TMP2 + U(MO,IO,ISPIN)
     *             *(THDERMO(NSEQ)-EI*TSDERMO(NSEQ))
              END DO
            END DO
            VAL = VAL + TMP2*TWO*OCC(1,ISPIN)
            !! IF W/O FON, ALL CONTRIBUTIONS HAVE BEEN DONE
            !! THEN COUPLING BETWEEN P.O.-D.O, P.O.-P.O, P.O.-U.O.
            DO IO = NDOCC(ISPIN)+1, NDOCC(ISPIN)+NPART(ISPIN)
              EI = EIG(IO,ISPIN)
              OCCI = OCC(IO,ISPIN)
              TMP = ZERO
              TMP2 = ZERO
              DO MO = 1, L1 !! ORIGINAL
                NSEQ = INDP(N2,ISPIN)
                N2 = N2 + 1
                EJ = EIG(MO,ISPIN)
                OCCJ = OCC(MO,ISPIN)
                IF (IO.EQ.MO) THEN !!.OR.OCCI.EQ.ONE.AND.OCCJ.EQ.ONE) THEN
                  TMP = TMP - SDERMOJ(NSEQ,ISPIN)
     *              *(THDERMO(NSEQ)-EI*TSDERMO(NSEQ))
                ELSE IF (ABS(EJ-EI).LE.1.0D-06) THEN
                  IF (OCCI.EQ.OCCJ) THEN !! FOR ROHF
                    TMP = TMP - TSDERMO(NSEQ)*FDERMO(NSEQ,ISPIN)
     *                  - THDERMO(NSEQ)*SDERMOJ(NSEQ,ISPIN)
                  ELSE
                    !! AVOID EXPLICIT CALCULATION OF
                    !! NEARLY-DEGENERATED PAIRS.
                    !! IF MO.LT.IO, U ELEMENT IS ZERO, SO SKIP IT.
                    IF (MO.GT.IO) THEN
                      AAA = (U(MO,IO,ISPIN)+SDERMOJ(NSEQ,ISPIN))
     *                  *(OCCJ*EJ-OCCI*EI)/(OCCJ-OCCI)
     *                  - EI*SDERMOJ(NSEQ,ISPIN)
                      TMP2 = TMP2 + U(MO,IO,ISPIN)*THDERMO(NSEQ)
     *                  - AAA*TSDERMO(NSEQ)
                    END IF
                  END IF
                ELSE
                  TMP2 = TMP2 + U(MO,IO,ISPIN)
     *              *(THDERMO(NSEQ)-EI*TSDERMO(NSEQ))
                END IF
              END DO
              VAL = VAL + (TMP+TMP2*TWO)*OCC(IO,ISPIN)
            END DO
            IF (FON(ISPIN).AND..NOT.ROHF) THEN
              NSEQ = NDOCC(ISPIN)*(NDOCC(ISPIN)+1)/2
              DO IO = NDOCC(ISPIN)+1, NDOCC(ISPIN)+NPART(ISPIN)
                NSEQ = NSEQ + IO
                TMP = (THDERMO(NSEQ)-EIG(IO,ISPIN)*TSDERMO(NSEQ))
     *            *FONDER(IO,ISPIN)
                VAL = VAL + TMP
                FONTMP = FONTMP + TMP
              END DO
            END IF
          END DO !! END OF SPIN LOOP
          HESSIAN(IR) = HESSIAN(IR) + VAL !! THIS LINE WASTES TIME ...
          FONCON = FONCON + FONTMP*FONTMP
        END DO
      END DO
C
      IF (DIRECT) CALL RETFM(NEED)
C
      RETURN
C
      END SUBROUTINE DFTB_DEDB
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DDOT_DER
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate vector multiplication.  Either MAT1 or MAT2
C>             should be a derivative matrix, then most matrix elements
C>             will be trivial, and this subroutine will hopefully be
C>             faster than ordinary DDOT (function).
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param NI Atom differentiated
C>    @param L2 L1*(L1+1)/2
C>    @param IND AO index of each atom
C>    @param MAT1,MAT2 Vecotrs to be multiplied
C>           --- OUTPUT ---
C>    @param VALUE Result of dot product
C>
C
      SUBROUTINE DDOT_DER(NAT,NI,L2,IND,VALUE,MAT1,MAT2)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NI,L2,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: MAT1(L2),MAT2(L2)
      DOUBLE PRECISION, INTENT(INOUT) :: VALUE
C
      INTEGER :: L,M,MU,NU,NSEQ,NJ
C
      IF (NI.EQ.1) GO TO 100
C
      NSEQ = IND(NI)*(IND(NI)+1)/2
      DO M = 1, IND(NI+1)-IND(NI)
        MU = IND(NI)+M
        DO NJ = 1, NI-1
          DO L = 1, IND(NJ+1) - IND(NJ)
            NU = IND(NJ)+L
            NSEQ = NSEQ + 1
            VALUE = VALUE + MAT1(NSEQ)*MAT2(NSEQ)
          END DO
        END DO
        NSEQ = NSEQ + M
      END DO
C
100   IF (NI.EQ.NAT) GO TO 200
C
      NSEQ = IND(NI+1)*(IND(NI+1)+1)/2 + IND(NI)
      DO NJ = NI+1, NAT
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1)-IND(NI)
            MU = IND(NI)+M
            NSEQ = NSEQ + 1
            VALUE = VALUE + MAT1(NSEQ)*MAT2(NSEQ)
          END DO
          NSEQ = NSEQ + IND(NI) + NU - MU
        END DO
      END DO
C
200   RETURN
C
      END SUBROUTINE DDOT_DER
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DISPLACEMENT
C>
C>    @brief Hessian of DFTB
C>
C>    @details Make a vector between atom NI and NJ.  If KI and KJ are
C>             zero, V is simply the vector between two atoms.
C>             Otherwise, this subroutine permits to add DELTA step
C>             displacement, which will be useful for numerical
C>             differentiation.  Now, all Slater-Koster transformations
C>             are analytically done, this suborutine may be useless?
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NI Atom at the begining of vector
C>    @param NJ Atom at the end of vector
C>    @param KI First axis displacement is added
C>    @param KJ Second axis displacement is added
C>    @param C Coordinates
C>    @param DELTA Step length of displacement
C>           --- OUTPUT ---
C>    @param V Vector of NI -> NJ
C>
C
      SUBROUTINE DFTB_DISPLACEMENT(NI,NJ,KI,KJ,V,C,DELTA)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: NI,NJ,KI,KJ
      DOUBLE PRECISION,INTENT(OUT) :: V(3)
      DOUBLE PRECISION,INTENT(IN) :: C(3,*),DELTA
      INTEGER :: I
C
      DO I = 1, 3
        V(I) = C(I,NJ) - C(I,NI)
      END DO
      IF (KI.EQ.0.AND.KJ.EQ.0) RETURN
      IF (KI.GT.0) V( KI) = V( KI) + DELTA
      IF (KI.LT.0) V(-KI) = V(-KI) - DELTA
      IF (KJ.EQ.0) RETURN
      IF (KJ.GT.0) V( KJ) = V( KJ) + DELTA
      IF (KJ.LT.0) V(-KJ) = V(-KJ) - DELTA
C
      RETURN
C
      END SUBROUTINE DFTB_DISPLACEMENT
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DER2
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate second-order geometrical derivatives of
C>             non-perturbed Hamiltonian and overlap matrix (AO basis)
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param L2 L1*(L1+1)/2
C>    @param NI Atom at the begining of vector
C>    @param NJ Atom at the end of vector
C>    @param KI First axis displacement is added
C>    @param KJ Second axis displacement is added
C>    @param NAT Number of atoms
C>    @param IND AO index of each atom
C>    @param C Coordinates
C>           --- OUTPUT ---
C>    @param HDER2 2nd der. of Hamiltonian
C>    @param SDER2 2nd der. of overlap
C>
C
      SUBROUTINE DFTB_DER2(L2,NI,KI,NJ,KJ,NAT,IND,C,HDER2,SDER2)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: L2,NI,KI,NJ,KJ,NAT,IND(*)
      DOUBLE PRECISION, INTENT(IN) :: C(3,*)
      DOUBLE PRECISION, INTENT(OUT) :: HDER2(L2),SDER2(L2)
C
      INTEGER :: NK,L,M,MU,NU,NSEQ
      DOUBLE PRECISION :: V(3),AUMM(9,9),BUMM(9,9),DHDR,DSDR
      LOGICAL :: SKP
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00
C
      CALL VCLR(HDER2,1,L2)
      CALL VCLR(SDER2,1,L2)
C
C     write (*,*) "ni,ki = ", ni, ki
C     write (*,*) "nj,kj = ", kj, kj
      IF (NI.EQ.NJ .AND. KI.EQ.KJ) THEN
        DO NK = 1, NAT
          IF (NI.EQ.NK) CYCLE
C         write (*,*) "nk = ", nk
          CALL DFTB_DISPLACEMENT(NI,NK,0,0,V,C,ZERO)
          CALL DFTB_SKODE_HELPA(2,NI,NK,KI,KI,V,AUMM,BUMM,.TRUE.,
     *      .TRUE.,SKP)
          IF (SKP) CYCLE
          DO L = 1, IND(NK+1) - IND(NK)
            NU = IND(NK)+L
            DO M = 1, IND(NI+1) - IND(NI)
              MU = IND(NI)+M
              CALL DFTB_CNVSQ(MU,NU,NSEQ)
              DHDR = AUMM(M,L)
              DSDR = BUMM(M,L)
C             write (*,'(I3,2(X,F20.10))'),NSEQ,DHDR,DSDR
              HDER2(NSEQ) = DHDR
              SDER2(NSEQ) = DSDR
            END DO
          END DO
        END DO
      ELSE IF (NI.EQ.NJ .AND. KI.NE.KJ) THEN
        DO NK = 1, NAT
          IF (NI.EQ.NK) CYCLE
C         write (*,*) "nk = ", nk
          CALL DFTB_DISPLACEMENT(NI,NK,0,0,V,C,ZERO)
          CALL DFTB_SKODE_HELPA(2,NI,NK,KI,KJ,V,AUMM,BUMM,.TRUE.,
     *      .TRUE.,SKP)
          DO L = 1, IND(NK+1) - IND(NK)
            NU = IND(NK)+L
            DO M = 1, IND(NI+1) - IND(NI)
              MU = IND(NI)+M
              CALL DFTB_CNVSQ(MU,NU,NSEQ)
              DHDR = AUMM(M,L)
              DSDR = BUMM(M,L)
C             write (*,'(I3,2(X,F20.10))'),NSEQ,DHDR,DSDR
              HDER2(NSEQ) = DHDR
              SDER2(NSEQ) = DSDR
            END DO
          END DO
        END DO
      ELSE
        CALL DFTB_DISPLACEMENT(NI,NJ,0,0,V,C,ZERO)
        CALL DFTB_SKODE_HELPA(2,NI,NJ,KI,KJ,V,AUMM,BUMM,.TRUE.,
     *    .TRUE.,SKP)
        DO L = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+L
          DO M = 1, IND(NI+1) - IND(NI)
            MU = IND(NI)+M
            CALL DFTB_CNVSQ(MU,NU,NSEQ)
            DHDR = AUMM(M,L)
            DSDR = BUMM(M,L)
C           write (*,'(I3,2(X,F20.10))'),NSEQ,DHDR,DSDR
            HDER2(NSEQ) = DHDR
            SDER2(NSEQ) = DSDR
          END DO
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_DER2
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_D2HS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of second-order
C>             geometrical derivatives of non-perturbed Hamiltonian
C>             and overlap matrix
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param D Density matrix
C>    @param DEIG Energy-weighted density matrix
C>    @param SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param C Coordinates
C>    @param NAT Number of atoms
C>    @param L2 L1*(L1+1)/2
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param IND AO index of each atom
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param INDSAO AO index of each shell
C>    @param SCC Whether SCC or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>           --- OUTPUT ---
C>    @param HDER2 2nd der. of Hamiltonian
C>    @param SDER2 2nd der. of overlap
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_D2HS(HDER2,SDER2,D,DEIG,SHIFT,SHIFTSA,SHIFTSB,
     *  C,HESSIAN,NAT,L2,NSPIN,IND,NSHELL,NSPE,ISPE,
     *  MAXANG,INDSAO,SCC,SRSCC,UHF)
C
      IMPLICIT NONE
C
      INTEGER,INTENT(IN) :: L2,NAT,NSPIN,NSHELL
      DOUBLE PRECISION,INTENT(IN) :: D(L2,NSPIN),DEIG(L2,NSPIN),
     *  SHIFT(NAT),SHIFTSA(NSHELL),SHIFTSB(NSHELL),
     *  C(3,NAT)
      DOUBLE PRECISION,INTENT(INOUT) :: HDER2(L2),SDER2(L2),
     *  HESSIAN(3*NAT,3*NAT)
      INTEGER,INTENT(IN) :: IND(*),NSPE,ISPE(NAT),MAXANG(NSPE),INDSAO(*)
      LOGICAL,INTENT(IN) :: SCC,SRSCC,UHF
C
      INTEGER :: NI,NJ,NK,KI,KJ,I,J,K,L,M,MU,NU,ISH,ISH0,JSH,JSH0,
     *  KSH,KSH0,NSEQ
      DOUBLE PRECISION :: TMP_HESS(3,3),SHIFTI,SHIFTJ,SHIFTIJ,
     *  SHIFTIA,SHIFTIB,SHIFTJA,SHIFTJB,SHIFTIJA,SHIFTIJB,VAL,
     *  TMP,D2HDR,D2SDR
      DOUBLE PRECISION,PARAMETER :: ZERO=0.0D+00,TWO=2.0D+00,
     *  HALF=0.5D+00
C
      IF (UHF.OR.SRSCC) THEN
        ISH0 = 0
        DO NI = 1, NAT
          JSH0 = 0
          DO NJ = 1, NI
            DO KI = 1, 3
              DO KJ = 1, KI
                CALL DFTB_DER2(L2,NI,KI,NJ,KJ,NAT,IND,C,HDER2,SDER2)
                CALL VCLR(TMP_HESS,1,9)
                VAL = ZERO
                IF (NI.EQ.NJ) THEN
                  DO I = 1, MAXANG(ISPE(NI))
                    ISH = ISH0 + I
                    SHIFTIA = SHIFTSA(ISH)
                    SHIFTIB = SHIFTSB(ISH)
                    KSH0 = 0
                    DO NK = 1, NAT
                      DO K = 1, MAXANG(ISPE(NK))
                        KSH = KSH0 + K
                        IF (NI.EQ.NK) CYCLE
                        SHIFTJA = SHIFTSA(KSH)
                        SHIFTJB = SHIFTSB(KSH)
                        SHIFTIJA = (SHIFTIA+SHIFTJA)*HALF
                        SHIFTIJB = (SHIFTIB+SHIFTJB)*HALF
                        DO L = 1, INDSAO(KSH+1) - INDSAO(KSH)
                          NU = INDSAO(KSH)+L
                          DO M = 1, INDSAO(ISH+1) - INDSAO(ISH)
                            MU = INDSAO(ISH)+M
                            CALL DFTB_CNVSQ(MU,NU,NSEQ)
                            D2HDR = HDER2(NSEQ)
                            D2SDR = SDER2(NSEQ)
                            IF (UHF) THEN
                              TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                            + D(NSEQ,2)*(D2HDR+SHIFTIJB*D2SDR)
     *                            - (DEIG(NSEQ,1)+DEIG(NSEQ,2))*D2SDR
                            ELSE
                              TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                            - DEIG(NSEQ,1)*D2SDR
                            END IF
                            VAL = VAL + TMP
                          END DO
                        END DO
                      END DO
                      KSH0 = KSH0 + MAXANG(ISPE(NK))
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) + VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) + VAL*TWO
                ELSE
                  DO I = 1, MAXANG(ISPE(NI))
                    ISH = ISH0 + I
                    SHIFTIA = SHIFTSA(ISH)
                    SHIFTIB = SHIFTSB(ISH)
                    DO J = 1, MAXANG(ISPE(NJ))
                      JSH = JSH0 + J
                      SHIFTJA = SHIFTSA(JSH)
                      SHIFTJB = SHIFTSB(JSH)
                      SHIFTIJA = (SHIFTIA+SHIFTJA)*HALF
                      SHIFTIJB = (SHIFTIB+SHIFTJB)*HALF
                      DO L = 1, INDSAO(JSH+1) - INDSAO(JSH)
                        NU = INDSAO(JSH)+L
                        DO M = 1, INDSAO(ISH+1) - INDSAO(ISH)
                          MU = INDSAO(ISH)+M
                          CALL DFTB_CNVSQ(MU,NU,NSEQ)
                          D2HDR = HDER2(NSEQ)
                          D2SDR = SDER2(NSEQ)
                          IF (UHF) THEN
                            TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                          + D(NSEQ,2)*(D2HDR+SHIFTIJB*D2SDR)
     *                          - (DEIG(NSEQ,1)+DEIG(NSEQ,2))*D2SDR
                          ELSE
                            TMP = D(NSEQ,1)*(D2HDR+SHIFTIJA*D2SDR)
     *                          - DEIG(NSEQ,1)*D2SDR
                          END IF
                          VAL = VAL + TMP
                        END DO
                      END DO
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) - VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) - VAL*TWO
                END IF
                CALL ADD_HESS(NI,NJ,NAT,TMP_HESS,HESSIAN)
              END DO
            END DO
            JSH0 = JSH0 + MAXANG(ISPE(NJ))
          END DO
          ISH0 = ISH0 + MAXANG(ISPE(NI))
        END DO
      ELSE
        DO NI = 1, NAT
          SHIFTI = SHIFT(NI)
          DO NJ = 1, NI
            DO KI = 1, 3
              DO KJ = 1, KI
                CALL DFTB_DER2(L2,NI,KI,NJ,KJ,NAT,IND,C,HDER2,SDER2)
                VAL = ZERO
                CALL VCLR(TMP_HESS,1,9)
                IF (NI.EQ.NJ) THEN
                  DO NK = 1, NAT
                    IF (NI.EQ.NK) CYCLE
                    SHIFTJ = SHIFT(NK)
                    SHIFTIJ = (SHIFTI+SHIFTJ)*HALF
                    DO L = 1, IND(NK+1) - IND(NK)
                      NU = IND(NK)+L
                      DO M = 1, IND(NI+1) - IND(NI)
                        MU = IND(NI)+M
                        CALL DFTB_CNVSQ(MU,NU,NSEQ)
                        D2HDR = HDER2(NSEQ)
                        D2SDR = SDER2(NSEQ)
                        IF (SCC) THEN
                          TMP = D(NSEQ,1)*(D2HDR+SHIFTIJ*D2SDR)
     *                        - DEIG(NSEQ,1)*D2SDR
                        ELSE
                          TMP = D(NSEQ,1)*D2HDR - DEIG(NSEQ,1)*D2SDR
                        END IF
                        VAL = VAL + TMP
                      END DO
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) + VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) + VAL*TWO
                ELSE
                  SHIFTJ = SHIFT(NJ)
                  SHIFTIJ = (SHIFTI+SHIFTJ)*HALF
                  DO L = 1, IND(NJ+1) - IND(NJ)
                    NU = IND(NJ)+L
                    DO M = 1, IND(NI+1) - IND(NI)
                      MU = IND(NI)+M
                      CALL DFTB_CNVSQ(MU,NU,NSEQ)
                      D2HDR = HDER2(NSEQ)
                      D2SDR = SDER2(NSEQ)
                      IF (SCC) THEN
                        TMP = D(NSEQ,1)*(D2HDR+SHIFTIJ*D2SDR)
     *                      - DEIG(NSEQ,1)*D2SDR
                      ELSE
                        TMP = D(NSEQ,1)*D2HDR - DEIG(NSEQ,1)*D2SDR
                      END IF
                      VAL = VAL + TMP
                    END DO
                  END DO
                  TMP_HESS(KI,KJ) = TMP_HESS(KI,KJ) - VAL*TWO
                  IF (KI.NE.KJ)
     *              TMP_HESS(KJ,KI) = TMP_HESS(KJ,KI) - VAL*TWO
                END IF
                CALL ADD_HESS(NI,NJ,NAT,TMP_HESS,HESSIAN)
              END DO
            END DO
          END DO
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_D2HS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_SLKODE_HELPA
C>
C>    @brief Hessian of DFTB
C>
C>    @details Helps analytical Slater-Koster transformation ...
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NDER Order of derivative to be calculated
C>    @param NI Atom at the begining of vector
C>    @param NJ Atom at the end of vector
C>    @param KI First axis displacement is added
C>    @param KJ Second axis displacement is added
C>    @param VEC Vector
C>    @param T1 Whether Hamiltonian derivative is needed or not
C>    @param T2 Whether overlap derivative is needed or not
C>           --- OUTPUT ---
C>    @param MAT1,MAT2 NDER-th derivative of Hamiltonian and overlap
C>
C
      SUBROUTINE DFTB_SKODE_HELPA(NDER,NI,NJ,KI,KJ,VEC,MAT1,MAT2,T1,T2,
     *  SKP)
C
      IMPLICIT NONE

      INTEGER, PARAMETER :: MXATM=5000,MXSPE=10,MXTAB=1500,MXINT=150
C
      INTEGER, INTENT(IN) :: NDER,NI,NJ,KI,KJ
      DOUBLE PRECISION, INTENT(INOUT) :: VEC(3),MAT1(9,9),MAT2(9,9)
      LOGICAL, INTENT(INOUT) :: T1,T2,SKP
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      COMMON /DFTBSK/ SKHTAB(10,MXTAB,MXSPE,MXSPE),
     &                SKSTAB(10,MXTAB,MXSPE,MXSPE),SKSELF(3,MXSPE),
     &                SKGRID(MXSPE,MXSPE),SKDIM(MXSPE,MXSPE),
     *                SKSPIN(MXSPE),REPCOEFF(6,MXINT,MXSPE,MXSPE),
     *                REPINTV(2,MXINT,MXSPE,MXSPE),
     &                REPSHORT(3,MXSPE,MXSPE),REPCUT(MXSPE,MXSPE),
     &                QREFL(3,MXSPE),HUBBL(3,MXSPE),QREF(MXSPE),
     &                HUBB(MXSPE),SKCUT2,ZREF(MXATM),SPNCST(6,MXSPE),
     *                NUMREP(MXSPE,MXSPE)
      DOUBLE PRECISION :: SKHTAB,SKSTAB,SKSELF,SKGRID,SKDIM,SKSPIN,
     &  HUBBL,QREFL,REPCUT,REPINTV,REPSHORT,REPCOEFF,QREF,HUBB,SKCUT2,
     &  ZREF,SPNCST
      INTEGER :: NUMREP
C
      CALL VCLR(MAT1,1,81)
      CALL VCLR(MAT2,1,81)
      CALL DFTB_SKODEA(ISPE(NI),ISPE(NJ),NDER,KI,KJ,MAXANG(ISPE(NI)),
     &  MAXANG(ISPE(NJ)),VEC(1:3),SKGRID(ISPE(NI),ISPE(NJ)),
     &  SKGRID(ISPE(NJ),ISPE(NI)),SKDIM(ISPE(NI),ISPE(NJ)),
     &  SKDIM(ISPE(NJ),ISPE(NI)),
     &  SKHTAB(1:10,1:MXTAB,ISPE(NI),ISPE(NJ)),
     &  SKHTAB(1:10,1:MXTAB,ISPE(NJ),ISPE(NI)),
     &  SKSTAB(1:10,1:MXTAB,ISPE(NI),ISPE(NJ)),
     &  SKSTAB(1:10,1:MXTAB,ISPE(NJ),ISPE(NI)),
     &  SKSELF(1:3,ISPE(NI)),SKCUT2,MAT1,MAT2,T1,T2,SKP)
C
      RETURN
C
      END SUBROUTINE DFTB_SKODE_HELPA
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HSDERIJ
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate and store the integrals of derivative
C>               H_{ij}^a = \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                 \frac{\partial H_{\mu \nu}}{\partial a}
C>               S_{ij}^a = \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                 \frac{\partial S_{\mu \nu}}{\partial a}
C>               V_{ij}^a = \sum_{\mu \nu} c_{\mu i} c_{\nu j}
C>                 \frac{\partial S_{\mu \nu}}{\partial a}
C>                 \frac{\partial \Omega_{AB}}{\partial a}
C>             Practically, H_{ij}^a and V_{ij}^a are usually used
C>             simultaneously, therefore HDERMO contains both terms.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param L0 NQMT
C>    @param L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IND AO index of each atom
C>    @param IRAF 20
C>    @param IORA Status of .F20
C>    @param NSHELL Number of shells
C>    @param C Coordinates
C>    @param SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param VEC MO coefficients
C>    @param WRKH,WRKS Working array for AO derivative of non-perturbed
C>           Hamiltonian and overlap matrix
C>    @param WRK,WRK1 Working array
C>    @param SCC Whether SCC or not
C>    @param DISK Whether intergrals are stored on disk or not
C>    @param UHF Whether U-DFTB or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param MAXANG Maximum angular momentum of each species
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param ID_HDERMO,ID_SDERMO,ID_SDERAO IDs of HDERIJ,SDERIJ,SDER
C>           stored on DDI memory pool.
C>           --- OUTPUT ---
C>    @param HDERMO H_{ij}^a + V_{ij}^a
C>    @param SDERMO S_{ij}^a
C>    @param SDERAO S_{\mu \nu}^a
C>
C
      SUBROUTINE DFTB_HSDERIJ(NAT,L0,L1,L2,IND,IRAF,IORA,NSHELL,C,
     *  HDERMO,SDERMO,SDERAO,SHIFT,SHIFTSA,SHIFTSB,VEC,WRKH,WRKS,WRK,
     *  WRK1,SCC,DISK,UHF,SRSCC,NSPIN,INDSH,INDSAO,MAXANG,NSPE,ISPE,
     *  ID_HDERMO,ID_SDERMO,ID_SDERAO)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,npglob,nnglob,JBTYP,
     *                ISGDDI,PAROUT,INITGDDI,wasgddi
      LOGICAL :: MYJOB,ISGDDI,PAROUT,INITGDDI,WASGDDI
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      LOGICAL GOPARR,DSKWRK,MASWRK
C
      INTEGER, PARAMETER :: DDI_WORLD=0,DDI_GROUP=1
      DOUBLE PRECISION :: AUP(9,9),BUP(9,9),V(3)
      DOUBLE PRECISION,PARAMETER :: ONE=1.0D+00
C
      INTEGER :: IND(*),NSEQ,O,IRAF,IORA(3*NAT*5),NSPIN,INDSH(*),
     *  INDSAO(*),MAXANG(*),NSPE,ISPE(NAT)
      !! SHIFTS  :: ATOMIC SHIFT (NORMAL 2ND ORDER DFTB)
      !! SHIFTSA :: SHELL-RESOLVED SHIFT + SPIN SHIFT
      !! SHIFTSB :: SHELL-RESOLVED SHIFT - SPIN SHIFT
      !! USE SHIFTSA FOR SRSCC
      DOUBLE PRECISION :: C(3,NAT),HDERMO(L2,3,NAT,NSPIN),
     *  SDERMO(L2,3,NAT,NSPIN),
     *  SDERAO(L2,3,NAT),SHIFT(NAT),VEC(L1,L1,NSPIN),WRKH(L2),
     *  WRKS(L2),
     *  WRK(*),WRK1(*),SHIFTSA(NSHELL),SHIFTSB(NSHELL)
      LOGICAL :: SCC,DISK,UHF,SRSCC,SKP
C
C     THIS SUBROUTINE CALCULATES THE DERIVATIVE OF OVERLAP MATRIX.
C     IT WILL BE INTEGRATED INTO DFTB_GRAD SUBROUTINE, BECAUSE
C     NOW THE OVERLAP-DERIVATIVE IS CALCULATED TWICE.
C
C     ----- CALCULATE DH/DR AND DS/DR NUMERICALLY -----
C     DS/DR = (BUP - BUM)/DELTA * 0.5
C
      IF (.NOT.DISK.AND..NOT.ISGDDI) THEN
        CALL VCLR(HDERMO,1,L2*3*NAT*NSPIN)
        CALL VCLR(SDERMO,1,L2*3*NAT*NSPIN)
        CALL VCLR(SDERAO,1,L2*3*NAT)
      END IF
      CALL VCLR(WRK1,1,L2)
C
C     IF DISK IS TRUE, H/S AO DERIVATIVES ARE STORED ON DISK.  THE
C     IR AND JR VARIABLES DETERMINE WHERE MATRICES ARE PUT.  FOR THE
C     DISPLACEMENT OF I-TH ATOM ALONG K-TH VECTOR, THE MATRIX IS STORED
C     AT THE POSITION OF IR = 3*(I-1)+K.
C
      IRA1 = 0
      IRA2 = IRA1 + NAT*3
      IRA3 = IRA2 + NAT*3
      IRA4 = IRA3 + NAT*3
      IRA5 = IRA4 + NAT*3
C
      IF (ISGDDI) THEN
        CALL DDI_DISTRIB(ID_HDERMO,ME,IL_HDERMO,IH_HDERMO,
     *    JL_HDERMO,JH_HDERMO)
        CALL GDDI_SCOPE(DDI_WORLD)
        CALL GDDI_SCOPE(DDI_GROUP)
        CALL DDI_COMMID(DDI_WORLD,IDWORLD)
        IDW = IDWORLD
        CALL GDDICOUNT(-1,LGROUP,MYJOB)
      END IF
C
      IR = 0
      DO I = 1, NAT
        DO K = 1, 3
          IR = IR + 1
          IF (ISGDDI.AND.(IR.GT.JH_HDERMO.OR.IR.LT.JL_HDERMO)) CYCLE
C         write (6,*) "doing for ir = ", ir
          CALL VCLR(WRKH,1,L2)
          CALL VCLR(WRKS,1,L2)
          DO J = 1, NAT
            IF (I.EQ.J) CYCLE
            CALL DFTB_DISPLACEMENT(I,J,K,0,V,C,0)
            CALL DFTB_SKODE_HELPA(1,I,J,K,0,V,AUP,BUP,.TRUE.,.TRUE.,SKP)
            IF (SKP) CYCLE
            DO L = 1, IND(J+1) - IND(J)
              O = IND(J)+L
              DO M = 1, IND(I+1) - IND(I)
                N = IND(I)+M
                CALL DFTB_CNVSQ(N,O,NSEQ)
                WRKH(NSEQ) = AUP(M,L)
                WRKS(NSEQ) = BUP(M,L)
              END DO
            END DO
          END DO
          IF (DISK) THEN
            IRA1 = IRA1 + 1
            IRA2 = IRA2 + 1
            IRA3 = IRA3 + 1
            IRA4 = IRA4 + 1
            IRA5 = IRA5 + 1
            !! HDERMO
            CALL TFTRI0(WRK1,WRKH,VEC,WRK,L0,L1,L1)
            IF (.NOT.SCC) THEN
              CALL RAWRIT(IRAF,IORA,WRK1,L2,IRA1,0) !! JUST SAVE HDER
            ELSE
              IF (UHF) THEN
                CALL RAWRIT(IRAF,IORA,WRK1,L2,IRA1,0)
                CALL TFTRI0(WRK1,WRKH,VEC(1,1,2),WRK,L0,L1,L1)
                CALL RAWRIT(IRAF,IORA,WRK1,L2,IRA4,0)
              ELSE
                CALL DCOPY(L2,WRK1,1,WRKH,1)
              END IF
            END IF
            !! SDERMO
            CALL TFTRI0(WRK1,WRKS,VEC,WRK,L0,L1,L1)
            CALL RAWRIT(IRAF,IORA,WRK1,L2,IRA2,0)
            IF (UHF) THEN
              CALL TFTRI0(WRK1,WRKS,VEC(1,1,2),WRK,L0,L1,L1)
              CALL RAWRIT(IRAF,IORA,WRK1,L2,IRA5,0)
            END IF
            IF (SCC) THEN
              CALL RAWRIT(IRAF,IORA,WRKS,L2,IRA3,0)
              IF (UHF.OR.SRSCC) THEN
                CALL SHIFT_TRIANGLE_SHELL(SHIFTSA,WRKS,WRK1,
     *            NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
              ELSE
                CALL SHIFT_TRIANGLE(NAT,L2,IND,SHIFT,WRKS,WRK1)
              END IF
              !! WRK1 = V_{IJ}^a
              CALL TFTRI0(WRKS,WRK1,VEC,WRK,L0,L1,L1)
              !! SAVE V_{IJ}^a (=\OMEGA*dS/da)
              IF (UHF) CALL RAREAD(IRAF,IORA,WRKH,L2,IRA1,0)
              CALL VADD(WRKH,1,WRKS,1,WRKH,1,L2)
              !! WRKH = H_{IJ}^a + V_{IJ}^a
              CALL RAWRIT(IRAF,IORA,WRKH,L2,IRA1,0)
              IF (UHF) THEN
                CALL RAREAD(IRAF,IORA,WRKS,L2,IRA3,0)
                CALL SHIFT_TRIANGLE_SHELL(SHIFTSB,WRKS,WRK1,
     *            NAT,NSPE,NSHELL,L2,ISPE,MAXANG)
                CALL TFTRI0(WRKS,WRK1,VEC(1,1,2),WRK,L0,L1,L1)
                CALL RAREAD(IRAF,IORA,WRKH,L2,IRA4,0)
                CALL DAXPY(L2,ONE,WRKS,1,WRKH,1)
                CALL RAWRIT(IRAF,IORA,WRKH,L2,IRA4,0)
              END IF
            END IF
          ELSE IF (ISGDDI) THEN
            DO ISPIN = 1, NSPIN
              CALL TFTRI0(HDERMO(1,ISPIN,1,1),WRKH,VEC(1,1,ISPIN),
     *          WRK,L0,L1,L1)
            END DO
            DO ISPIN = 1, NSPIN
              CALL TFTRI0(SDERMO(1,ISPIN,1,1),WRKS,VEC(1,1,ISPIN),
     *          WRK,L0,L1,L1)
            END DO
            IF (SCC) THEN
              !! SAVE SDERAO
              CALL DCOPY(L2,WRKS,1,SDERAO,1)
              IF (UHF.OR.SRSCC) THEN
                CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *            INDSAO,NSPE,ISPE,MAXANG,SHIFTSA,SDERAO,WRKS)
              ELSE
                CALL SHIFT_TRIANGLE_DER(NAT,I,L2,IND,SHIFT,
     *               SDERAO,WRKS)
              END IF
              CALL TFTRI0(WRK1,WRKS,VEC,WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
              CALL DAXPY(L2,ONE,WRK1,1,HDERMO(1,1,1,1),1)
              IF (UHF) THEN
                CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *             INDSAO,NSPE,ISPE,MAXANG,SHIFTSB,SDERAO,WRKS)
                CALL TFTRI0(WRK1,WRKS,VEC(1,1,2),WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
                CALL DAXPY(L2,ONE,WRK1,1,HDERMO(1,2,1,1),1)
              END IF
              CALL SHIFT_TRIANGLE_DER_CLEAR(NAT,I,L2,IND,WRK1)
              CALL DDI_PUT_COMM(ID_SDERAO,1,L2    ,IR,IR,SDERAO,IDW)
            END IF
            CALL DDI_PUT_COMM(ID_HDERMO,1,L2*NSPIN,IR,IR,HDERMO,IDW)
            CALL DDI_PUT_COMM(ID_SDERMO,1,L2*NSPIN,IR,IR,SDERMO,IDW)
          ELSE
            !! HDERMO
            DO ISPIN = 1, NSPIN
              CALL TFTRI0(HDERMO(1,K,I,ISPIN),WRKH,VEC(1,1,ISPIN),
     *          WRK,L0,L1,L1)
            END DO
            !! SDERMO
            DO ISPIN = 1, NSPIN
              CALL TFTRI0(SDERMO(1,K,I,ISPIN),WRKS,VEC(1,1,ISPIN),
     *          WRK,L0,L1,L1)
            END DO
            IF (SCC) THEN
              !! SAVE SDERAO
              CALL DCOPY(L2,WRKS,1,SDERAO(1,K,I),1)
              IF (UHF.OR.SRSCC) THEN
                CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *            INDSAO,NSPE,ISPE,MAXANG,SHIFTSA,SDERAO(1,K,I),WRKS)
              ELSE
                CALL SHIFT_TRIANGLE_DER(NAT,I,L2,IND,SHIFT,
     *               SDERAO(1,K,I),WRKS)
              END IF
              CALL TFTRI0(WRK1,WRKS,VEC,WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
              CALL DAXPY(L2,ONE,WRK1,1,HDERMO(1,K,I,1),1)
              IF (UHF) THEN
                CALL SHIFT_TRIANGLE_DER_SHELL(NAT,I,L2,IND,INDSH,
     *             INDSAO,NSPE,ISPE,MAXANG,SHIFTSB,SDERAO(1,K,I),WRKS)
                CALL TFTRI0(WRK1,WRKS,VEC(1,1,2),WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
                CALL DAXPY(L2,ONE,WRK1,1,HDERMO(1,K,I,2),1)
              END IF
              CALL SHIFT_TRIANGLE_DER_CLEAR(NAT,I,L2,IND,WRK1)
            END IF
          END IF
        END DO
      END DO
C
      IF (ISGDDI) THEN
        CALL GDDICOUNT( 1,LGROUP,MYJOB)
        CALL GDDI_SCOPE(DDI_WORLD)
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_HSDERIJ
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_EREP_HESSIAN
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution from Erep
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param GRADMAT Matrix of gradient
C>    @param HESSMAT Matrix of Hessian
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_EREP_HESSIAN(DISTMAT,GRADMAT,HESSMAT,HESSIAN)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      PARAMETER (MXATM=5000, MXSPE=10, MXTAB=1500, MXINT=150)
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      COMMON /DFTBSK/ SKHTAB(10,MXTAB,MXSPE,MXSPE),
     &                SKSTAB(10,MXTAB,MXSPE,MXSPE),SKSELF(3,MXSPE),
     &                SKGRID(MXSPE,MXSPE),SKDIM(MXSPE,MXSPE),
     *                SKSPIN(MXSPE),REPCOEFF(6,MXINT,MXSPE,MXSPE),
     *                REPINTV(2,MXINT,MXSPE,MXSPE),
     &                REPSHORT(3,MXSPE,MXSPE),REPCUT(MXSPE,MXSPE),
     &                QREFL(3,MXSPE),HUBBL(3,MXSPE),QREF(MXSPE),
     &                HUBB(MXSPE),SKCUT2,ZREF(MXATM),SPNCST(6,MXSPE),
     *                NUMREP(MXSPE,MXSPE)
      DOUBLE PRECISION :: SKHTAB,SKSTAB,SKSELF,SKGRID,SKDIM,SKSPIN,
     &  HUBBL,QREFL,REPCUT,REPINTV,REPSHORT,REPCOEFF,QREF,HUBB,SKCUT2,
     &  ZREF,SPNCST
      INTEGER :: NUMREP

C
      DOUBLE PRECISION :: DISTMAT(*),GRADMAT(*),HESSMAT(*),
     *  HESSIAN(3*NAT,3*NAT)
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      DO I = 1, NAT
        ISP1 = ISPE(I)
        DO J = 1, I
          ISP2 = ISPE(J)
          GRAD = ZERO
          HESS = ZERO
          CALL DFTB_CNVSQ(I,J,NSEQ)
          DIST = DISTMAT(NSEQ)
          IF (DIST.LT.1.0D-02) THEN
C         ----- VAL = 0.0 IF DISTANCE IS LESS THAN 0.01 AU
            GRAD = ZERO
            HESS = ZERO
          ELSE IF (DIST.GT.REPCUT(ISP1,ISP2)) THEN
C         ----- VAL = 0.0 IF DISTANCE IS MORE THAN CUTOFF
            GRAD = ZERO
            HESS = ZERO
          ELSE
            IF (DIST.LT.REPINTV(1,1,ISP1,ISP2)) THEN
C            --- SHORT RANGE REPULSIVE PART ---
              GRAD = -REPSHORT(1,ISP1,ISP2)
     &            * EXP(-REPSHORT(1,ISP1,ISP2)*DIST
     &                 + REPSHORT(2,ISP1,ISP2))
              HESS = (REPSHORT(1,ISP1,ISP2)**2)
     &            * EXP(-REPSHORT(1,ISP1,ISP2)*DIST
     &                 + REPSHORT(2,ISP1,ISP2))
            ELSE
              DO K = 1, NUMREP(ISP1,ISP2)
                IF (DIST.GE.REPINTV(1,K,ISP1,ISP2)
     &              .AND. DIST.LE.REPINTV(2,K,ISP1,ISP2)) EXIT
              END DO
              X1  = DIST - REPINTV(1,K,ISP1,ISP2)
              X0  = ONE
              X00 = ONE
              IF (K.LT.NUMREP(ISP1,ISP2)) THEN
C            --- MEDIUM RANGE REPULSIVE PART ---
                DO L = 2, 4
                  GRAD = GRAD + (L-1)*REPCOEFF(L,K,ISP1,ISP2) * X0
                  HESS = HESS + (L-1)*(L-2)*REPCOEFF(L,K,ISP1,ISP2)*X00
                  IF (L.NE.2) X00 = X00 * X1
                  X0  = X0 * X1
                END DO
              ELSE
C            --- LONG RANGE REPULSIVE PART ---
                DO L = 2, 6
                  GRAD = GRAD + (L-1)*REPCOEFF(L,K,ISP1,ISP2) * X0
                  HESS = HESS + (L-1)*(L-2)*REPCOEFF(L,K,ISP1,ISP2)*X00
                  IF (L.NE.2) X00 = X00 * X1
                  X0  = X0 * X1
                END DO
              END IF
            END IF
          END IF
C         WRITE (*,'(I3,X,I3,X,F12.6,X,F12.6)') I,J,GRAD,HESS
          GRADMAT(NSEQ) = GRAD
          HESSMAT(NSEQ) = HESS
        END DO
      END DO
C
C     ----- ADD CONTRIBUTIONS (GRADMAT AND HESSMAT) TO HESSIAN -----
C
      CALL DFTB_MAT_HESS(NAT,C,DISTMAT,GRADMAT,HESSMAT,HESSIAN)
C
      END SUBROUTINE DFTB_EREP_HESSIAN
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK ADD_HESS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Add Hessian contribution to NI and NJ blocks
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NI,NJ Atom block to be added
C>    @param NAT Nymber of atoms
C>    @param TMP Block Hessian
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE ADD_HESS(NI,NJ,NAT,TMP,HESSIAN)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NI,NJ,NAT
      DOUBLE PRECISION, INTENT(INOUT) :: TMP(3,3)
      DOUBLE PRECISION, INTENT(OUT) :: HESSIAN(3*NAT,3*NAT)
C
      INTEGER :: I,ITMP,JTMP
      DOUBLE PRECISION :: VTMP,ONE=1.0D+00
C
      IF (NI.EQ.NJ) THEN
        ITMP = 3*(NI-1)+1
        JTMP = 3*(NI-1)
        DO I = 1, 3
          JTMP = JTMP + 1
          CALL DAXPY(3,ONE,TMP(1,I),1,HESSIAN(ITMP,JTMP),1)
        END DO
      ELSE
        ITMP = 3*(NJ-1)+1
        JTMP = 3*(NI-1)
        DO I = 1, 3
          JTMP = JTMP + 1
          CALL DAXPY(3,ONE,TMP(1,I),1,HESSIAN(ITMP,JTMP),1)
        END DO
        VTMP = TMP(2,1)
        TMP(2,1) = TMP(1,2)
        TMP(1,2) = VTMP
        VTMP = TMP(3,1)
        TMP(3,1) = TMP(1,3)
        TMP(1,3) = VTMP
        VTMP = TMP(3,2)
        TMP(3,2) = TMP(2,3)
        TMP(2,3) = VTMP
        ITMP = 3*(NI-1)+1
        JTMP = 3*(NJ-1)
        DO I = 1, 3
          JTMP = JTMP + 1
          CALL DAXPY(3,ONE,TMP(1,I),1,HESSIAN(ITMP,JTMP),1)
        END DO
      END IF
C
      RETURN
C
      END SUBROUTINE ADD_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_DISP_HESS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of dispersion correction.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>    @date Nov, 2014- Yoshio Nishimoto
C>    - Bug fix of SK dispersion Hessian
C>
C>           --- INPUT ---
C>    @param NAT Nymber of atoms
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param DFTBDP Parameters of dispersion correction
C>    @param ZREF Nuclear charges of a given atom.  In FMO-DFTB, ZREF
C>           of BDA or BAA is differet from QREF
C>    @param QREF Nuclear charges of a given species.  This is taken
C>           from Slater-Koster files
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param IDFTBD (1) UFF (2) SK
C>           --- OUTPUT ---
C>    @param GRADMAT Matrix of 1st-order derivatives of dispersion
C>    @param HESSMAT Matrix of 2nd-order derivatives of dispersion
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_DISP_HESS(NAT,NSPE,ISPE,DFTBDP,ZREF,QREF,C,
     *  DISTMAT,GRADMAT,HESSMAT,HESSIAN,IDFTBD)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      INTEGER, INTENT(IN) :: NAT,NSPE,ISPE(*),IDFTBD
      DOUBLE PRECISION :: RDMAT(3,NSPE,NSPE)
      DOUBLE PRECISION, INTENT(IN) :: DFTBDP(*),ZREF(*),QREF(*),
     *  DISTMAT(*)
      DOUBLE PRECISION, INTENT(INOUT) :: GRADMAT(*),HESSMAT(*),
     *  HESSIAN(3*NAT,3*NAT)
C
      DOUBLE PRECISION :: NEA, NEB
C
      NN = NAT*(NAT+1)/2
      CALL VCLR(GRADMAT,1,NN)
      CALL VCLR(HESSMAT,1,NN)
C
      NSP1 = 0
      NSP2 = 0
      IF (IDFTBD.EQ.1) THEN
        C1 = 4.78947150872246D+01 !! 2^(5/6)*672/25
        C2 = 3.50498152274578D+01 !! 2^(2/3)*552/25
        CR0 = 8.908987181D-01
        !! FIRST CALCULATE SOME CONSTANTS FOR ALL PAIRS OF SPECIES
        DO I = 1, NSPE
          RI = DFTBDP(I*2-1)
          DI = DFTBDP(I*2  )
          DO J = I, NSPE
            RJ = DFTBDP(J*2-1)
            DJ = DFTBDP(J*2  )
            RIJ = SQRT(RI*RJ) !! van der Waals distance
            DIJ = SQRT(DI*DJ) !! well depth
            R0 = CR0*RIJ
            RDMAT(1,I,J) = R0
            RDMAT(2,I,J) = RIJ
            RDMAT(3,I,J) = DIJ
            RDMAT(1,J,I) = R0
            RDMAT(2,J,I) = RIJ
            RDMAT(3,J,I) = DIJ
          END DO
        END DO
        !! CALCULATE DISPERSION CORRECTION
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CI = ZREF(I)/QREF(NSP1)
          DO J = 1, I
            CALL DFTB_CNVSQ(I,J,NSEQ)
            IF (I.EQ.J) THEN
              GRADMAT(NSEQ) = ZERO
              HESSMAT(NSEQ) = ZERO
              CYCLE
            END IF
            NSP2 = ISPE(J)
            CJ = ZREF(J)/QREF(NSP2)
            GRAD = ZERO
            HESS = ZERO
            R0  = RDMAT(1,NSP1,NSP2)
            RIJ = RDMAT(2,NSP1,NSP2)
            DIJ = RDMAT(3,NSP1,NSP2)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIJ = DIJ * CI * CJ
            IF (DIST.GE.R0) THEN !! ATTRACTIVE POTENTIAL
              TMP = RIJ/DIST
              R6 = TMP**6
              R12 = R6**2
              GRAD = 1.2D+01*DIJ*(R6-R12)*DISTI
              HESS = 1.2D+01*DIJ*(-7.0D+00*R6+1.3D+01*R12)*DISTI*DISTI
            ELSE !! REPULSIVE POTENTIAL
              TMP = DIST/RIJ
              R5 = TMP**5
              R10 = R5**2
              GRAD = DIJ*(-5.0D+00*C1*R5+1.0D+01*C2*R10)*DISTI
              HESS = DIJ*(-2.0D+01*C1*R5+9.0D+01*C2*R10)*DISTI*DISTI
            END IF
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      ELSE IF (IDFTBD.EQ.2) THEN
        !! FIRST CALCULATE SOME CONSTANTS FOR ALL PAIRS OF SPECIES
        DO I = 1, NSPE
          PA  = DFTBDP(I*3-2)
          R0A = DFTBDP(I*3-1)
          NEA = DFTBDP(I*3  )
          C6A = 7.5D-01*SQRT(NEA*PA*PA*PA)
          DO J = I, NSPE
            PB  = DFTBDP(J*3-2)
            R0B = DFTBDP(J*3-1)
            NEB = DFTBDP(J*3  )
            C6B = 7.5D-01*SQRT(NEB*PB*PB*PB)
C
            C6AB = (2.0D+00*C6A*C6B*PA*PB) / (PA*PA*C6B+PB*PB*C6A)
            R0AB = (R0A**3 + R0B**3) / (R0A**2 + R0B**2)
            R0AB7I = 1.0D+00 / R0AB**7
            RDMAT(1,I,J) = C6AB
            RDMAT(2,I,J) = R0AB7I
            RDMAT(1,J,I) = C6AB
            RDMAT(2,J,I) = R0AB7I
          END DO
        END DO
        DO I = 1, NAT
          NSP1 = ISPE(I)
          CI = ZREF(I)/QREF(NSP1)
          DO J = I+1, NAT
            NSP2 = ISPE(J)
            CJ = ZREF(J)/QREF(NSP2)
            C6AB   = RDMAT(1,NSP1,NSP2)
            R0AB7I = RDMAT(2,NSP1,NSP2)
            C6AB = C6AB * CI * CJ
            CALL DFTB_CNVSQ(I,J,NSEQ)
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DIST7  = DIST**7
            DIST7I = DISTI**7
            R7R07 = DIST7*R0AB7I
            VEXP = EXP(-3.0D+00*R7R07)
            DAMP1 = ONE - VEXP
            DAMP2 = DAMP1 * DAMP1
            DAMP3 = DAMP2 * DAMP1
            VAL = 8.4D+01*VEXP*R7R07-6.0D+00*DAMP1
            GRAD = VAL*C6AB*DAMP3*DIST7I
            VAL = 2.52D+02*R7R07*VEXP*(-2.0D+00*DAMP1
     *                 +7.0D+00*R7R07*(3.0D+00-4.0D+00*DAMP1))
     *          + 4.2D+01*DAMP2
            HESS = -VAL*C6AB*DAMP2*DIST7I*DISTI
            GRADMAT(NSEQ) = GRAD
            HESSMAT(NSEQ) = HESS
          END DO
        END DO
      END IF
C
C     ----- ADD CONTRIBUTIONS (GRADMAT AND HESSMAT) TO HESSIAN -----
C
      CALL DFTB_MAT_HESS(NAT,C,DISTMAT,GRADMAT,HESSMAT,HESSIAN)
C
      RETURN
C
      END SUBROUTINE DFTB_DISP_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_MAT_HESS
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate Hessian contribution of classical terms from
C>             1st- and 2nd-order derivatives
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Nymber of atoms
C>    @param C Coordinates
C>    @param DISTMAT Matrix of inter-atomic distances
C>    @param GRADMAT Matrix of 1st-order derivatives of dispersion
C>    @param HESSMAT Matrix of 2nd-order derivatives of dispersion
C>           --- OUTPUT ---
C>    @param HESSIAN Hessian
C>
C
      SUBROUTINE DFTB_MAT_HESS(NAT,C,DISTMAT,GRADMAT,HESSMAT,HESSIAN)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
C
      INTEGER :: NAT
      DOUBLE PRECISION, INTENT(IN) :: C(3,*),DISTMAT(*),GRADMAT(*),
     *  HESSMAT(*)
      DOUBLE PRECISION, INTENT(INOUT) :: HESSIAN(3*NAT,3*NAT)
      DOUBLE PRECISION :: TMP(3,3),VEC(3)
C
C     NI :: DISPLACEMENT OF ATOM A
C     KI :: DIRECTION ALONG X, Y, OR Z (ATOM A)
C     NJ :: DISPLACEMENT OF ATOM B
C     KJ :: DIRECTION ALONG X, Y, OR Z (ATOM B)
C     NK :: SUM FOR WHEN NI = NJ
C
      DO NI = 1, NAT
        DO NJ = 1, NI
          CALL VCLR(TMP,1,9)
          IF (NI.EQ.NJ) THEN
            DO NK = 1, NAT
              IF (NI.EQ.NK) CYCLE
              CALL DFTB_CNVSQ(NI,NK,NSEQ)
              GRAD = GRADMAT(NSEQ)
              HESS = HESSMAT(NSEQ)
              IF (GRAD.EQ.ZERO.AND.HESS.EQ.ZERO) CYCLE
              DIST = DISTMAT(NSEQ)
              DISTI = ONE/DIST
              DO KK = 1, 3
                VEC(KK) = C(KK,NI) - C(KK,NK)
                VEC(KK) = VEC(KK)*DISTI
              END DO
              DO KI = 1, 3
                DO KJ = 1, KI
                  IF (KI.EQ.KJ) THEN
                    HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                       + (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                    TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                  ELSE
                    HESS_TMP = VEC(KI)*VEC(KJ)*HESS
     *                       - VEC(KI)*VEC(KJ)*DISTI*GRAD
                    TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                    TMP(KJ,KI) = TMP(KJ,KI) + HESS_TMP
                  END IF
                END DO
              END DO
            END DO
          ELSE
            CALL DFTB_CNVSQ(NI,NJ,NSEQ)
            GRAD = GRADMAT(NSEQ)
            HESS = HESSMAT(NSEQ)
            IF (GRAD.EQ.ZERO.AND.HESS.EQ.ZERO) CYCLE
            DIST = DISTMAT(NSEQ)
            DISTI = ONE/DIST
            DO KK = 1, 3
              VEC(KK) = C(KK,NI) - C(KK,NJ)
              VEC(KK) = VEC(KK)*DISTI
            END DO
            DO KI = 1, 3
              DO KJ = 1, KI
                IF (KI.EQ.KJ) THEN
                  HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                     - (ONE-VEC(KI)*VEC(KJ))*DISTI*GRAD
                  TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                ELSE
                  HESS_TMP = -VEC(KI)*VEC(KJ)*HESS
     *                     + VEC(KI)*VEC(KJ)*DISTI*GRAD
                  TMP(KI,KJ) = TMP(KI,KJ) + HESS_TMP
                  TMP(KJ,KI) = TMP(KJ,KI) + HESS_TMP
                END IF
              END DO
            END DO
          END IF
          CALL ADD_HESS(NI,NJ,NAT,TMP,HESSIAN)
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_MAT_HESS
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_TFTRI0
C>
C>    @brief Hessian of DFTB
C>
C>    @details See below
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C
      SUBROUTINE DFTB_TFTRI0(NDOCC,NPART,H,F,T,WRK,M,N,LDT)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION H(*),F(*),T(LDT,M),WRK(N)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL3
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
      PARAMETER (ZERO=0.0D+00, ONE=1.0D+00)
C
C     ----- TRANSFORM THE TRIANGULAR MATRIX F USING VECTORS T -----
C                      H = T-DAGGER * F * T
C     THE ORDER OF THE TRIANGULAR MATRIX -H- IS -M-   AND   -F- IS -N-
C     THIS SUBROUTINE CALCULATES ONLY INDEPENDENT (OCCUPIED-VIRTUAL
C     COUPLING) TERMS.
C
      M2 = (M*M+M)/2
C
      PARALL3 = GOPARR  .AND.  M.GT.MXSQN3()
      IF (PARALL3) CALL VCLR(H,1,M2)
      IPCOUNT = ME - 1

C
C        THE COMPUTATION HERE IS H = T-DAGGER * (F * T),
C        WITH THE -DSPMV- FIRST PRODUCING ONE COLUMN OF F*T,
C        THEN THE -DGEMV- GENERATES AN ENTIRE ROW -J- OF -H-.
C
      DO 100 J = NDOCC+1, M
         IF(PARALL3) THEN
           IPCOUNT = IPCOUNT + 1
           IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 100
         END IF
         IJ = (J*J-J)/2
         CALL DSPMV('U',N,ONE,F,T(1,J),1,ZERO,WRK,1)
         LOCY = 1
         DO 210 I=1, MIN(J,NDOCC+NPART)
            H(IJ+LOCY) = DDOT(M,T(1,I),1,WRK,1)
            LOCY = LOCY+1
  210    CONTINUE
  100 CONTINUE
C
      IF(PARALL3) CALL DDI_GSUMF(520,H,M2)
C
      RETURN
      end
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_CHKOCC
C>
C>    @brief Hessian of DFTB
C>
C>    @details Check occupation of all orbitals in alpha and beta
C>             space.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param OCC Occupation number of each MO
C>    @param EIG Eigenvalues of each MO
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param L1 Number of basis functions
C>    @param IW 6
C>    @param MASWRK
C>    @param SOME Some output
C>    @param SCFTYP
C>           --- OUTPUT ---
C>    @param NDOCC Numer of doubly occupied orbitals in R-DFTB, but
C>           of singly occupied orbitals in U-DFTB.
C>    @param NPART Number of partially occupied orbitals
C>    @param NVIRT Number of virtual orbitals
C>    @param FON Whether fractional occupation is used or not
C>    @param ROHF Whether (same-electron) RO-DFTB or not
C>
C
      SUBROUTINE DFTB_HESS_CHKOCC(OCC,EIG,NDOCC,NPART,NVIRT,NSPIN,L1,IW,
     *  FON,ROHF,MASWRK,SOME,SCFTYP)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NSPIN,L1
      DOUBLE PRECISION, INTENT(IN) :: OCC(L1,NSPIN),EIG(L1,NSPIN),SCFTYP
      INTEGER, INTENT(OUT) :: NDOCC(2),NPART(2),NVIRT(2)
      INTEGER, INTENT(IN) :: IW
      LOGICAL, INTENT(OUT) :: FON(3),ROHF
      LOGICAL, INTENT(IN) :: MASWRK,SOME
C
      INTEGER :: IO,NHALF,ISPIN
      DOUBLE PRECISION :: DOC,OCCI
      DOUBLE PRECISION, PARAMETER :: ONE=1.0D+00,TWO=2.0D+00
      DOUBLE PRECISION RHF/8HRHF     /,ROHFC/8HROHF    /,UHF/8HUHF     /
C
      !! NHALF SHOULD BE USED, MAYBE
      !! FIRST ONLY FOR ALPHA
C
      IF (SCFTYP.EQ.RHF)  DOC = TWO
      IF (SCFTYP.EQ.UHF)  DOC = ONE
      IF (SCFTYP.EQ.ROHFC) DOC = TWO
C
      DO ISPIN = 1, NSPIN
        FON(ISPIN) = .FALSE.
        NDOCC(ISPIN) = 0
        NPART(ISPIN) = 0
        NVIRT(ISPIN) = 0
        NHALF = 0
        DO IO = 1, L1
          OCCI = OCC(IO,ISPIN)
          IF (OCCI+1.0D-10.GT.DOC) THEN
            NDOCC(ISPIN) = NDOCC(ISPIN) + 1
          ELSE IF (OCCI.LE.1.0D-10) THEN
            NVIRT(ISPIN) = NVIRT(ISPIN) + 1
          ELSE
            NPART(ISPIN) = NPART(ISPIN) + 1
            IF (OCCI.EQ.ONE) NHALF = NHALF + 1
            IF (.NOT.FON(ISPIN).AND.MASWRK.AND.SOME) THEN
              IF (ISPIN.EQ.1) THEN
                WRITE (IW,'(/" CHECK PARTLY OCCUPIED ALPHA-ORBITALS"/)')
              ELSE
                WRITE (IW,'(/" CHECK PARTLY OCCUPIED  BETA-ORBITALS"/)')
              END IF
              WRITE (IW,*) " #ORB       EIGENVALUES(AU)      OCCUPATION
     * NUM."
            END IF
            IF (MASWRK.AND.SOME) WRITE (IW,'(2X,I4,2(X,F20.10))')
     *        IO,EIG(IO,ISPIN),OCC(IO,ISPIN)
            FON(ISPIN) = .TRUE.
          END IF
        END DO
        !! ASSUME ROHF WAVE FUNCTION, IF THE OCCUPATION OF ALL PARTLY
        !! OCCUPIED ARE ONE.
      END DO
      IF (NSPIN.EQ.1.AND.NHALF.NE.0.AND.NHALF.EQ.NPART(1)) ROHF=.TRUE.
C
      RETURN
C
      END SUBROUTINE DFTB_HESS_CHKOCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBHS    *DECK DFTB_HESS_DIRECT
C>
C>    @brief Hessian of DFTB
C>
C>    @details Calculate derivative integrals in integral direct way.
C>             This will be abolished, unless someone finds a better
C>             algorithm.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param C Coordinates
C>    @param SHIFT Shift contribution (atom-resolved)
C>    @param SHIFTSA Shift contribution of alpha orbitals (shell-res.)
C>    @param SHIFTSB Shift contribution of beta  orbitals (shell-res.)
C>    @param WRKH,WRKS Working array for AO derivative of non-perturbed
C>           Hamiltonian and overlap matrix
C>    @param NI Atom to be differenciated
C>    @param KI Axis to be differenciated
C>    @param NAT Number of atoms
C>    @param L0 LQMT
C>    @parma L1 Number of basis functions
C>    @param L2 L1*(L1+1)/2
C>    @param IND AO index of each atom
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param NSPIN Number of spins (1=R-DFTB,2=U-DFTB)
C>    @param INDSH Index of shell for each atom
C>    @param INDSAO AO index of each shell
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param SCC Whether SCC or not
C>    @param SRSCC Whether shell-resolved SCC or not
C>    @param UHF Whether U-DFTB or not
C>           --- OUTPUT ---
C>    @param HDERMO H_{ij}^a + V_{ij}^a
C>    @param SDERMO S_{ij}^a
C>    @param SDERAO S_{\mu \nu}^a
C>
C
      SUBROUTINE DFTB_HESS_DIRECT(HDERMO,SDERMO,SDERAO,C,VEC,SHIFT,
     *  SHIFTSA,SHIFTSB,WRKH,WRKS,WRK,WRK1,NI,KI,NAT,L0,L1,L2,IND,
     *  NSHELL,NSPE,NSPIN,INDSH,INDSAO,ISPE,MAXANG,SCC,SRSCC,UHF)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: L0,L1,L2,NAT,NSHELL,NSPIN
      DOUBLE PRECISION, INTENT(OUT) :: HDERMO(L2,NSPIN),
     *  SDERMO(L2,NSPIN),SDERAO(L2)
      DOUBLE PRECISION, INTENT(IN) :: C(3,NAT),VEC(L1,L1,NSPIN),
     *  SHIFT(NAT),SHIFTSA(NSHELL),SHIFTSB(NSHELL)
      DOUBLE PRECISION, INTENT(INOUT) :: WRKH(L2),WRKS(L2),WRK(*),
     *  WRK1(*)
      INTEGER, INTENT(IN) :: NI,KI,IND(*),NSPE,
     *                       INDSH(*),INDSAO(*),ISPE(NAT),MAXANG(NSPE)
      LOGICAL, INTENT(IN) :: SCC,SRSCC,UHF
C
      DOUBLE PRECISION :: AU(9,9),BU(9,9),V(3)
      INTEGER :: NSEQ,NJ,M,N,MU,NU,ISPIN
      LOGICAL :: SKP
C
      CALL VCLR(WRKH,1,L2)
      CALL VCLR(WRKS,1,L2)
      DO NJ = 1, NAT
        IF (NI.EQ.NJ) CYCLE
C       CALL VCLR(AU,1,81)
C       CALL VCLR(BU,1,81)
        CALL DFTB_DISPLACEMENT(NI,NJ,KI,0,V,C,0)
        CALL DFTB_SKODE_HELPA(1,NI,NJ,KI,0,V,AU,BU,.TRUE.,.TRUE.,SKP)
        IF (SKP) CYCLE
        DO N = 1, IND(NJ+1) - IND(NJ)
          NU = IND(NJ)+N
          DO M = 1, IND(NI+1) - IND(NI)
            MU = IND(NI)+M
            CALL DFTB_CNVSQ(MU,NU,NSEQ)
            WRKH(NSEQ) = AU(M,N)
            WRKS(NSEQ) = BU(M,N)
          END DO
        END DO
      END DO
C
      !! HDERMO
      DO ISPIN = 1, NSPIN
        CALL TFTRI0(HDERMO(1,ISPIN),WRKH,VEC(1,1,ISPIN),WRK,L0,L1,L1)
      END DO
C
      !! SDERMO
      DO ISPIN = 1, NSPIN
        CALL TFTRI0(SDERMO(1,ISPIN),WRKS,VEC(1,1,ISPIN),WRK,L0,L1,L1)
      END DO
C
      IF (SCC) THEN
        !! SAVE SDERAO
        CALL DCOPY(L2,WRKS,1,SDERAO,1)
        IF (UHF.OR.SRSCC) THEN
          CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *      INDSAO,NSPE,ISPE,MAXANG,SHIFTSA,SDERAO,WRKS)
        ELSE
          CALL SHIFT_TRIANGLE_DER(NAT,NI,L2,IND,SHIFT,
     *         SDERAO,WRKS)
        END IF
        CALL TFTRI0(WRK1,WRKS,VEC,WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
        CALL VADD(WRK1,1,HDERMO,1,HDERMO,1,L2)
        IF (UHF) THEN
          CALL SHIFT_TRIANGLE_DER_SHELL(NAT,NI,L2,IND,INDSH,
     *       INDSAO,NSPE,ISPE,MAXANG,SHIFTSB,SDERAO,WRKS)
          CALL TFTRI0(WRK1,WRKS,VEC(1,1,2),WRK,L0,L1,L1) !! WRK1 = V_{IJ}^a
          CALL VADD(WRK1,1,HDERMO(1,2),1,HDERMO(1,2),1,L2)
        END IF
      END IF
C
      END SUBROUTINE DFTB_HESS_DIRECT
