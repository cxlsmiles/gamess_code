C 29 Sep 14 - YN  - Implement Density-Functional Tight-Binding Method
C
C*MODULE DFTBLB    *DECK DFTB_INPUT
C>
C>    @brief Read and prepare DFTB input information
C>
C>    @details Read input information from $DFTB directive.
C>             Read the location of Slater-Koster files from $DFTBSK
C>             directive, and then store parameters to parameters in
C>             SKTAB common block.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C
C     DETAILS OF OVERALL IMPLEMENTATION OF DFTB IN GAMESS
C
C     The code of DFTB part comes from so called as Padreborn DFTB,
C     which is sometimes called old DFTB.  Therefore, the implementation
C     is different from DFTB+.
C     YN acknowledge authors of Paderborn DFTB,
C       P. Blaudeck, D. Porezag, G. Jungnickel, J. Elsner, M. Haugk,
C       Th. Frauenheim, G. Seifert, and M. Elstner
C
C     Possible References:
C     NCC-DFTB (DFTB1)
C       Porezag, D. et al. Phys. Rev. B 1995, 51, 12947-12957.
C       Seiferg, G. et al. Int. J. Quantum Chem. 1996, 58, 185-192.
C     SCC-DFTB (DFTB2)
C       Elstner, M. et al. Phys. Rev. B 1998, 58, 7260-7268.
C     DFTB3
C       Gaus, M. et al. J. Chem. Theory Comput. 2011, 7, 931-948.
C
C     Memo of DFTB specific dictionary files
C     556 :: Atom-resolved Mulliken population
C     557 :: Shell-resolved Mulliken population
C     558 :: Shell-resolved spin population
C     559 :: Atom-resolved shift contribution
C     560 :: Shell-resolved shift contribution
C     561 :: Shell-resolved spin shift contribution
C     562 :: Occupation number (Alpha)
C     563 :: Occupation number (Beta)
C     564 :: Non-perturbed Hamiltonian (only in FMO-DFTB)
C     565 :: Contribution of Hybrid orbital projection (only in FMO-DFTB)
C     566 :: Atom-resolved shift contribution of ESP (only in FMO-DFTB)
C     567 :: Atom-resolved shift contribution of ESP (only in FMO-DFTB3)
C
      SUBROUTINE DFTB_INPUT
C
      IMPLICIT NONE
C
      INTEGER,PARAMETER :: MXATM=5000, MXSPE=10, MXAO=2047
      INTEGER,PARAMETER :: MXTAB=1500, MXINT=150, MXSH=1000
      INTEGER,PARAMETER :: MXGTOT=5000
C
      COMMON /BASSPH/ QMTTOL,ISPHER
      DOUBLE PRECISION :: QMTTOL
      INTEGER :: ISPHER
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
C
      COMMON /DFTBMX/ SIMPLE,ITYPMX,TBROYDEN
      DOUBLE PRECISION :: SIMPLE
      INTEGER :: ITYPMX
      LOGICAL :: TBROYDEN
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
C
      COMMON /DFTBSK/ SKHTAB(10,MXTAB,MXSPE,MXSPE),
     &                SKSTAB(10,MXTAB,MXSPE,MXSPE),SKSELF(3,MXSPE),
     &                SKGRID(MXSPE,MXSPE),SKDIM(MXSPE,MXSPE),
     *                SKSPIN(MXSPE),REPCOEFF(6,MXINT,MXSPE,MXSPE),
     *                REPINTV(2,MXINT,MXSPE,MXSPE),
     &                REPSHORT(3,MXSPE,MXSPE),REPCUT(MXSPE,MXSPE),
     &                QREFL(3,MXSPE),HUBBL(3,MXSPE),QREF(MXSPE),
     &                HUBB(MXSPE),SKCUT2,ZREF(MXATM),SPNCST(6,MXSPE),
     *                NUMREP(MXSPE,MXSPE)
      DOUBLE PRECISION :: SKHTAB,SKSTAB,SKSELF,SKGRID,SKDIM,SKSPIN,
     &  HUBBL,QREFL,REPCUT,REPINTV,REPSHORT,REPCOEFF,QREF,HUBB,SKCUT2,
     &  ZREF,SPNCST
      INTEGER :: NUMREP
C
      COMMON /DFTDC / DC,IDCVER,DCCHG,DCABC,DCSR,DCS6,DCS8,DCALP
      LOGICAL :: DC,DCCHG,DCABC
      INTEGER :: IDCVER
      DOUBLE PRECISION :: DCSR,DCS6,DCS8,DCALP
C
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D
      INTEGER :: LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,LGAMMAD,MODESD,
     *  MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D
C
C     COMMON /GDDI/   ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP,
C    *                ISGDDI,PAROUT,INITGDDI,wasgddi
C     INTEGER :: ISCOPE,NGROUPS,MYGROUP,MEGLOB,NPGLOB,NNGLOB,JBTYP
C     LOGICAL :: ISGDDI,PAROUT,INITGDDI,WASGDDI
C
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     & ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      INTEGER :: NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      INTEGER :: IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA
C
      COMMON /MASSES/ ZMASS(MXATM)
      DOUBLE PRECISION :: ZMASS
C
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      DOUBLE PRECISION :: EX,CS,CP,CD,CF,CG,CH,CI
      INTEGER :: KSTART,KATOM,KTYPE,KNG,KLOC,KMIN,KMAX,NSHELL
C
      COMMON /RUNLAB/ TITLE(10),ANAM(MXATM),B(MXATM),BFLAB(MXAO)
      DOUBLE PRECISION :: TITLE,ANAM,B,BFLAB
C     character*8 a(MXATM)
C     EQUIVALENCE (a,anam)
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      INTEGER :: ME,MASTER,NPROC,IBTYP,IPTIM
      LOGICAL :: GOPARR,DSKWRK,MASWRK
C
      INTEGER :: I, J, IEOF, JRET, NRET, NFTDFTB, NDER, NSK, NDFTB, NUMA
      DOUBLE PRECISION :: DFTBD
      CHARACTER(4)   :: C4
      CHARACTER(8)   :: DUM1, DUM2, SP1, SP2
      CHARACTER(150) :: DUM3,SKPATH(MXSPE,MXSPE)
      DOUBLE PRECISION C8/8H        /,NONE/8HNONE    /,UFF/8HUFF     /,
     *                 LJ/8HLJ      /,SK/8HSK      /,DFT/8HDFT     /

      LOGICAL :: SKJUDGE(MXSPE,MXSPE)
C
C       ----- SET UP NAMELIST $DFTB TABLES -----
C
C NNAM : NUMBER OF ARGUMENTS TO READ
C DFTB : ONLY CONTAINS "DFTB    " CHARACTERS
C QNAM : ARGUMENTS TO READ (CHARACTERS)
C KQNAM : SEE NAMEIO SUBROUTINE in nameio.src (46-675)
C
C SCC (LOGICAL) : SCC (TRUE) OR NCC (FALSE)
C SRSCC (LOGICAL) : SHELL-RESOLVED SCC, USES DIFFERENT HUBBARD VALUES
C   FOR DIFFERENT SHELLS
C
      INTEGER,PARAMETER      :: NNAM = 18
      CHARACTER(8),PARAMETER :: CHDFTB = "DFTB    "
      CHARACTER(8)           :: QNAM(NNAM)
      INTEGER                :: KQNAM(NNAM)
      LOGICAL :: PRTORB

      ISPHER = 1 !! FORCE TO USE 5D.  THIS IS ONLY CHIOCE FOR DFTB.
      IF (MASWRK) THEN
        WRITE (IW,*)
        WRITE (IW,*)
     *    " **********************************************************"
        WRITE (IW,*)
     *    " **  DENSITY-FUNCTIONAL TIGHT-BINDING (DFTB) CALCULATION **"
        WRITE (IW,*)
     *    " **********************************************************"
        WRITE (IW,*)
     *    "       WRITTEN BY YOSHIO NISHIMOTO (NAGOYA UNIVERSITY)"
        WRITE (IW,*)
      END IF
      QNAM( 1) = "SCC     "
      QNAM( 2) = "ETEMP   "
      QNAM( 3) = "BROYDN  "
      QNAM( 4) = "ITYPMX  "
      QNAM( 5) = "MODESD  "
      QNAM( 6) = "MODGAM  "
      QNAM( 7) = "DISP    "
      QNAM( 8) = "DISPPR  "
      QNAM( 9) = "DFTB3   "
      QNAM(10) = "DAMPXH  "
      QNAM(11) = "DAMPEX  "
      QNAM(12) = "HUBDER  "
      QNAM(13) = "LRDFTB  "
      QNAM(14) = "PRTORB  "
      QNAM(15) = "SPNCST  "
      QNAM(16) = "SRSCC   "
      QNAM(17) = "MAXANG  "
      QNAM(18) = "NDFTB   "
C     0 : LOGICAL
C     1 : INTEGER
C     3 : DOUBLE PRECISION
C     5 : CHARACTERS
      KQNAM( 1) = 0
      KQNAM( 2) = 3
      KQNAM( 3) = 0
      KQNAM( 4) = 1
      KQNAM( 5) = 1
      KQNAM( 6) = 1
      KQNAM( 7) = 5
      KQNAM( 8) = 3 + 3*MXSPE*10 !! 3 may be replace with 14 later
      KQNAM( 9) = 0
      KQNAM(10) = 0
      KQNAM(11) = 3
      KQNAM(12) = 3 + MXSPE*10
      KQNAM(13) = 0
      KQNAM(14) = 0
      KQNAM(15) = 3 + 6*MXSPE*10
      KQNAM(16) = 0
      KQNAM(17) = 1
      KQNAM(18) = 1
C
      MODESD    = 0
      MODGAMMA  = 0
      DFTBD     = NONE
      DFTB3     = .FALSE.
      DAMPXH    = .FALSE.
      DAMPXHE   = 4.2D+00 !! (See JCTC 2011 7 931-948)
      LRDFTB    = .FALSE.
      PRTORB    = .FALSE.
      SRSCC     = .FALSE.
      NDFTB     = 0
      CALL VCLR(SPNCST,1,6*MXSPE)
      DO I = 1, MXSPE
        HUBDER(I) = 1.0D+06
      END DO
      DO I = 1, 14*MXSPE
        DFTBDP(I) = 1.0D+06
      END DO
C
C       COUNT HOW MANY SPECIES EXIST,
C       AND GET THESE SEPARATE SPECIES
C
      NSPE = 0
C     INITIALIZE SPE MATRIX
      DO I = 1, NAT
        SPE(I) = C8
      END DO
C
      DO I = 1, NAT
        IF (I.EQ.1) THEN
          NSPE = NSPE + 1
          SPE(NSPE) = ANAM(1)
          ISPE(I) = NSPE
        ELSE
          DO J = 1, NAT
            IF (ANAM(I)==SPE(J)) THEN
              ISPE(I) = J
              EXIT
            END IF
            IF (J.GT.NSPE) THEN
              NSPE = NSPE + 1
              SPE(NSPE) = ANAM(I)
              ISPE(I) = NSPE
              EXIT
            END IF
          END DO
        END IF
      END DO
      SPE(NSPE+1:NAT) = C8
      KQNAM(17) = KQNAM(17) + NSPE*10
C
C       ----- INITIALIZE VARIABLES FOR NAMELIST $DFTB -----
C
      SCC      = .TRUE.
      ETEMP    =  0.0D+00
      ITYPMX   = 0  !! BROYDEN'S METHOD BY DEFAULT
      DO I = 1, NSPE
        MAXANG(I) = -1
      END DO
C
C     CALL SEQOPN(IR,'INPUT','OLD',.TRUE.,'FORMATTE')
      IEOF = 0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $DFTB  ',IEOF)
      IF (IEOF.EQ.1) THEN
        IF (MASWRK) WRITE (IW,*) "$DFTB KEYWORD NOT FOUND"
        GO TO 10
      END IF
C
      JRET = 0
      CALL NAMEIO(IR,JRET,CHDFTB,NNAM,QNAM,KQNAM,
     &     SCC,ETEMP,TBROYDEN,ITYPMX,MODESD,
     &     MODGAMMA,DFTBD,DFTBDP,DFTB3,DAMPXH,
     &     DAMPXHE,HUBDER,LRDFTB,PRTORB,SPNCST,
     &     SRSCC,MAXANG,NDFTB,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0,0,
     &     0,0,0,0)
      IF (JRET.EQ.2) THEN
        IF (MASWRK) WRITE (IW,'(" TYPING ERROR IN $DFTB INPUT")')
        CALL ABRT
      END IF
C
C     SET DEFAULT MAXIMUM ANGULAR MOMENTUM
C
   10 CONTINUE
      IF (MASWRK) WRITE (IW,'(" NUMBER OF SPECIES:",I3)') NSPE
      DO I = 1, NSPE
        IF (MAXANG(I).EQ.-1) THEN
          CALL DFTB_RMNUM(SPE(I),DUM1)
          CALL UPRCAS(DUM1,8)
          CALL DFTB_CONV_AN(NUMA,DUM1)
          IF (NUMA.EQ. 1) MAXANG(I) = 1 !! H
          IF (NUMA.EQ. 2) MAXANG(I) = 1 !! HE
          IF (NUMA.EQ. 3) MAXANG(I) = 2 !! LI
          IF (NUMA.EQ. 4) MAXANG(I) = 2 !! BE
          IF (NUMA.EQ. 5) MAXANG(I) = 2 !! B
          IF (NUMA.EQ. 6) MAXANG(I) = 2 !! C
          IF (NUMA.EQ. 7) MAXANG(I) = 2 !! N
          IF (NUMA.EQ. 8) MAXANG(I) = 2 !! O
          IF (NUMA.EQ. 9) MAXANG(I) = 2 !! F
          IF (NUMA.EQ.10) MAXANG(I) = 2 !! NE
          IF (NUMA.EQ.11) MAXANG(I) = 2 !! NA
          IF (NUMA.EQ.12) MAXANG(I) = 2 !! MG
          IF (NUMA.EQ.13) MAXANG(I) = 3 !! AL
          IF (NUMA.EQ.14) MAXANG(I) = 3 !! SI
          IF (NUMA.EQ.15) MAXANG(I) = 3 !! P
          IF (NUMA.EQ.16) MAXANG(I) = 3 !! S
          IF (NUMA.EQ.17) MAXANG(I) = 3 !! CL
          IF (NUMA.EQ.18) MAXANG(I) = 3 !! AR
          IF (NUMA.EQ.19) MAXANG(I) = 3 !! K
          IF (NUMA.EQ.20) MAXANG(I) = 3 !! CA
          IF (NUMA.EQ.21) MAXANG(I) = 3 !! SC
          IF (NUMA.EQ.22) MAXANG(I) = 3 !! TI
          IF (NUMA.EQ.23) MAXANG(I) = 3 !! V
          IF (NUMA.EQ.24) MAXANG(I) = 3 !! CR
          IF (NUMA.EQ.25) MAXANG(I) = 3 !! MN
          IF (NUMA.EQ.26) MAXANG(I) = 3 !! FE
          IF (NUMA.EQ.27) MAXANG(I) = 3 !! CO
          IF (NUMA.EQ.28) MAXANG(I) = 3 !! NI
          IF (NUMA.EQ.29) MAXANG(I) = 3 !! CU
          IF (NUMA.EQ.30) MAXANG(I) = 3 !! ZN
          IF (NUMA.EQ.31) MAXANG(I) = 3 !! GA
          IF (NUMA.EQ.32) MAXANG(I) = 3 !! GE
          IF (NUMA.EQ.33) MAXANG(I) = 3 !! AS
          IF (NUMA.EQ.34) MAXANG(I) = 3 !! SE
          IF (NUMA.EQ.35) MAXANG(I) = 2 !! BR
          IF (NUMA.EQ.36) MAXANG(I) = 3 !! KR
          IF (MAXANG(I).EQ.0) THEN
          WRITE (IW,'(" ERROR FOUND WHILE LOOKING FOR MAXANG FOR ",A8)')
     *        SPE(I)
            CALL ABRT
          END IF
          IF (MASWRK) THEN
            IF (MAXANG(I).EQ.1) THEN
              WRITE (IW,'("        SPECIES",I2," :  ",A8,
     *          "WITH S     ORBITAL")')  I, SPE(I)
            ELSE IF (MAXANG(I).EQ.2) THEN
              WRITE (IW,'("        SPECIES",I2," :  ",A8,
     *          "WITH S+P   ORBITALS")') I, SPE(I)
            ELSE IF (MAXANG(I).EQ.3) THEN
              WRITE (IW,'("        SPECIES",I2," :  ",A8,
     *          "WITH S+P+D ORBITALS")') I, SPE(I)
            END IF
          END IF
        ELSE
          IF (MASWRK) THEN
            IF (MAXANG(I).EQ.1) THEN
              WRITE (IW,'("        SPECIES",I2," :  ",A8,
     *          "WITH S     ORBITAL  (USER DEFINED)")') I, SPE(I)
            ELSE IF (MAXANG(I).EQ.2) THEN
              WRITE (IW,'("        SPECIES",I2," :  ",A8,
     *          "WITH S+P   ORBITALS (USER DEFINED)")') I, SPE(I)
            ELSE IF (MAXANG(I).EQ.3) THEN
              WRITE (IW,'("        SPECIES",I2," :  ",A8,
     *          "WITH S+P+D ORBITALS (USER DEFINED)")') I, SPE(I)
            END IF
          END IF
        END IF
      END DO
      IF (MASWRK) WRITE (IW,*)
C
C       CALCULATION OF INDICES FOR MATRICES H AND S
C
      IND(1) = 0
      DO I = 1, NAT
        IND(I+1) = IND(I) + MAXANG(ISPE(I))**2
      END DO
C
C       CALCULATE THE NUMBER OF SHELLS
C
      DO I = 1, NAT
        NSHELL = NSHELL + MAXANG(ISPE(I))
      END DO
C
      NUM  = IND(NAT+1)
      NQMT = IND(NAT+1)
C
C     CHECK NDFTB VALUE
C
      IF (NDFTB.EQ.1) THEN
        IF (SCC.OR.DFTB3) THEN
          IF (MASWRK)
     *      WRITE (IW,'(" NDFTB=1 IS IMCOMPATIBLE WITH SCC OR DFTB3")')
          CALL ABRT
        END IF
        SCC = .FALSE.
        DFTB3 = .FALSE.
      ELSE IF (NDFTB.EQ.2) THEN
        IF (DFTB3) THEN
        IF (MASWRK) WRITE (IW,'(" NDFTB=2 IS IMCOMPATIBLE WITH DFTB3")')
          CALL ABRT
        END IF
C       IF (.NOT.SCC.AND.MASWRK)
C    *    WRITE (IW,'(" TURNING ON SCC BY NDFTB=2")')
        SCC = .TRUE.
        DFTB3 = .FALSE.
      ELSE IF (NDFTB.EQ.3) THEN
C       IF (.NOT.SCC.AND.MASWRK)
C    *    WRITE (IW,'(" TURNING ON SCC BY NDFTB=3")')
C       IF (.NOT.DFTB3.AND.MASWRK)
C    *    WRITE (IW,'(" TURNING ON DFTB3 BY NDFTB=3")')
        SCC = .TRUE.
        DFTB3 = .TRUE.
      ELSE
        NDFTB = 2 !! SCC-DFTB BY DEFAULT
        IF (.NOT.SCC) NDFTB = 1
        IF (DFTB3) NDFTB = 3
      END IF
      IF (.NOT.DAMPXH) DAMPXHE = 0.0D+00
C
C     PRINT DFTB OPTIONS
C
      IF (MASWRK) THEN
        WRITE (IW,'("     $DFTB OPTIONS")')
        WRITE (IW,'("     -------------")')
        WRITE (IW,'(" NDFTB =",I8,4X,   " SCC   =",L8,4X,
     *              " DFTB3 =",L8      )') NDFTB,SCC,DFTB3
        WRITE (IW,'(" SRSCC =",L8,4X,   " DAMPXH=",L8,4X,
     *              " DAMPEX=",F8.2    )') SRSCC,DAMPXH,DAMPXHE
        WRITE (IW,'(" DISP  =",A8,4X,   " ITYPMX=",I8,4X,
     *              " ETEMP =",F8.2    )') DFTBD,ITYPMX,ETEMP
        WRITE (IW,'(" MODESD=",I8,4X,   " MODGAM=",I8,4X,
     *              " PRTORB=",L8      )') MODESD,MODGAMMA,PRTORB
        WRITE (IW,*)
      END IF
C
C     DAMP DFTB OPTIONS
C
      IF (MASWRK) THEN
        IF (.NOT.SCC.AND.(DFTB3.OR.DAMPXH)) THEN
         WRITE (IW,'(" NCC-DFTB IS IMCOMPATIBLE WITH DFTB3 OR DAMPXH")')
         CALL ABRT
        END IF
        IF (SCC) THEN
          WRITE (IW,'(" --- SCC CALCULATION ---")')
          IF (DFTB3) THEN
            WRITE (IW,'("     INCLUDE 3RD ORDER CORRECTION")')
            CALL DFTB_3RD_PARAM(NSPE,SPE,HUBDER,IW,MASWRK)
          END IF
          IF (DAMPXH) THEN
            WRITE (IW,'("     USE X-H DAMPING: ",F8.5)') DAMPXHE
          END IF
        ELSE IF (.NOT.SCC) THEN
          WRITE (IW,'(" --- NCC CALCULATION ---")')
        END IF
        WRITE (IW,*)
      END IF
C
C     MIXING METHOD
C
      IF (ITYPMX.GT.3.OR.ITYPMX.LT.-1.OR.ITYPMX.EQ.1) THEN
        IF (MASWRK) WRITE (IW,*) "UNKNOWN ITYPMX ... CHANGED TO -1"
        ITYPMX = -1
      END IF
      IF (MASWRK) THEN
        IF (ITYPMX.EQ.0)
     *    WRITE (IW,'(" BROYDEN''S CHARGE MIXING")')
C       IF (ITYPMX.EQ.1)
C    *    WRITE (IW,'(" ANDERSON''S CHARGE MIXING WILL BE USED.")')
        IF (ITYPMX.EQ.2)
     *    WRITE (IW,'(" DIIS CHARGE UPDATE")')
        IF (ITYPMX.EQ.3)
     *    WRITE (IW,'(" SIMPLE CHARGE MIXING")')
        IF (ITYPMX.EQ.-1)
     *    WRITE (IW,'(" GAMESS STANDARD SUBROUTINES")')
      END IF
C
C     CHECK IF SPHERICALLY-RESOLVED SCC (SASCC) OR SHELL-RESOLVED
C     SCC (SRSCC).  SASCC IS DEFAULT CHOICE.
C     IT SHOULD NOT BE COMBINED WITH EITHER NCC OR DFTB3 (NOW)
C
      IF (SRSCC.AND..NOT.SCC) THEN
        IF (MASWRK) WRITE (IW,*)"NCC-DFTB CANNOT BE COMBINED WITH SRSCC"
        CALL ABRT
      END IF
      IF (SRSCC.AND.DFTB3) THEN
        IF (MASWRK) WRITE (IW,*)"SRSCC AND DFTB3 CANNOT BE COMBINED NOW"
        CALL ABRT
      END IF
C
C     CHECK DISPERSION CORRECTION
C
      DC = .FALSE.
      IDFTBD = 0
      IF (DFTBD.EQ.UFF.OR.DFTBD.EQ.LJ) THEN
        IDFTBD = 1
        DC = .TRUE.
        IF (MASWRK)
     *    WRITE (IW,'(" LENARD-JONES TYPE DISPERSION IS TURNED ON")')
      ELSE IF (DFTBD.EQ.SK) THEN
        IDFTBD = 2
        DC = .TRUE.
        IF (MASWRK)
     *    WRITE (IW,'(" SLATER-KIRKWOOD TYPE DISPERSION IS TURNED ON")')
      ELSE IF (DFTBD.EQ.DFT) THEN
        IDFTBD = 3
        DC = .TRUE.
        IF (MASWRK)
     *    WRITE (IW,'(" DFT-D[1,2,3] TYPE DISPERSION IS TURNED ON")')
        CALL DERCHK(NDER)
        IF (NDER.EQ.2) THEN
          WRITE (IW,'(" NDER.EQ.2 (HESSIAN) IS NOT AVAILABLE")')
          CALL ABRT
        END IF
      ELSE IF (DFTBD.NE.NONE) THEN
        WRITE (IW,'(" ''DISP'' IS NOT RECOGNIZED.")')
        CALL ABRT
      END IF
C
      IF (DC) THEN
        CALL DFTB_DISP_PARAM(DFTBDP,IW,NSPE,DFTBD,SPE,MASWRK)
C       DO I = 1, NSPE*14
C         IF (DFTBDP(I).NE.-1.0D+00) J = J + 1
C       END DO
C       WRITE (IW,'(" NUMBER OF DFTB-D PARAMETERS READ FROM INPUT =
C    * ",I3)') J
C       IF (DFTBD.EQ."UFF".OR.DFTBD.EQ."LJ") THEN
C         IF (J.NE.2*NSPE) THEN
C           WRITE (IW,'(" NUMBER OF PARAMETERS MAY BE WRONG")')
C         END IF
C       ELSE IF (DFTBD.EQ."SK") THEN
C         IF (J.NE.14*NSPE.AND.J.NE.3*NSPE) THEN
C           WRITE (IW,'(" NUMBER OF PARAMETERS MAY BE WRONG")')
C         END IF
C       END IF
      END IF
C
C     READ SLATER-KOSTER TABLE FROM $DFTBSK SECTION
C
      IEOF = 0
      CALL SEQREW(IR)
      CALL FNDGRP(IR,' $DFTBSK',IEOF)
      IF (IEOF.EQ.1) THEN
        IF (MASWRK) THEN
          WRITE (IW,*) "$DFTBSK KEYWORD NOT FOUND"
          WRITE (IW,*)
     *      "APPROPRIATE PARAMETERS MUST EXIST IN $DFTBSK FOR DFTB"
        END IF
        CALL ABRT
      END IF

      SKJUDGE = .FALSE.
      NFTDFTB = 21
      SP1 = '        '
      SP2 = '        '
      NSK = 0
      if (.not.maswrk) goto 100
      DO
        READ (IR,*) DUM1,DUM2,DUM3
        CALL DFTB_SLKOCH(DUM1,NRET)
        IF (NRET.EQ.1) GOTO 100
        CALL UPRCAS(DUM1,8)
        CALL UPRCAS(DUM2,8)
        DO I = 1, NSPE
          DO J = 1, NSPE
C           SKPATH(I,J) = '' !! it must not exist
            WRITE (SP1,'(A8)') SPE(I)
            WRITE (SP2,'(A8)') SPE(J)
            IF ( (DUM1==SP1 .AND. DUM2==SP2) ) THEN !! this line has something to do with DDI error for parallel calculations.
c           IF ( (DUM1.EQ.SP1 .AND. DUM2.EQ.SP2) ) THEN !! this line has something to do with DDI error for parallel calculations.
              SKPATH(I,J) = ADJUSTL(TRIM(DUM3))
C             WRITE (*,*) I, J
C             WRITE (IW,'(X,A4," - ",A4," = ",A80)')
C    &               SP1, SP2, SKPATH(I,J)
              OPEN (NFTDFTB,FILE=ADJUSTL(TRIM(DUM3)),ERR=110)
              CLOSE (NFTDFTB)
              SKJUDGE(I,J) = .TRUE.
              NSK = NSK + 1
              GOTO 200
            END IF
          END DO
        END DO
C       WRITE (IW,*) "PROBLEM OCCURS IN READING SLATER-KOSTER FILES"
C       WRITE (IW,*) ADJUSTL(TRIM(DUM1))," OR ", ADJUSTL(TRIM(DUM2)),
C    &               " OR ",ADJUSTL(TRIM(DUM3)),"WERE NOT FOUND"
C       CALL ABRT
200   END DO

100   IF (MASWRK) THEN
        WRITE (IW,'(X,I3," SLATER-KOSTER FILES WILL BE READ")') NSK
        DO I = 1, NSPE
          DO J = 1, NSPE
C           IF (SKJUDGE(I,J).EQ..FALSE.) THEN
            IF (.NOT.SKJUDGE(I,J)) THEN
              WRITE (IW,'(X,"ERROR!")')
              WRITE (IW,'(X,A4," - ",A4,"
     &          HAS NOT BEEN READ CORRECTLY")') SPE(I),SPE(J)
              CALL ABRT
            END IF
C           WRITE (*,*) I, J
C           WRITE (IW,'(X,A4," - ",A4," = ",A80)')
C    &             SPE(I), SPE(J), ADJUSTL(SKPATH(I,J))
          END DO
        END DO
        WRITE (IW,*)
      END IF
C
      SKCUT2 = 0.0D+00
      IF (MASWRK) THEN
        WRITE (IW,*) " START TO READ SLATER-KOSTER FILES"
        WRITE (IW,*)
        DO I = 1, NSPE
          DO J = 1, NSPE
            CALL DFTB_SKTAB(I,J,SKPATH(I,J))
          END DO
        END DO
        I = 1
        CALL DFTB_SETLAB(I,C4)
      END IF
C
      IF (MASWRK) CALL DFTB_SPNCST(SPNCST,NSPE,MAXANG,IW,SPE)
C
      IF (GOPARR) THEN
        CALL DDI_BCAST(2354,'F',SKHTAB  ,10*MXTAB*MXSPE*MXSPE,MASTER)
        CALL DDI_BCAST(2355,'F',SKSTAB  ,10*MXTAB*MXSPE*MXSPE,MASTER)
        CALL DDI_BCAST(2356,'F',SKSELF  ,3*MXSPE             ,MASTER)
        CALL DDI_BCAST(2357,'F',SKGRID  ,MXSPE*MXSPE         ,MASTER)
        CALL DDI_BCAST(2358,'F',SKDIM   ,MXSPE*MXSPE         ,MASTER)
        CALL DDI_BCAST(2359,'F',SKSPIN  ,MXSPE               ,MASTER)
        CALL DDI_BCAST(2360,'F',REPCOEFF,6*MXINT*MXSPE*MXSPE ,MASTER)
        CALL DDI_BCAST(2361,'F',REPINTV ,2*MXINT*MXSPE*MXSPE ,MASTER)
        CALL DDI_BCAST(2362,'F',REPSHORT,3*MXSPE*MXSPE       ,MASTER)
        CALL DDI_BCAST(2363,'F',REPCUT  ,MXSPE*MXSPE         ,MASTER)
        CALL DDI_BCAST(2364,'F',QREFL   ,3*MXSPE             ,MASTER)
        CALL DDI_BCAST(2365,'F',HUBBL   ,3*MXSPE             ,MASTER)
        CALL DDI_BCAST(2366,'I',NUMREP  ,MXSPE*MXSPE         ,MASTER)
        CALL DDI_BCAST(2367,'F',QREF    ,MXSPE               ,MASTER)
        CALL DDI_BCAST(2368,'F',HUBB    ,MXSPE               ,MASTER)
        CALL DDI_BCAST(2369,'F',SKCUT2  ,1                   ,MASTER)
        CALL DDI_BCAST(2370,'I',ITYPMX  ,1                   ,MASTER)
        IF (DFTB3) CALL DDI_BCAST(2371,'F',HUBDER,NSPE       ,MASTER)
        I = 1
        IF (.NOT.MASWRK) CALL DFTB_SETLAB(I,DUM1)
      END IF
C
C         SET NUCLEAR CHARGES FOR ALL ATOMS
C
      CALL VCLR(ZREF,1,NAT)
      DO I = 1, NAT
        ZREF(I) = QREF(ISPE(I))
      END DO
      !! ADDED FOR SCRF BUT NOT CHECKED FOR OTHER PURPOSES
      CALL RAMS(ZMASS,0)
C
C     ----- CALCULATE NUMBER OF REFERENCE ELECTRONS -----
C
      NE = 0
      DO I = 1, NAT
        NE = INT(NE + ZREF(I) + 1.0D-02)
      END DO

C     NUM  = NORB !! NUMBER OF CARTESIAN BASIS FUNCTIONS
C     NQMT = NORB
      IF (MASWRK) THEN
        WRITE (IW,*)
        WRITE (IW,*) " FOLLOWING VALUES ARE ADAPTED TO DFTB!"
      END IF
C
C     CALL SEQREW(IR)
C     CALL SEQCLO(IR,'KEEP')
C
      IF (MASWRK.AND.PRTORB) THEN
        DO I = 1, NSPE
          IF (MAXANG(I).GT.2) THEN
            WRITE (IW,*) " PRTORB IS NOT AVAILABLE FOR D FUNCTIONS"
            CALL ABRT
          END IF
        END DO
        WRITE (IW,*) " NOTE THAT DFTB USES PSEUDO-SLATER TYPE ORBITALS"
        WRITE (IW,*) " THIS IS JUST FOR APPROXIMATION"
        CALL DFTB_SHOW_MINI(NAT,ISPE,MAXANG,ANAM,B)
      END IF
      CALL FLSHBF(IW)
      RETURN

110   WRITE (IW,'(" FAILED IN OPENING SLATER-KOSTER FILE:")')
      WRITE (IW,'(A80)') DUM3
      CALL ABRT

      END SUBROUTINE DFTB_INPUT
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_RMNUM
C>
C>    @brief Remove numbers, period, and comma from INC
C>
C>    @details Remove numbers, period, and comma from INC and put OUTC
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param INC Input characters
C>           --- OUTPUT ---
C>    @param OUTC Output characters, which should not contain numbers,
C>           period, and comma
C
      SUBROUTINE DFTB_RMNUM(INC,OUTC)
C
      IMPLICIT NONE
C
      CHARACTER(8), INTENT(IN) :: INC
      CHARACTER(8), INTENT(OUT) :: OUTC
C
      INTEGER :: I,II
      CHARACTER(8) :: TMP
      CHARACTER(12) :: CHARA,BLANK
      DATA CHARA /'.,1234567890'/
      DATA BLANK /'            '/
C
      TMP = INC
      DO I = 1, 8
        II = INDEX(CHARA,TMP(I:I))
        IF (II.GT.0) TMP(I:I) = BLANK(II:II)
      END DO
      II = LEN_TRIM(TMP)
      OUTC = INC(1:II)
C
      RETURN
C
      END SUBROUTINE DFTB_RMNUM
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_SPNCST
C>
C>    @brief Check input spin constants for DFTB
C>
C>    @details Check spin constants for DFTB, particularly if
C>             SCFTYP=ROHF and all spin constants are zero, program is
C>             going to use same-electron RO-DFTB
C>             Show spin constants
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param SPNCST Spin constant array
C>    @param NSPE Number of species
C>    @param MAXANG Maximum angular momentum of each species
C>    @param IW (6)
C>    @param SPE Name of each species
C
      SUBROUTINE DFTB_SPNCST(SPNCST,NSPE,MAXANG,IW,SPE)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NSPE
      DOUBLE PRECISION, INTENT(IN) :: SPNCST(6,NSPE),SPE(NSPE)
      INTEGER, INTENT(IN) :: MAXANG(NSPE),IW
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00
      DOUBLE PRECISION :: CHARA8
      INTEGER :: I,J
C
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      DOUBLE PRECISION :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,UHF
      INTEGER ::          MPLEVL,MPCTYP
c     CHARACTER(8) :: SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
c    *                MPLEVL,MPCTYP
      data UHF/8HUHF     /
C
      IF (SCFTYP.NE.UHF) RETURN
C
      DO I = 1, NSPE
        DO J = 1, 6
          IF (SPNCST(J,I).NE.ZERO) GO TO 100
        END DO
      END DO
C
      WRITE (IW,'(/"ALL SPIN CONSTANTS ARE ZERO")')
      WRITE (IW,'("RESULTS WILL BE SAME TO ROHF CALCULATION")')
C
      RETURN
C
100   WRITE (IW,'(/" SPIN CONSTANTS FOR UHF CALCULATION")')
      DO I = 1, NSPE
        CHARA8 = SPE(I)
        WRITE (IW,'(/3X,A8)') CHARA8
        IF (MAXANG(I).EQ.1) WRITE (IW,'(9X,"S")')
        IF (MAXANG(I).EQ.2) WRITE (IW,'(9X,"S",8X,"P")')
        IF (MAXANG(I).EQ.3) WRITE (IW,'(9X,"S",8X,"P",8X,"D")')
        WRITE (IW,'(3X,"S",1(X,F8.4))') SPNCST(1,I)
        IF (MAXANG(I).EQ.1) CYCLE
        WRITE (IW,'(3X,"P",2(X,F8.4))') (SPNCST(J,I),J=2,3)
        IF (MAXANG(I).EQ.2) CYCLE
        WRITE (IW,'(3X,"D",3(X,F8.4))') (SPNCST(J,I),J=4,6)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SPNCST
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_SPNCST
C>
C>    @brief Find "$" character
C>
C>    @details Finds "$" character in the STR argument.  This is used
C>             only to detect the end of $DFTBSK directive
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param STR Input character
C>           --- OUTPUT ---
C>    @param NRET (Integer) if STR contains "$" character, return with 1
C
      SUBROUTINE DFTB_SLKOCH(STR,NRET)

      IMPLICIT NONE

      CHARACTER(*),INTENT(IN) :: STR
      INTEGER,INTENT(OUT) :: NRET

      INTEGER :: I

      NRET = 0
      DO I = 1, LEN_TRIM(STR)
        IF (STR(I:I).EQ."$") NRET = 1
      END DO

      RETURN

      END SUBROUTINE DFTB_SLKOCH
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_NUCZ
C>    @brief Subtract frozen core-electrons for DFTB
C>
C>    @details DFTB does not use inner shells.  Therefore they have to
C>             be removed to calculate Mulliken charges.
C>             For instance, atomic number of C is 6, however is 4
C>             in DFTB.
C>             In FMO-DFTB calculation, "FMOZAN" is wrong for DFTB,
C>             therefore the call of this subroutine from fmoprop
C>             subroutine always have to correct ZI number (IMODE=2).
C>             On the other hand, "ZAN" array is correct for FMO-DFTB,
C>             so the call from MULKEN subroutine should not do
C>             anything (IMODE=1 and NFG.NE.0).  Normal DFTB calculation
C>             uses incorrect "ZAN" array, so this sobroutine has to
C>             correct ZI (IMODE=1 and NFG=0).
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- IN/OUT PUT ---
C>    @param ZI (in) atomic number (out) nuclear charge of DFTB
C>    @param IMODE See above
C>
C
      SUBROUTINE DFTB_NUCZ(ZI,IMODE)
C
      IMPLICIT NONE
C
      common /fmoinf/ nfg,nlayer,natfmo,nbdfg,naotyp,nbody
      integer nfg,nlayer,natfmo,nbdfg,naotyp,nbody
C
      DOUBLE PRECISION, INTENT(INOUT) :: ZI
      INTEGER, INTENT(IN) :: IMODE
C
      IF (IMODE.EQ.1.AND.NFG.NE.0) RETURN
C
      IF (ZI.LE.2.0D+00) THEN
        RETURN
      ELSE IF (ZI.LE.1.0D+01) THEN !! SECOND ROW
        ZI = ZI - 2.0D+00
      ELSE IF (ZI.LE.1.8D+01) THEN
        ZI = ZI - 1.0D+01
      ELSE IF (ZI.LE.3.6D+01) THEN
        ZI = ZI - 1.8D+01
      !! THE REST ARE TENTATIVE VALUES (HAVE TO BE CHECKED!)
      ELSE IF (ZI.LE.5.4D+01) THEN
        ZI = ZI - 3.6D+01
      ELSE IF (ZI.LE.8.6D+01) THEN
        ZI = ZI - 5.4D+01
      END IF

      RETURN

      END SUBROUTINE DFTB_NUCZ
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_DISP_PARAM
C>    @brief Put DFTB-D parameters
C>
C>    @details Put DFTB-D parameters.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param IW (6)
C>    @param NSPE Number of species
C>    @param SPE Name of species (character)
C>    @param DFTBD Type of dispersion correction (character)
C>    @param MASWRK ...
C>           --- OUTPUT ---
C>    @param DFTBDP DFTB-D parameters
C
      SUBROUTINE DFTB_DISP_PARAM(DFTBDP,IW,NSPE,DFTBD,SPE,MASWRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: IW,NSPE
      DOUBLE PRECISION, INTENT(IN) :: SPE(*),DFTBD
      DOUBLE PRECISION, INTENT(INOUT) :: DFTBDP(*)
      LOGICAL, INTENT(IN) :: MASWRK
C
      DOUBLE PRECISION, PARAMETER :: AA_AU = 1.889726D+00
      DOUBLE PRECISION, PARAMETER :: AA_AU3 = AA_AU**3
C     DOUBLE PRECISION, PARAMETER :: KCAL_AU = 1.593601372D-03
C     FOLLOWING VALUE IS USED IN DFTB+, MAYBE.
      DOUBLE PRECISION, PARAMETER :: KCAL_AU = 1.594668386D-03
      DOUBLE PRECISION, PARAMETER :: BIG = 1.0D+06
C
      INTEGER :: I,J,NUMA
      DOUBLE PRECISION :: CHARA8
      DOUBLE PRECISION UFF/8HUFF     /, LJ/8HLJ      /, SK/8HSK      /
C
C     STORE PARAMETERS OF DISTANCE AND ENERGY FOR DISPERSION
C     CORRECTION
C     ALL VALUES ARE CONVERTED INTO ATOMIC UNIT
C
      J = 1
      IF (DFTBD.EQ.UFF.OR.DFTBD.EQ.LJ) THEN
        IF (MASWRK) THEN
          WRITE (IW,'(/" SETTING PARAMETERS FOR UFF-TYPE DISPERSION")')
          WRITE (IW,'( " DISTANCE IN ANGSTROM, ENERGY IN KCAL/MOL"/)')
          WRITE (IW,'("               DISTANCE       ENERGY")')
        END IF
        !! REFERENCE
        !! J. Am. Chem. Soc. 1992, 114, 10024-10035.
        !! See Table I, and its 4th and 5th columns (nonbond distance
        !! and energy)
        DO I = 1, NSPE
          CALL DFTB_RMNUM(SPE(I),CHARA8)
          CALL UPRCAS(CHARA8,8)
          IF (DFTBDP(J+0).EQ.BIG.AND.DFTBDP(J+1).EQ.BIG) THEN
            CALL DFTB_CONV_AN(NUMA,CHARA8)
C           CHARA8 = SPE(I)
            IF (NUMA.EQ.1) THEN
              DFTBDP(J+0) = 2.886D+00*AA_AU
              DFTBDP(J+1) = 0.044D+00*KCAL_AU
            ELSE IF (NUMA.EQ.2) THEN
              DFTBDP(J+0) = 2.362D+00*AA_AU
              DFTBDP(J+1) = 0.056D+00*KCAL_AU
            ELSE IF (NUMA.EQ.3) THEN
              DFTBDP(J+0) = 2.451D+00*AA_AU
              DFTBDP(J+1) = 0.025D+00*KCAL_AU
            ELSE IF (NUMA.EQ.4) THEN
              DFTBDP(J+0) = 2.745D+00*AA_AU
              DFTBDP(J+1) = 0.085D+00*KCAL_AU
            ELSE IF (NUMA.EQ.5) THEN
              DFTBDP(J+0) = 4.083D+00*AA_AU
              DFTBDP(J+1) = 0.180D+00*KCAL_AU
            ELSE IF (NUMA.EQ.6) THEN
              DFTBDP(J+0) = 3.851D+00*AA_AU
              DFTBDP(J+1) = 0.105D+00*KCAL_AU
            ELSE IF (NUMA.EQ.7) THEN
              DFTBDP(J+0) = 3.660D+00*AA_AU
              DFTBDP(J+1) = 0.069D+00*KCAL_AU
            ELSE IF (NUMA.EQ.8) THEN
              DFTBDP(J+0) = 3.500D+00*AA_AU
              DFTBDP(J+1) = 0.060D+00*KCAL_AU
            ELSE IF (NUMA.EQ.9) THEN
              DFTBDP(J+0) = 3.364D+00*AA_AU
              DFTBDP(J+1) = 0.050D+00*KCAL_AU
            ELSE IF (NUMA.EQ.10) THEN
              DFTBDP(J+0) = 3.243D+00*AA_AU
              DFTBDP(J+1) = 0.042D+00*KCAL_AU
            ELSE IF (NUMA.EQ.11) THEN
              DFTBDP(J+0) = 2.983D+00*AA_AU
              DFTBDP(J+1) = 0.030D+00*KCAL_AU
            ELSE IF (NUMA.EQ.12) THEN
              DFTBDP(J+0) = 3.021D+00*AA_AU
              DFTBDP(J+1) = 0.111D+00*KCAL_AU
            ELSE IF (NUMA.EQ.13) THEN
              DFTBDP(J+0) = 4.499D+00*AA_AU
              DFTBDP(J+1) = 0.505D+00*KCAL_AU
            ELSE IF (NUMA.EQ.14) THEN
              DFTBDP(J+0) = 4.295D+00*AA_AU
              DFTBDP(J+1) = 0.402D+00*KCAL_AU
            ELSE IF (NUMA.EQ.15) THEN
              DFTBDP(J+0) = 4.147D+00*AA_AU
              DFTBDP(J+1) = 0.305D+00*KCAL_AU
            ELSE IF (NUMA.EQ.16) THEN
              DFTBDP(J+0) = 4.035D+00*AA_AU
              DFTBDP(J+1) = 0.274D+00*KCAL_AU
            ELSE IF (NUMA.EQ.17) THEN
              DFTBDP(J+0) = 3.947D+00*AA_AU
              DFTBDP(J+1) = 0.227D+00*KCAL_AU
            ELSE IF (NUMA.EQ.18) THEN
              DFTBDP(J+0) = 3.868D+00*AA_AU
              DFTBDP(J+1) = 0.185D+00*KCAL_AU
            ELSE IF (NUMA.EQ.19) THEN
              DFTBDP(J+0) = 3.812D+00*AA_AU
              DFTBDP(J+1) = 0.035D+00*KCAL_AU
            ELSE IF (NUMA.EQ.20) THEN
              DFTBDP(J+0) = 3.399D+00*AA_AU
              DFTBDP(J+1) = 0.238D+00*KCAL_AU
            ELSE IF (NUMA.EQ.21) THEN
              DFTBDP(J+0) = 3.295D+00*AA_AU
              DFTBDP(J+1) = 0.019D+00*KCAL_AU
            ELSE IF (NUMA.EQ.22) THEN
              DFTBDP(J+0) = 3.175D+00*AA_AU
              DFTBDP(J+1) = 0.017D+00*KCAL_AU
            ELSE IF (NUMA.EQ.23) THEN
              DFTBDP(J+0) = 3.144D+00*AA_AU
              DFTBDP(J+1) = 0.016D+00*KCAL_AU
            ELSE IF (NUMA.EQ.24) THEN
              DFTBDP(J+0) = 3.023D+00*AA_AU
              DFTBDP(J+1) = 0.015D+00*KCAL_AU
            ELSE IF (NUMA.EQ.25) THEN
              DFTBDP(J+0) = 2.961D+00*AA_AU
              DFTBDP(J+1) = 0.013D+00*KCAL_AU
            ELSE IF (NUMA.EQ.26) THEN
              DFTBDP(J+0) = 2.912D+00*AA_AU
              DFTBDP(J+1) = 0.013D+00*KCAL_AU
            ELSE IF (NUMA.EQ.27) THEN
              DFTBDP(J+0) = 2.872D+00*AA_AU
              DFTBDP(J+1) = 0.014D+00*KCAL_AU
            ELSE IF (NUMA.EQ.28) THEN
              DFTBDP(J+0) = 2.834D+00*AA_AU
              DFTBDP(J+1) = 0.015D+00*KCAL_AU
            ELSE IF (NUMA.EQ.29) THEN
              DFTBDP(J+0) = 3.495D+00*AA_AU
              DFTBDP(J+1) = 0.005D+00*KCAL_AU
            ELSE IF (NUMA.EQ.30) THEN
              DFTBDP(J+0) = 2.763D+00*AA_AU
              DFTBDP(J+1) = 0.124D+00*KCAL_AU
            ELSE IF (NUMA.EQ.31) THEN
              DFTBDP(J+0) = 4.383D+00*AA_AU
              DFTBDP(J+1) = 0.415D+00*KCAL_AU
            ELSE IF (NUMA.EQ.32) THEN
              DFTBDP(J+0) = 4.280D+00*AA_AU
              DFTBDP(J+1) = 0.379D+00*KCAL_AU
            ELSE IF (NUMA.EQ.33) THEN
              DFTBDP(J+0) = 4.230D+00*AA_AU
              DFTBDP(J+1) = 0.309D+00*KCAL_AU
            ELSE IF (NUMA.EQ.34) THEN
              DFTBDP(J+0) = 4.205D+00*AA_AU
              DFTBDP(J+1) = 0.291D+00*KCAL_AU
            ELSE IF (NUMA.EQ.35) THEN
              DFTBDP(J+0) = 4.189D+00*AA_AU
              DFTBDP(J+1) = 0.251D+00*KCAL_AU
            ELSE IF (NUMA.EQ.36) THEN
              DFTBDP(J+0) = 4.141D+00*AA_AU
              DFTBDP(J+1) = 0.220D+00*KCAL_AU
            ELSE
              WRITE (IW,*)
     *          "UNRECOGNIZED ATOMIC SYMBOL IN DFTB_DISP_PARAM"
              WRITE (IW,'(A,A8/)') "PARAMETERS ARE MISSING FOR ",CHARA8
              CALL ABRT
            END IF
            IF (MASWRK) WRITE (IW,'(X,A8,":",3X,F10.5,3X,F10.5)')
     *        CHARA8,DFTBDP(J)/AA_AU,DFTBDP(J+1)/KCAL_AU
          ELSE
            DFTBDP(J+0) = DFTBDP(J+0)*AA_AU
            DFTBDP(J+1) = DFTBDP(J+1)*KCAL_AU
            IF (MASWRK) WRITE (IW,'(X,A8,":",3X,F10.5,3X,F10.5,
     *        " (USER DEFINED)")')
     *        CHARA8,DFTBDP(J)/AA_AU,DFTBDP(J+1)/KCAL_AU
          END IF
          J = J + 2
        END DO
      ELSE IF (DFTBD.EQ.SK) THEN
        IF (MASWRK) THEN
          WRITE (IW,'(" SETTING PARAMETERS FOR SK-TYPE DISPERSION")')
        END IF
        DO I = 1, NSPE
          CALL DFTB_RMNUM(SPE(I),CHARA8)
          CALL UPRCAS(CHARA8,8)
          IF (DFTBDP(J).EQ.BIG.AND.DFTBDP(J+1).EQ.BIG.AND.
     *        DFTBDP(J+2).EQ.BIG) THEN
            CALL DFTB_CONV_AN(NUMA,CHARA8)
            WRITE (IW,*) "UNRECOGNIZED ATOMIC SYMBOL IN DFTB_DISP_PARAM"
            WRITE (IW,'(A,A8/)') " CHECK :: ", SPE(I)
            CALL ABRT
            IF (MASWRK)
     *        WRITE (IW,'(X,A8,":",3X,F10.5,3X,F10.5,3X,F10.5)')
     *        CHARA8,DFTBDP(J)/AA_AU3,DFTBDP(J+1)/AA_AU,DFTBDP(J+2)
          ELSE
            DFTBDP(J+0) = DFTBDP(J+0)*AA_AU3
            DFTBDP(J+1) = DFTBDP(J+1)*AA_AU
            DFTBDP(J+2) = DFTBDP(J+2)
            IF (MASWRK) WRITE (IW,'(X,A8,":",3X,F10.5,3X,F10.5,3X,F10.5,
     *        " (USER DEFINED)")')
     *        CHARA8,DFTBDP(J)/AA_AU3,DFTBDP(J+1)/AA_AU,DFTBDP(J+2)
          END IF
          J = J + 3
        END DO
      END IF
      WRITE (IW,*)
C
      END SUBROUTINE DFTB_DISP_PARAM
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_3RD_PARAM
C>    @brief Put DFTB3 parameters
C>
C>    @details Put DFTB3 parameters, which are called Hubbard derivative
C>             These are taken from the 3ob parameter set.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NSPE Number of species
C>    @param SPE Name of species (character)
C>    @param IW 6
C>    @param MASWRK ...
C>           --- OUTPUT ---
C>    @param HUBDER Hubbard derivatives
C
      SUBROUTINE DFTB_3RD_PARAM(NSPE,SPE,HUBDER,IW,MASWRK)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NSPE,IW,SPE(*)
      DOUBLE PRECISION, INTENT(INOUT) :: HUBDER(*)
      LOGICAL, INTENT(IN) :: MASWRK
C
      DOUBLE PRECISION :: CHARA8
      INTEGER :: I,J,NUMA
C
C     STORE PARAMETERS OF HUBBARD DERIVATIVES FOR 3RD ORDER CORRECTION
C     THE DEFAULT PARAMETERS ARE TAKEN FROM
C       Gaus, M.; Cui, Q.; Elstner, M. J. Chem. Theory Comput.
C       2011, 7, 931-948. (see Table 2)
C
      J = 1
      IF (MASWRK) THEN
        WRITE (IW,'(/" SETTING HUBBARD DERIVATIVES FOR DFTB3")')
      END IF
      DO I = 1, NSPE
        IF (HUBDER(I).EQ.1.0D+06) THEN
          CALL DFTB_RMNUM(SPE(I),CHARA8)
          CALL UPRCAS(CHARA8,8)
          CALL DFTB_CONV_AN(NUMA,CHARA8)
          IF (NUMA.EQ.1) THEN
            HUBDER(J) = -0.16D+00
          ELSE IF (NUMA.EQ.6) THEN
            HUBDER(J) = -0.23D+00
          ELSE IF (NUMA.EQ.7) THEN
            HUBDER(J) = -0.13D+00
          ELSE IF (NUMA.EQ.8) THEN
            HUBDER(J) = -0.19D+00
          ELSE IF (NUMA.EQ.15) THEN
            HUBDER(J) = -0.14D+00
          ELSE
            IF (MASWRK) THEN
              WRITE (IW,*)"UNRECOGNIZED ATOMIC SYMBOL IN DFTB_3RD_PARAM"
              WRITE (IW,'(A,A8/)') " OR PARAMETERS ARE MISSING FOR ",
     *          CHARA8
            END IF
            CALL ABRT
          END IF
          IF (MASWRK) WRITE (IW,'(X,A8,":",3X,F10.5)') SPE(I),HUBDER(J)
        ELSE
          IF (MASWRK) WRITE (IW,'(X,A8,":",3X,F10.5," (USER DEFINED)")')
     *      SPE(I),HUBDER(J)
        END IF
        J = J + 1
      END DO
C
      END SUBROUTINE DFTB_3RD_PARAM
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_SHOW_STO3G
C>    @brief Show MINI exponent and coefficients
C>
C>    @details Show MINI exponent and coefficients.  These are called
C>             by $DFTB PRTORB=.TRUE. $END., then it can be read by
C>             MacMolPlt program.
C>             Note that DFTB uses an kind of Slater-type orbital,
C>             so the projection to STO-3G orbital is just an
C>             approximation, hopefully good approximation.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param ZANINP nuclear charges on atomic table
C>    @param A Name of atoms
C>    @param B
C
      SUBROUTINE DFTB_SHOW_MINI(NAT,ISPE,MAXANG,A,B)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      CHARACTER(8) :: A(*),B(*)
      DIMENSION :: EX(3),CC(3)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(*)
C
      IW = 6
      WRITE (IW,9080)
      WRITE (IW,9090)
      WRITE (IW,9100)
      WRITE (IW,9110)
      NSHELL = 0
      NPRIM = 0
      DO IAT = 1, NAT
        WRITE (IW,9120) A(IAT),B(IAT)
        ISHELL = MAXANG(ISPE(IAT))
C       IF (NUCZ.LE.2) THEN
C         ISHELL = 1
C       ELSE IF (NUCZ.LE.10) THEN
C         ISHELL = 2
C       END IF
C       IPRIM = ISHELL*3
        DO ISH = 1, ISHELL
          NSHELL = NSHELL + 1
          CALL DFTB_PUT_MINI(A(IAT),ISH,EX,CC)
          DO IPR = 1, 3
            NPRIM = NPRIM + 1
            IF (ISH.EQ.1) THEN
              WRITE (IW,9130) NSHELL,"S",NPRIM,EX(IPR),CC(IPR)
            ELSE IF (ISH.EQ.2) THEN
              WRITE (IW,9130) NSHELL,"P",NPRIM,EX(IPR),CC(IPR)
            ELSE IF (ISH.EQ.3) THEN
              WRITE (IW,9130) NSHELL,"D",NPRIM,EX(IPR),CC(IPR)
            END IF
          END DO
          IF (ISH.NE.ISHELL) WRITE (IW,*)
        END DO
      END DO
C
 9080 FORMAT(/5X,'ATOMIC BASIS SET'/5X,16(1H-))
 9090 FORMAT(1X,'THE CONTRACTED PRIMITIVE FUNCTIONS HAVE BEEN',
     *          ' UNNORMALIZED')
 9100 FORMAT(1X,'THE CONTRACTED BASIS FUNCTIONS ARE NOW NORMALIZED',
     *          ' TO UNITY')
 9110 FORMAT(/1X,' SHELL TYPE  PRIMITIVE        EXPONENT',
     *       10X,'CONTRACTION COEFFICIENT(S)')
 9120 FORMAT(/1X,A8,A2/)
 9130 FORMAT(1X,I6,3X,A2,I7,F22.7, F18.12)
C9140 FORMAT(1X,I6,3X,A2,I7,F22.7,2F18.12)
C
      END SUBROUTINE DFTB_SHOW_MINI
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_PUT_MINI
C>    @brief Get MINI exponent and coefficients
C>
C>    @details Get MINI exponent and coefficients.  They are simply
C>             taken from outputs of calculations for isolated atom.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param A Name of atoms
C>    @param ISH Number of shells (s=1, p=2, d=3, ...)
C>    @param EX Exponent
C>    @param CC Contraction coefficients
C
      SUBROUTINE DFTB_PUT_MINI(A,ISH,EX,CC)
C
      IMPLICIT NONE
C
      CHARACTER(8),INTENT(IN) :: A
      INTEGER, INTENT(IN) :: ISH
      DOUBLE PRECISION, INTENT(OUT) :: EX(3),CC(3)
C
      CHARACTER(8) :: B
      INTEGER :: NUMA
C
      CALL DFTB_RMNUM(A,B)
      CALL DFTB_CONV_AN(NUMA,B)
C
      IF (NUMA.EQ.1) THEN
        EX(1) = 7.0340625D+00
        EX(2) = 1.0647563D+00
        EX(3) = 0.2365594D+00
        CC(1) = 0.070452003325D+00
        CC(2) = 0.407826019247D+00
        CC(3) = 0.647752030571D+00
      ELSE IF (NUMA.EQ.2) THEN
        EX(1) = 13.6267360D+00
        EX(2) = 1.9993490D+00
        EX(3) = 0.3829930D+00
        CC(1) = 0.080240952730D+00
        CC(2) = 0.409142758974D+00
        CC(3) = 0.657277612798D+00
      ELSE IF (NUMA.EQ.3) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 0.8512533D+00
          EX(2) = 0.0839505D+00
          EX(3) = 0.0325542D+00
          CC(1) = -0.09396993147D+00
          CC(2) = 0.570100058422D+00
          CC(3) = 0.499750063553D+00
        ELSE IF (ISH.EQ.2) THEN
          !! TENTATIVE !!
          EX(1) = 0.8512533D+00
          EX(2) = 0.0839505D+00
          EX(3) = 0.0325542D+00
          CC(1) = -0.09396993147D+00
          CC(2) = 0.570100058422D+00
          CC(3) = 0.499750063553D+00
        END IF
      ELSE IF (NUMA.EQ.4) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 2.3348562D+00
          EX(2) = 0.1969758D+00
          EX(3) = 0.0674494D+00
          CC(1) = -0.082820392502D+00
          CC(2) = 0.557552749521D+00
          CC(3) = 0.516042553279D+00
        ELSE IF (ISH.EQ.2) THEN
          !! TENTATIVE !!
          EX(1) = 2.3348562D+00
          EX(2) = 0.1969758D+00
          EX(3) = 0.0674494D+00
          CC(1) = -0.082820392502D+00
          CC(2) = 0.557552749521D+00
          CC(3) = 0.516042553279D+00
        END IF
      ELSE IF (NUMA.EQ.5) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 4.4578539D+00
          EX(2) = 0.3693150D+00
          EX(3) = 0.1225550D+00
          CC(1) = -0.082419195645D+00
          CC(2) = 0.559064370460D+00
          CC(3) = 0.516794772694D+00
        ELSE IF (ISH.EQ.2) THEN
          EX(1) = 3.2148920D+00
          EX(2) = 0.6461357D+00
          EX(3) = 0.1539156D+00
          CC(1) = 0.105900108350D+00
          CC(2) = 0.457180536048D+00
          CC(3) = 0.631860749821D+00
        END IF
      ELSE IF (NUMA.EQ.6) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 6.6166118D+00
          EX(2) = 0.5258556D+00
          EX(3) = 0.1699578D+00
          CC(1) = -0.081380500552D+00
          CC(2) = 0.574853203898D+00
          CC(3) = 0.502412803407D+00
        ELSE IF (ISH.EQ.2) THEN
          EX(1) = 4.9129201D+00
          EX(2) = 0.9976164D+00
          EX(3) = 0.2326851D+00
          CC(1) = 0.109930601675D+00
          CC(2) = 0.462712707051D+00
          CC(3) = 0.627513709563D+00
        END IF
      ELSE IF (NUMA.EQ.7) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 8.9194264D+00
          EX(2) = 0.7061408D+00
          EX(3) = 0.2250537D+00
          CC(1) = -0.080890299919D+00
          CC(2) = 0.567201999435D+00
          CC(3) = 0.511091799491D+00
        ELSE IF (ISH.EQ.2) THEN
          EX(1) = 6.5562719D+00
          EX(2) = 1.3490793D+00
          EX(3) = 0.3122085D+00
          CC(1) = 0.115919498304D+00
          CC(2) = 0.469958193126D+00
          CC(3) = 0.618447590954D+00
        END IF
      ELSE IF (NUMA.EQ.8) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 11.7893262D+00
          EX(2) = 0.9128941D+00
          EX(3) = 0.2866610D+00
          CC(1) = -0.080819896351D+00
          CC(2) = 0.582089473721D+00
          CC(3) = 0.497159577555D+00
        ELSE IF (ISH.EQ.2) THEN
          EX(1) = 8.2741400D+00
          EX(2) = 1.7154628D+00
          EX(3) = 0.3830133D+00
          CC(1) = 0.124270892747D+00
          CC(2) = 0.476593472182D+00
          CC(3) = 0.613044464218D+00
        END IF
      ELSE IF (NUMA.EQ.9) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 15.3647082D+00
          EX(2) = 1.1675456D+00
          EX(3) = 0.3631411D+00
          CC(1) = -0.080549895948D+00
          CC(2) = 0.587728970438D+00
          CC(3) = 0.491979175254D+00
        ELSE IF (ISH.EQ.2) THEN
          EX(1) = 10.7256673D+00
          EX(2) = 2.2258173D+00
          EX(3) = 0.4861047D+00
          CC(1) = 0.126269505768D+00
          CC(2) = 0.477948221832D+00
          CC(3) = 0.614007728047D+00
        END IF
      ELSE IF (NUMA.EQ.10) THEN
        IF (ISH.EQ.1) THEN
          EX(1) = 19.3271900D+00
          EX(2) = 1.4418200D+00
          EX(3) = 0.4440800D+00
          CC(1) = -0.080249695714D+00
          CC(2) = 0.595297668204D+00
          CC(3) = 0.484868074102D+00
        ELSE IF (ISH.EQ.2) THEN
          EX(1) = 13.3525200D+00
          EX(2) = 2.7794700D+00
          EX(3) = 0.6009700D+00
          CC(1) = 0.128840304208D+00
          CC(2) = 0.480441215691D+00
          CC(3) = 0.611671619976D+00
        END IF
      END IF
C
      END SUBROUTINE DFTB_PUT_MINI
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_CONV_AN
C>
C>    @brief Convert element name to atomic number
C>
C>    @details Convert element name to atomic number
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param CHARA8 Name of atom
C>           --- OUTPUT ---
C>    @param NUMA Atominuc Number
C
      SUBROUTINE DFTB_CONV_AN(NUMA,CHARA8)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(OUT) :: NUMA
      DOUBLE PRECISION, INTENT(IN) :: CHARA8
C
      DOUBLE PRECISION :: CTMP
      DOUBLE PRECISION
     *   H1/8H1       /,  H2/8HH       /,  H3/8HHYDROGEN/,
     *  HE1/8H2       /, HE2/8HHE      /, HE3/8HHELIUM  /,
     *  LI1/8H3       /, LI2/8HLI      /, LI3/8HLITHIUM /,
     *  BE1/8H4       /, BE2/8HBE      /, BE3/8HBERYLIUM/,
     *   B1/8H5       /,  B2/8HB       /,  B3/8HBORON   /,
     *   C1/8H6       /,  C2/8HC       /,  C3/8HCARBON  /,
     *   N1/8H7       /,  N2/8HN       /,  N3/8HNITROGEN/,
     *   O1/8H8       /,  O2/8HO       /,  O3/8HOXYGEN  /,
     *   F1/8H9       /,  F2/8HF       /,  F3/8HFLUORINE/,
     *  NE1/8H10      /, NE2/8HNE      /, NE3/8HNEON    /,
     *  NA1/8H11      /, NA2/8HNA      /, NA3/8HSODIUM  /,
     *  MG1/8H12      /, MG2/8HMG      /, MG3/8HMAGNESIU/,
     *  AL1/8H13      /, AL2/8HAL      /, AL3/8HALUMINIU/,
     *  SI1/8H14      /, SI2/8HSI      /, SI3/8HSILICON /,
     *   P1/8H15      /,  P2/8HP       /,  P3/8HPHOSPHOR/,
     *   S1/8H16      /,  S2/8HS       /,  S3/8HSULFUR  /,
     *  CL1/8H17      /, CL2/8HCL      /, CL3/8HCHLORINE/,
     *  AR1/8H18      /, AR2/8HAR      /, AR3/8HARGON   /,
     *   K1/8H19      /,  K2/8HK       /,  K3/8HPOTASIUM/,
     *  CA1/8H20      /, CA2/8HCA      /, CA3/8HCALCIUM /,
     *  SC1/8H21      /, SC2/8HSC      /, SC3/8HSCANDIUM/,
     *  TI1/8H22      /, TI2/8HTI      /, TI3/8HTITANIUM/,
     *   V1/8H23      /,  V2/8HV       /,  V3/8HVANADIUM/,
     *  CR1/8H24      /, CR2/8HCR      /, CR3/8HCHROMIUM/,
     *  MN1/8H25      /, MN2/8HMN      /, MN3/8HMANGANES/,
     *  FE1/8H26      /, FE2/8HFE      /, FE3/8HIRON    /,
     *  CO1/8H27      /, CO2/8HCO      /, CO3/8HCOBALT  /,
     *  NI1/8H28      /, NI2/8HNI      /, NI3/8HNICKEL  /,
     *  CU1/8H29      /, CU2/8HCU      /, CU3/8HCOPPER  /,
     *  ZN1/8H30      /, ZN2/8HZN      /, ZN3/8HZINC    /,
     *  GA1/8H31      /, GA2/8HGA      /, GA3/8HGALLIUM /,
     *  GE1/8H32      /, GE2/8HGE      /, GE3/8HGERMANIU/,
     *  AS1/8H33      /, AS2/8HAS      /, AS3/8HARSENIUM/,
     *  SE1/8H34      /, SE2/8HSE      /, SE3/8HSELENIUM/,
     *  BR1/8H35      /, BR2/8HBR      /, BR3/8HBROMINE /,
     *  KR1/8H36      /, KR2/8HKR      /, KR3/8HKRYPTON /
C
      CTMP = CHARA8
      IF (CTMP.EQ. H1.OR.CTMP.EQ. H2.OR.CTMP.EQ. H3) NUMA =  1
      IF (CTMP.EQ.HE1.OR.CTMP.EQ.HE2.OR.CTMP.EQ.HE3) NUMA =  2
      IF (CTMP.EQ.LI1.OR.CTMP.EQ.LI2.OR.CTMP.EQ.LI3) NUMA =  3
      IF (CTMP.EQ.BE1.OR.CTMP.EQ.BE2.OR.CTMP.EQ.BE3) NUMA =  4
      IF (CTMP.EQ. B1.OR.CTMP.EQ. B2.OR.CTMP.EQ. B3) NUMA =  5
      IF (CTMP.EQ. C1.OR.CTMP.EQ. C2.OR.CTMP.EQ. C3) NUMA =  6
      IF (CTMP.EQ. N1.OR.CTMP.EQ. N2.OR.CTMP.EQ. N3) NUMA =  7
      IF (CTMP.EQ. O1.OR.CTMP.EQ. O2.OR.CTMP.EQ. O3) NUMA =  8
      IF (CTMP.EQ. F1.OR.CTMP.EQ. F2.OR.CTMP.EQ. F3) NUMA =  9
      IF (CTMP.EQ.NE1.OR.CTMP.EQ.NE2.OR.CTMP.EQ.NE3) NUMA = 10
      IF (CTMP.EQ.NA1.OR.CTMP.EQ.NA2.OR.CTMP.EQ.NA3) NUMA = 11
      IF (CTMP.EQ.MG1.OR.CTMP.EQ.MG2.OR.CTMP.EQ.MG3) NUMA = 12
      IF (CTMP.EQ.AL1.OR.CTMP.EQ.AL2.OR.CTMP.EQ.AL3) NUMA = 13
      IF (CTMP.EQ.SI1.OR.CTMP.EQ.SI2.OR.CTMP.EQ.SI3) NUMA = 14
      IF (CTMP.EQ. P1.OR.CTMP.EQ. P2.OR.CTMP.EQ. P3) NUMA = 15
      IF (CTMP.EQ. S1.OR.CTMP.EQ. S2.OR.CTMP.EQ. S3) NUMA = 16
      IF (CTMP.EQ.CL1.OR.CTMP.EQ.CL2.OR.CTMP.EQ.CL3) NUMA = 17
      IF (CTMP.EQ.AR1.OR.CTMP.EQ.AR2.OR.CTMP.EQ.AR3) NUMA = 18
      IF (CTMP.EQ. K1.OR.CTMP.EQ. K2.OR.CTMP.EQ. K3) NUMA = 19
      IF (CTMP.EQ.CA1.OR.CTMP.EQ.CA2.OR.CTMP.EQ.CA3) NUMA = 20
      IF (CTMP.EQ.SC1.OR.CTMP.EQ.SC2.OR.CTMP.EQ.SC3) NUMA = 21
      IF (CTMP.EQ.TI1.OR.CTMP.EQ.TI2.OR.CTMP.EQ.TI3) NUMA = 22
      IF (CTMP.EQ. V1.OR.CTMP.EQ. V2.OR.CTMP.EQ. V3) NUMA = 23
      IF (CTMP.EQ.CR1.OR.CTMP.EQ.CR2.OR.CTMP.EQ.CR3) NUMA = 24
      IF (CTMP.EQ.MN1.OR.CTMP.EQ.MN2.OR.CTMP.EQ.MN3) NUMA = 25
      IF (CTMP.EQ.FE1.OR.CTMP.EQ.FE2.OR.CTMP.EQ.FE3) NUMA = 26
      IF (CTMP.EQ.CO1.OR.CTMP.EQ.CO2.OR.CTMP.EQ.CO3) NUMA = 27
      IF (CTMP.EQ.NI1.OR.CTMP.EQ.NI2.OR.CTMP.EQ.NI3) NUMA = 28
      IF (CTMP.EQ.CU1.OR.CTMP.EQ.CU2.OR.CTMP.EQ.CU3) NUMA = 29
      IF (CTMP.EQ.ZN1.OR.CTMP.EQ.ZN2.OR.CTMP.EQ.ZN3) NUMA = 30
      IF (CTMP.EQ.GA1.OR.CTMP.EQ.GA2.OR.CTMP.EQ.GA3) NUMA = 31
      IF (CTMP.EQ.GE1.OR.CTMP.EQ.GE2.OR.CTMP.EQ.GE3) NUMA = 32
      IF (CTMP.EQ.AS1.OR.CTMP.EQ.AS2.OR.CTMP.EQ.AS3) NUMA = 33
      IF (CTMP.EQ.SE1.OR.CTMP.EQ.SE2.OR.CTMP.EQ.SE3) NUMA = 34
      IF (CTMP.EQ.BR1.OR.CTMP.EQ.BR2.OR.CTMP.EQ.BR3) NUMA = 35
      IF (CTMP.EQ.KR1.OR.CTMP.EQ.KR2.OR.CTMP.EQ.KR3) NUMA = 36
C
      RETURN
C
      END SUBROUTINE DFTB_CONV_AN
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_CNVSQ
C>
C>    @brief Indexing for DFTB
C>
C>    @details Convert two values for symmetric square matrix to a value
C>             of upper triangular matrix in a sequantial manner
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C
      SUBROUTINE DFTB_CNVSQ(I,J,N)
C
      IMPLICIT NONE
C
      INTEGER :: I, J, N
C
C     CoNVert two values to a SeQuential value.
C
      IF (I.GE.J) THEN
        N = I*(I-1)/2 + J
      ELSE
        N = J*(J-1)/2 + I
      END IF
C
      END SUBROUTINE DFTB_CNVSQ
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_EREP
C>
C>    @brief Calculate Erep for DFTB
C>
C>    @details Calculate Erep (sum of repulsive potential energy)
C>             for DFTB
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param NAT Number of atoms
C>    @param C Coordinate
C>    @param ISPE Index of species
C>    @param NUMREP Number of grids for specific pairs
C>    @param REPCUT Cutoff distance for specific pairs
C>    @param REPINTV Lower and upper bound of each grid of repulsive
C>                   potential for specific pairs
C>    @param REPSHORT Coefficients (and exponent) for short range
C>                    respulsive potential
C>    @param REPSHORT Coefficients for medium (4 terms) and long (6
C>                    terms) range respulsive potential
C>    @param ZREF Nuclear charges of each atom
C>    @param QREF Reference nuclear charges of each species
C>           --- OUTPUT ---
C>    @param EREP Sum of repulsive energy
C>    @param DISTMAT Matrix of distance between each atom (up. triang.)
C>
C
      SUBROUTINE DFTB_EREP(NAT,C,ISPE,NSPE,NUMREP,REPCUT,
     & REPINTV,REPSHORT,REPCOEFF,EREP,DISTMAT,ZREF,QREF)
C
      IMPLICIT NONE
C
      INTEGER,PARAMETER :: MXINT=150
C
      INTEGER,INTENT(IN) :: NAT
      DOUBLE PRECISION,INTENT(IN) :: C(3,NAT)
      INTEGER,INTENT(IN) :: ISPE(NAT)
      INTEGER,INTENT(IN) :: NSPE
      INTEGER,INTENT(IN) :: NUMREP(NSPE,NSPE)
      DOUBLE PRECISION,INTENT(IN) :: REPCUT(NSPE,NSPE)
      DOUBLE PRECISION,INTENT(IN) :: REPINTV(2,MXINT,NSPE,NSPE)
      DOUBLE PRECISION,INTENT(IN) :: REPSHORT(3,NSPE,NSPE)
      DOUBLE PRECISION,INTENT(IN) :: REPCOEFF(6,MXINT,NSPE,NSPE)
      DOUBLE PRECISION,INTENT(OUT):: DISTMAT(*)
      DOUBLE PRECISION,INTENT(IN) :: ZREF(NAT),QREF(NSPE)

      DOUBLE PRECISION,INTENT(OUT) :: EREP

      INTEGER :: I,J,K,L,SPE1,SPE2,NSEQ
      DOUBLE PRECISION :: VAL, X, X1, DIST, CI, CJ,TQ1,TQ2

      EREP = 0.0D+00
      DO I = 1, NAT
        SPE1 = ISPE(I)
        TQ1 = 1.0D+00 / QREF(SPE1)
        CI = ZREF(I)*TQ1
        DO J = 1, I-1
          SPE2 = ISPE(J)
          TQ2 = 1.0D+00 / QREF(SPE2)
          CJ = ZREF(J)*TQ2
          DIST = SQRT( (C(1,I)-C(1,J))**2
     &               + (C(2,I)-C(2,J))**2
     &               + (C(3,I)-C(3,J))**2 )
          CALL DFTB_CNVSQ(I,J,NSEQ)
          DISTMAT(NSEQ) = DIST
          IF (DIST.LT.1.0D-02) THEN
C         ----- VAL = 0.0 IF DISTANCE IS LESS THAN 0.01 AU
            VAL = 0.0D+00
          ELSE IF (DIST.GT.REPCUT(SPE1,SPE2)) THEN
C         ----- VAL = 0.0 IF DISTANCE IS MORE THAN CUTOFF
            VAL = 0.0D+00
          ELSE
            IF (DIST.LT.REPINTV(1,1,SPE1,SPE2)) THEN
C            --- SHORT RANGE REPULSIVE PART ---
              VAL = EXP(-REPSHORT(1,SPE1,SPE2)*DIST
     &                 + REPSHORT(2,SPE1,SPE2))
     &              + REPSHORT(3,SPE1,SPE2)
            ELSE
              DO K = 1, NUMREP(SPE1,SPE2)
                IF (DIST.GE.REPINTV(1,K,SPE1,SPE2)
     &              .AND. DIST.LE.REPINTV(2,K,SPE1,SPE2)) EXIT
              END DO
              VAL = REPCOEFF(1,K,SPE1,SPE2)
              X1  = DIST - REPINTV(1,K,SPE1,SPE2)
              X   = X1
              IF (K.LT.NUMREP(SPE1,SPE2)) THEN
C            --- MEDIUM RANGE REPULSIVE PART ---
                DO L = 2, 4
                  VAL = VAL + REPCOEFF(L,K,SPE1,SPE2) * X
                  X   = X * X1
                END DO
              ELSE
C            --- LONG RANGE REPULSIVE PART ---
                DO L = 2, 6
                  VAL = VAL + REPCOEFF(L,K,SPE1,SPE2) * X
                  X   = X * X1
                END DO
              END IF
            END IF
          END IF
          VAL = VAL * CI * CJ
C         WRITE (6,'(3I3,X,F14.7,X,F8.5)') I, J, K, VAL, DIST
          EREP = EREP + VAL
        END DO
      END DO

      RETURN

      END SUBROUTINE DFTB_EREP
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_DMTEIG
C>
C>    @brief Calculate energy-weighted density matrix
C>
C>    @details Calculate energy-weighted density matrix, with occupation
C>             number.  This is a copy of ...
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param VEC MO vector (C_{\mu i})
C>    @param OCC Occupation number
C>    @param EIG eigenvalue (or what we call orbital energy)
C>    @param M,N,LDV
C>          --- OUTPUT ---
C>    @param D energy-weighted density matrix
C>
C
      SUBROUTINE DFTB_DMTEIG(D,VEC,OCC,EIG,M,N,LDV)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION D(*),VEC(LDV,N),OCC(N),EIG(N)
C
      LOGICAL GOPARR,DSKWRK,MASWRK,PARALL3
C
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
C
C     GENERATE DENSITY MATRIX -D- IN THE AO BASIS, WHEN THE
C     FIRST -M- MOLECULAR ORBITALS IN -V- HAVE OCCUPATION
C     NUMBERS -X-.  THE DIMENSION OF -D- IS GIVEN BY -N-.
C     THUS, THE DENSITY MATRIX IS D = V * X * V-TRANSPOSE.
C
      L2 = (N*N+N)/2
      CALL VCLR(D,1,L2)
C
      PARALL3 = GOPARR  .AND.  M.GT.MXSQN3()
      IPCOUNT = ME - 1
C
      DO 100 K = 1,N
         IF(PARALL3) THEN
            IPCOUNT = IPCOUNT + 1
            IF (MOD(IPCOUNT,NPROC).NE.0) GO TO 100
         END IF
         IJ = 1
         DO I = 1,N
            CALL DAXPY(I,EIG(K)*OCC(K)*VEC(I,K),VEC(1,K),1,D(IJ),1)
            IJ = IJ + I
         ENDDO
  100 CONTINUE
C
      IF (PARALL3) CALL DDI_GSUMF(1,D,L2)
      RETURN

      END SUBROUTINE DFTB_DMTEIG
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_DMTOCC
C>
C>    @brief Calculate density matrix
C>
C>    @details Calculate density matrix with occupation number.
C>             Maybe this is faster than the default density matrix
C>             subroutine?
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param VEC MO vector (C_{\mu i})
C>    @param OCC Occupation number
C>    @param WORK work
C>    @param N,LDV
C>          --- OUTPUT ---
C>    @param D density matrix
C>
C
      SUBROUTINE DFTB_DMTOCC(D,VEC,OCC,WORK,N,LDV)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION D(*),VEC(LDV,N),OCC(N),WORK(N,N)
C
C     LOGICAL GOPARR,DSKWRK,MASWRK
C
C     COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK

      DOUBLE PRECISION, PARAMETER :: ONE = 1.0D+00, ZERO = 0.0D+00
C
C     GENERATE DENSITY MATRIX -D- IN THE AO BASIS, WHEN THE
C     FIRST -M- MOLECULAR ORBITALS IN -V- HAVE OCCUPATION
C     NUMBERS -X-.  THE DIMENSION OF -D- IS GIVEN BY -N-.
C     THUS, THE DENSITY MATRIX IS D = V * X * V-TRANSPOSE.
C
      L2 = (N*N+N)/2
      L3 = N*N
      CALL VCLR(D,1,L2)
      CALL VCLR(WORK,1,L3)
C
C
      DO I = N, 1, -1
        MAXIND = I
        IF (OCC(I).GT.1.0D-08) EXIT
      END DO
C
      DO I = 1, MAXIND
        !! A : EIGVEC
        !! X : OCC
        !! ALPHA = 1.0
        !! BETA  = 0.0
        CALL DSCAL(LDV,SQRT(OCC(I)),VEC(1,I),1)
      END DO
C
      !! VEC :: EIGENVECTORS
      !! D   :: DENSITY MATRIX
      CALL DSYRK('L','N',N,MAXIND,ONE,VEC,N,ZERO,WORK,N)
      CALL CPYSQT(WORK,D,N,1)
C
      DO I = 1, MAXIND
        CALL DSCAL(LDV,1.0D+00/SQRT(OCC(I)),VEC(1,I),1)
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_DMTOCC
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_GAM2
C>
C>    @brief Calculate DFTB2 gamma
C>
C>    @details Calculate gamma values for DFTB2
C>               Gamma_{AB} = 1/R - S(Ua,Ub,R)
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>    @param DIST distance between A-B
C>    @param VALUE Temporary matrix made before calling this function.
C>    @param DAMPXH Whether X-H damping is used or not
C>    @param DAMPXHE Exponent for X-H damping
C>    @param SPE1,SPE2 Characters of A and B (Used when DAMPXH=.TRUE.)
C>
C
      DOUBLE PRECISION FUNCTION DFTB_GAM2(DIST,VALUE,
     * DAMPXH,DAMPXHE,SPE1,SPE2)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: DIST,VALUE(12),DAMPXHE,SPE1,SPE2
      LOGICAL :: DAMPXH
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00
      DOUBLE PRECISION, PARAMETER :: DISTTOL=1.0D-08,HUBTOL=1.0D-04
C
      DOUBLE PRECISION :: TAUA,TAUB,TAUMEAN,DISTI,TAUAB3I,TMP
      DOUBLE PRECISION H/8HH       /
C
      DFTB_GAM2 = ZERO
      TAUA = VALUE(1)
      TAUB = VALUE(2)
      IF (DIST.LE.DISTTOL) THEN
        DFTB_GAM2 = VALUE(12)
        RETURN
      ELSE IF (ABS(TAUA-TAUB).LE.HUBTOL) THEN
        TAUMEAN = VALUE(3)
        DISTI = ONE / DIST
        DFTB_GAM2 = exp(-TAUMEAN*DIST)
     &  * (DISTI + VALUE(4) + VALUE(5)*DIST + VALUE(6)*(DIST**2))
      ELSE
        DISTI = ONE / DIST
        TAUAB3I = DISTI * VALUE(11)
        DFTB_GAM2 = EXP(-TAUA*DIST) * (VALUE(7) - VALUE( 9)*TAUAB3I)
     &            + EXP(-TAUB*DIST) * (VALUE(8) + VALUE(10)*TAUAB3I)
      END IF
C
      IF (DAMPXH) THEN
        IF (SPE1.EQ.H.OR.SPE2.EQ.H) THEN
          TMP = VALUE(12)**DAMPXHE
          DFTB_GAM2 = DFTB_GAM2 * EXP(-TMP*(DIST**2))
        END IF
      END IF
C
      DFTB_GAM2 = DISTI - DFTB_GAM2
C
      RETURN
C
      END FUNCTION DFTB_GAM2
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_GAM3
C>
C>    @brief Calculate DFTB3 gamma
C>
C>    @details Calculate gamma values for DFTB3 (only for FMO?)
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>    @param DIST distance between A-B
C>    @param VAL1,VAL2 \Gamma_{AB} and \Gamma{BA}
C>    @param HUBA,HUBB Hubbard values of atom A and B
C>    @param VALUE1,VALUE2 Temporary array made before calling it
C>    @param DAMPXH Whether X-H damping is used or not
C>    @param DAMPXHE Exponent for X-H damping
C>    @param SPE1,SPE2 Characters of A and B (Used when DAMPXH=.TRUE.)
C>
C
      SUBROUTINE DFTB_GAM3(DIST,VAL1,VAL2,HUBA,HUBB,VALUE1,VALUE2,
     * DAMPXH,DAMPXHE,SPE1,SPE2)
C
      IMPLICIT NONE
C
      DOUBLE PRECISION :: DIST,VAL1,VAL2,HUBA,HUBB,VALUE1(10),
     * VALUE2(10),DAMPXHE,SPE1,SPE2

      LOGICAL :: DAMPXH
C
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00,ONE=1.0D+00,
     * HALF=5.0D-01
      DOUBLE PRECISION, PARAMETER :: HUBTOL=1.0D-04
C
      DOUBLE PRECISION :: TAUA,TAUB,EXPA,EXPB,DIST2,DIST3,DISTI,
     * DSAB_DR,DSBA_DR,DFAB_DA,DFBA_DA,DFAB_DB,DFBA_DB,FAB,FBA,HUBMEAN,
     * HUBMEANEXP,HUBMEANEXP1,EXPH,SAB,SBA,DH_DU
      DOUBLE PRECISION H/8HH       /
C
      VAL1 = ZERO
      VAL2 = ZERO
      TAUA = VALUE1(1)
      TAUB = VALUE1(2)
      EXPA = EXP(-TAUA*DIST)
      EXPH = ONE
      DH_DU = ZERO
      IF (DIST.LE.1.0D-08) THEN
        VAL1 = HALF
        VAL2 = HALF
        RETURN
      END IF
      IF (DAMPXH) THEN
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          !! DS^g/Da
          DIST2 = DIST**2
          DIST3 = DIST2*DIST
          DSAB_DR = EXPA*(VALUE1(3)+VALUE1(4)*DIST
     *      + VALUE1(5)*DIST2+VALUE1(6)*DIST3)
          IF (SPE1.EQ.H.OR.SPE2.EQ.H) THEN
            DISTI = ONE/DIST
            HUBMEAN = HALF*(HUBA+HUBB)
            HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
            HUBMEANEXP = HUBMEANEXP1*HUBMEAN
            EXPH = EXP(-(HUBMEAN**DAMPXHE)*DIST2)
            SAB = EXPA * (DISTI + VALUE1(7) +
     `        VALUE1(8)*DIST + VALUE1(9)*DIST2)
            DH_DU = -DIST2*DAMPXHE*HUBMEANEXP1*EXPH*HALF
          END IF
          VAL1 = -(DSAB_DR*EXPH*3.2D+00+SAB*DH_DU)
          VAL2 = VAL1
        ELSE
          EXPB = EXP(-TAUB*DIST)
          DISTI = ONE/DIST
          !! DS^f/Da
          DFAB_DA = VALUE1(3)+VALUE1(4)*DISTI
          FAB = VALUE1(5)+VALUE1(6)*DISTI
          DFBA_DA = VALUE1(7)+VALUE1(8)*DISTI
          FBA = VALUE1(9)+VALUE1(10)*DISTI
          DFAB_DB = VALUE2(7)+VALUE2(8)*DISTI
          DFBA_DB = VALUE2(3)+VALUE2(4)*DISTI
          DSAB_DR = EXPA*(DFAB_DA-DIST*FAB)+EXPB*DFBA_DA
          DSBA_DR = EXPB*(DFBA_DB-DIST*FBA)+EXPA*DFAB_DB
          IF (SPE1.EQ.H.OR.SPE2.EQ.H) THEN
            DIST2 = DIST**2
            HUBMEAN = HALF*(HUBA+HUBB)
            HUBMEANEXP1 = HUBMEAN**(DAMPXHE-ONE)
            HUBMEANEXP = HUBMEANEXP1*HUBMEAN
            EXPH = EXP(-HUBMEANEXP*DIST2)
            SAB = EXPA*FAB + EXPB*FBA
            SBA = SAB
            DH_DU = -DIST2*DAMPXHE*HUBMEANEXP1*EXPH*HALF
          END IF
          VAL1 = -(DSAB_DR*EXPH*3.2D+00+SAB*DH_DU)
          VAL2 = -(DSBA_DR*EXPH*3.2D+00+SBA*DH_DU)
        END IF
      ELSE !! WITHOUS H DAMPING
        IF (ABS(HUBA-HUBB).LE.HUBTOL) THEN
          !! DS^g/Da
          DIST2 = DIST**2
          DIST3 = DIST2*DIST
          DSAB_DR = EXPA*(VALUE1(3)+VALUE1(4)*DIST
     *      + VALUE1(5)*DIST2+VALUE1(6)*DIST3)
          VAL1 = -DSAB_DR*3.2D+00
          VAL2 = VAL1
        ELSE
          EXPB = EXP(-TAUB*DIST)
          DISTI = ONE/DIST
          !! DS^f/Da
          DFAB_DA = VALUE1(3)+VALUE1(4)*DISTI
          FAB = VALUE1(5)+VALUE1(6)*DISTI
          DFBA_DA = VALUE1(7)+VALUE1(8)*DISTI
          FBA = VALUE1(9)+VALUE1(10)*DISTI
          DFAB_DB = VALUE2(7)+VALUE2(8)*DISTI
          DFBA_DB = VALUE2(3)+VALUE2(4)*DISTI
          DSAB_DR = EXPA*(DFAB_DA-DIST*FAB)+EXPB*DFBA_DA
          DSBA_DR = EXPB*(DFBA_DB-DIST*FBA)+EXPA*DFAB_DB
          VAL1 = -DSAB_DR*3.2D+00
          VAL2 = -DSBA_DR*3.2D+00
        END IF
      END IF
C
      RETURN
C
      END SUBROUTINE DFTB_GAM3
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_SHIFT_ATOSH
C>
C>    @brief Convert atom-resolved to shell-resolved
C>
C>    @details Convert atom-resolved to shell-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param INPUT Atom-resolved values
C>    @param NAT Number of atoms
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param OUTPUT Shell-resolved values
C>
C
      SUBROUTINE DFTB_SHIFT_ATOSH(INPUT,OUTPUT,NAT,NSHELL,NSPE,ISPE,
     *  MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NSHELL,NSPE
      DOUBLE PRECISION, INTENT(IN) :: INPUT(NAT)
      DOUBLE PRECISION, INTENT(INOUT) :: OUTPUT(NSHELL)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(NSPE)
C
      INTEGER :: I,J,ISH
      DOUBLE PRECISION :: TMP
C
      ISH = 0
      DO I = 1, NAT
        TMP = INPUT(I)
        DO J = 1, MAXANG(ISPE(I))
          ISH = ISH + 1
          OUTPUT(ISH) = TMP
        END DO
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SHIFT_ATOSH
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_SHIFT_SHTOA
C>
C>    @brief Convert shell-resolved to atom-resolved
C>
C>    @details Convert shell-resolved to atom-resolved.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>           --- INPUT ---
C>    @param INPUT Shell-resolved values
C>    @param NAT Number of atoms
C>    @param NSHELL Number of shells
C>    @param NSPE Number of species
C>    @param ISPE Index of species
C>    @param MAXANG Maximum angular momentum of each species
C>           --- OUTPUT ---
C>    @param OUTPUT Atom-resolved values
C>
C
      SUBROUTINE DFTB_SHIFT_SHTOA(INPUT,OUTPUT,NAT,NSHELL,NSPE,ISPE,
     *  MAXANG)
C
      IMPLICIT NONE
C
      INTEGER, INTENT(IN) :: NAT,NSHELL,NSPE
      DOUBLE PRECISION, INTENT(IN) :: INPUT(NSHELL)
      DOUBLE PRECISION, INTENT(INOUT) :: OUTPUT(NAT)
      INTEGER, INTENT(IN) :: ISPE(NAT),MAXANG(NSPE)
C
      INTEGER :: I,J,ISH
      DOUBLE PRECISION :: TMP
      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00
C
      ISH = 0
      DO I = 1, NAT
        TMP = ZERO
        DO J = 1, MAXANG(ISPE(I))
          ISH = ISH + 1
          TMP = TMP + INPUT(ISH)
        END DO
        OUTPUT(I) = TMP
      END DO
C
      RETURN
C
      END SUBROUTINE DFTB_SHIFT_SHTOA
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_NCCMAT
C>
C>    @brief Calculate charge-independent quantity
C>
C>    @details Calculate non-charge consistent (NCC) DFTB quantity.
C>             This subroutine constructs Hamiltonian and overlap
C>             matrix and Q matrix.  If FMO-DFTB, calculates ESP
C>             contribution (DFTB_ESP), too.
C>             This is mostly a copy of ONEEI subroutine.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C
      SUBROUTINE DFTB_NCCMAT

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      INTEGER,PARAMETER :: MXATM=5000, MXSPE=10!, MXAO=2047
      INTEGER,PARAMETER :: MXGTOT=5000, MXSH=1000

      DOUBLE PRECISION, PARAMETER :: ZERO=0.0D+00

      LOGICAL SOME,DBUG,GOPARR,DSKWRK,MASWRK,EFLDL,
     *        DOESP,DOESP0,DOESP1,DOESP2,DOHOP,DOHOP2,ADDESP,
     *        DOPCM,DOVLMO,DOEFP!,DOREP
      LOGICAL DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB,outpcm
      dimension idamdt(3)
C
      COMMON /DFTB  / DFTBFL,SCC,SRSCC,DFTB3,DAMPXH,LRDFTB
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      COMMON /EFLDC / EVEC(3),EFLDL
      COMMON /FMCOM / X(1)
      COMMON /FMODIM/ MAXBND,MAXKND,MAXCBS,MAXCAO,MAXVEC,MAXL1,MAXNAT,
     *                MAXABD,MAXBAS,MAXBBD,MAXLMO,MAXSLO,MAXABD2
      COMMON /FMOINF/ NFG,NLAYER,NATFMO,NBDFG,NAOTYP,NBODY
      COMMON /FMOOPT/ ESPSCA(9),RESPAP(2),RESPPC(2),RESDIM,RESTRI(4),
     *                RCORSD,RESPCT,CONVFG,CNVDMP,COROFF,RFLMO(4),
     *                ORSHFT,ORSHFT2,CNVAFO,ASCREEN(4),IXESP,MXITFG,
     *                NGUESS,NBSSE,MODORB,MODPAR,IRSTSTP,IRSTLAY,NPRFMO,
     *                NFMOPAL,MODPRP,MAXL1C,IPIEDA,MODGRD,MODESP,IVMUL,
     *                MODLMO,NOPDEN,MOFOCK,MODFD,modfmm,ncentm,ndualb
      common /fmopnt/ lichfg,lmulfg,lidmrec,lfrgnam,llayfrg,lindat,
     *                lnCBS,lfmozan,lfmoc,lfmomas,lizbas,liaglob,libdgh,
     *                liabdfg,ljabdfg,lnCAO,lidxCAO,liaprjo,ljaprjo,
     *                lCoreAO,lOccCor,lshiftb,liodfmo,lfmoda,lfmodb,
     *                lfmoespa,lfmoespb,llocfmo,lscffrg,lfmoscf,lrij,
     *                lpopmul,lpopmat,lialoc,lindbd,liatfrg,lindfrg,
     *                lindgfrg,lnatfrg,lnat0frg,lianfrg,lzanfrg,lcfrg,
     *                llibish,llibnsh,llibng,lindatg,lfmobuf(3),lfmode,
     *                lnumfrg,lloctat,liaoglob,lloadm,lfmoge,ldgrid,
     *                liodcfmo,ljob2grp,lfmopg,lemocdr,luntxyz,luntrot,
     *                lstonep,lmapsu,lfrgmul,lclmo,lialmo,lindlmo,
     *                latclmo,llmobdf,lfgflmo,lnfglmo,llfglmo,lpfglmo,
     *                LPOPDMAT,lidmpnt,liddpnt,livmpnt,liactfg,lcrfrg,
     *                lzlmfrgv,lYlmfrgv,lndtfrg,lf_mm,lg_mm
      COMMON /FMORUN/ ESPSCF,E0SCF(2),EMP2S,IDAFMO,ICURFG,JCURFG,KCURFG,
     *                ICURLAY,ICURUNT,NAT1E,NCURSH,NGAU,ICURPOP,IFMOSTP,
     *                MONCOR,NEEDR,MODRST,NORBPROJ,NUNESP,ISKIPESP,
     *                IESDPPC,IDOPROP,MP2RUN,ICURIT,IDMFMO,IDDFMO,
     *                IDDCUR,NDDLEFT,IVMFMO,nzmtfmo,ifmobas
C     COMMON /FRGINF/ NMPTS(MXFRG),NMTTPT,IEFC,IEFD,IEFQ,IEFO,
C    *                NPPTS(MXFRG),NPTTPT,IEFP,
C    *                NRPTS(MXFRG),NRTTPT,IREP,ICHGP,NFRG,
C    *                NDPPTS(MXDPPT),NDPTTPT,IEFDP,LSTMPTS(MXFRG),
C    *                NBSFN(MXFRG),NMXMO(MXFRG)
      COMMON /FMODTB/ LGAMMA,LZREF,LISPE,LSHIFTG,LSHIFTCT,
     *                LGAMMAD,MODESD,MODGAMMA,LDCTMP,LGAMMA3,LGAMMA3D
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /NSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     *                CF(MXGTOT),CG(MXGTOT),CH(MXGTOT),CI(MXGTOT),
     *                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     *                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /OUTPUT/ NPRINT,ITOL,ICUT,NORMF,NORMP,NOPK
      COMMON /PAR   / ME,MASTER,NPROC,IBTYP,IPTIM,GOPARR,DSKWRK,MASWRK
      COMMON /PCMDIM/ MXSP,MXTS,MEMPCM1,MEMPCM2,NTS
      COMMON /PCMPNT/ LXYZRE,LSSFE,LLIST,LALPCM,LRINPCM,LINAPCM,LINFPCM,
     *                LINIPCM,LMEPCM,LAXYZCT,LXYZCT2,LNVERT,LQSN,LQSE,
     *                LQFS,LQIND,LISPHE,LVAD,LQOR,LVECMUL,LAIPRJ,LFIPRJ,
     *                LPEL,LPCMCDR,LDAI,LIDDAI,LQSND,LQSED
      common /ppcpnt/ lddijpot,lzppcpot,lvipot,lgrdtest
C     COMMON /RELWFN/ RMETHOD,QRQMT,CLIG,CLIG2,QRTOL,IQRORD,MODQR,NESOC,
C    *                NRATOM,NUMU,NQMTR,NQRDAF,MORDA,NDARELB
C     COMMON /RUNLAB/ TITLE(10),A(MXATM),B(MXATM),BFLAB(MXAO)
      COMMON /RUNOPT/ RUNTYP,EXETYP,NEVALS,NGLEVL,NHLEVL
      COMMON /SIMDAT/ NACC,NREJ,IGOMIN,NRPA,IBWM,NACCT,NREJT,NRPAT,
     *                NPRTGO,IDPUNC,IGOFLG
      COMMON /WFNOPT/ SCFTYP,VBTYP,DFTYPE,TDDFTYP,CITYP,CCTYP,
     *                MPLEVL,MPCTYP
      COMMON /ZRFPAR/ GZRF,FIND(3),GNUCF,EBORN,DIELEC,IZRF,ICALC
C
      DATA DEBUG/8HDEBUG   /,DBUGME/8HINT1    /
      DATA CHECK/8HCHECK   /
      DATA RMC/8HMCSCF   /,RNONE/8HNONE    /
C memo : RMETHOD -> relativistic correction

C
C     ---- ALLOCATE MEMORY -----
C     TAKEN FROM ONEEI SUBROUTINE IN int1.src
C
      SOME = MASWRK  .AND.  .NOT.(NPRINT.EQ.-5 .OR. NPRINT.EQ.-2183)
      DBUG = MASWRK  .AND.
     *       (NPRINT.EQ.3 .OR. EXETYP.EQ.DEBUG .OR. EXETYP.EQ.DBUGME)
C
      CALL SETLESP(DOESP,DOESP0,DOESP1,DOESP2,DOHOP,DOHOP2,DOPCM,ADDESP,
     *             DOVLMO,DOEFP)
C
      IF(SOME) WRITE (IW,9000)
      IF(SOME) CALL TSECND(T0)
C
      L0 = 0
      L1 = NUM           !! NUMBER OF ATOMIC ORBITALS
      L2 = (L1*L1+L1)/2  !! DIMENSION OF LOWER TRIANGLE
      L3 = L1*L1         !! NORB*NORB
C
      CALL VALFM(LOADFM)
      LH   = LOADFM + 1       !!
      LS   = LH     + L2      !! HAMILTONIAN
      LT   = LS     + L2      !! OVERLAP
      LV   = LT     + L2      !! KINETIC INTEGRAL => 0
      LQ   = LV     + L3      !! WORK DIRECTRY IN QMTSYM
      LWRK = LQ     + L3      !! FOR TRANSFORMATION MATRIX
      LE   = LWRK   + L2      !! USED IN FMOHOP
      LSCR = LE     + L1      !! TEMPORARY IN QMTSYM
      LIWRK= LSCR   + L1*8    !! TEMPORARY IN QMTSYM
      LRI  = LIWRK  + L1      !! TEMPORARY IN QMTSYM
      LHP  = LRI    + L3      !! TEMPORARY IN QMTSYM
      LRI2 = LHP    + L2      !! HOP CONTRIBUTION OF HAMILTONICN
      LAST = LRI2   + NAT*NAT !! 1/R matrix

      IF(DOHOP) THEN
         LSS=LAST
         LDD=LSS+L1*L1
         LROTLCAO=LDD+(MAXCBS*MAXCBS+MAXCBS)/2
         last=LROTLCAO+MAXCBS*MAXCAO
      END IF
C
      NEED = LAST-LOADFM-1
      CALL GETFM(NEED)
C
      CALL VCLR(X(LH),1,L2)
      CALL VCLR(X(LS),1,L2)
C
C     ----- SUM UP PARTIAL CONTRIBUTIONS IF PARALLEL -----
C     canno use currently
C
C     IF (GOPARR) THEN
C       CALL DDI_GSUMF(910,X(LH),L2)
C       CALL DDI_GSUMF(911,X(LS),L2)
C     END IF
C
C     ----- NOW, CONSTRUCT NCC-HAMILTONIAN AND OVERLAP
C
      IF (MASWRK.AND.SOME) WRITE (IW,*) " NUMBER OF ATOMIC ORBITALS:",L1
      CALL DFTB_HAM_OVER(1,NAT,X(LH),X(LS),.TRUE.,.TRUE.)
C
C     ----- OPTIONAL DEBUG PRINTOUT -----
C
      IF (MASWRK.AND.DBUG) THEN
        WRITE (IW,*) "OVERLAP MATRIX"
        CALL PRTRIL(X(LS),L1)
        WRITE (IW,*) "NCC HAMILTONIAN"
        CALL PRTRIL(X(LH),L1)
      END IF
C
C     ----- ZERO-FILL FOR KINETIC INTEGRAL ----
C
      CALL VCLR(X(LT),1,L2)
C
C     ----- SAVE H AND S MATRICES ON THE DAF -----
C
      IF (NFG.GT.0 .AND. SCC) CALL DAWRIT(IDAF,IODA,X(LH),L2,564,0)
      CALL DAWRIT(IDAF,IODA,X(LH),L2,11,0)
      CALL DAWRIT(IDAF,IODA,X(LS),L2,12,0)
      CALL DAWRIT(IDAF,IODA,X(LT),L2,13,0)
C
C     ----- SAVE INITIAL GUESS AND EIGENVALUES OR ORBITALS, BUT ZERO VALUE-----
C
C     IF (IODA(15).EQ.-1) CALL DAWRIT(IDAF,IODA,X(LQ),L3,15,0)
      CALL VCLR(X(LQ),1,L3)
C     IF (IODA(15).EQ.-1.AND.NFG.NE.0)
C    *   CALL DAWRIT(IDAF,IODA,X(LQ),L3,15,0)
C     WRITE (IW,*) "INITIALIZATION IN nccmat.src IS TURNED OFF"
c     CALL DAWRIT(IDAF,IODA,X(LQ),L2,16,0)
      CALL DAWRIT(IDAF,IODA,X(LQ),L1,17,0)
C
C     ----- SAVE Q ON THE DAF, BUT HAS NONE -----
C       THIS IS CALLED SYMMETRY ADAPTED Q MATRIX
C
      CALL QMATRX(X(LS),X(LQ),X(LE),X(LSCR),X(LIWRK),L0,L1,L1,
     & .FALSE.)
c     CALL QMTSYM(X(LS),X(LV),X(LQ),X(LE),X(LSCR),X(LIWRK),
c    *            L0,L1,L2,L3,.FALSE.)
      CALL DAWRIT(IDAF,IODA,X(LQ),L3,44,0)
      CALL DAWRIT(IDAF,IODA,X(LQ),L3,45,0)
      IF (DBUG) THEN
        WRITE (IW,*) "TRANSFORMATION MATRIX"
        CALL PRSQ(X(LQ),L1,L1,L1)
      END IF
C
      IF (SOME) THEN
        CALL TSECND(T1)
        TCPU = T1 - T0
        T0 = T1
        WRITE(IW,9010) TCPU
      END IF
C
C     ----- DIPOLE INTEGRALS, AT COORDINATE ORIGIN -----
C     THE REASONING BEHIND DOING DIPOLE INTEGRALS FOR MCSCF IS IN CASE
C     SOMEONE DOES STATE-AVERAGED MCSCF ON DIFFERENT ENERGIES SO THAT
C     THE PROPERTY CODE SKIPS OUT, BUT WHERE ONE MIGHT WANT TO DO A
C     BOYS LOCALIZATION THAT REQUIRES THESE INTEGRALS.  IT IS HARD TO
C     TEST FOR THIS SOMEWHAT ODD CONDITION, SO JUST DO THE INTEGRALS.
C
      IF(EFLDL  .OR.  IZRF.EQ.1  .OR.  SCFTYP.EQ.RMC) THEN
         CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
         CALL DFTB_DIPINT(IND,ZERO,ZERO,ZERO,X(LS),DBUG)
         IF(SOME) THEN
            CALL TSECND(T1)
            TCPU = T1 - T0
            T0 = T1
            WRITE(IW,9030) TCPU
         END IF
      END IF
C
C     ----- CALCULATE CENTER OF MASS WITH FRAGMENTS ----
C
!     IF(NFRG.GT.0) CALL EFCM
C
C     ----- EFFECTIVE FRAGMENT INTEGRALS -----
C           CHARGE-CHARGE INTEGRALS
C           CHARGE-DIPOLE INTEGRALS
C           CHARGE-QUADRUPOLE INTEGRALS
C           CHARGE-OCTUPOLE INTEGRALS
C           CHARGE-POLARIZABLE POINTS INTEGRALS
C           CHARGE-REPULSIVE POTENTIAL INTEGRALS
C
      IF(EXETYP.EQ.CHECK) GO TO 800
C     IF(SKIPEFP) GOTO 700
C
C     IF (DOEFP) THEN
c     call stopwa(6,0)
C
C     IF (NFRG.GT.0) THEN
C        CALL VCLR(X(LH),1,L2)
C        CALL DAWRIT(IDAF,IODA,X(LH),L2,89,0)
C     END IF
C     IF(NBUFMO.GT.0)THEN
C       CALL DAREAD(IDAF,IODA,X(LH),L2,11,0)
C       CALL DAWRIT(IDAF,IODA,X(LH),L2,319,0)
C       CALL VCLR(X(LH),1,L2)
C     END IF
C     IF(DOESP2.AND.IVMUL.GT.1) CALL SETVSKIP(X(LNATFRG),X(LUNTXYZ),
C    *                                        X(LINDVMUL))
C     IF(IEFC.EQ.1) CALL EFCINT(X(LWRK),X(LH))
C     IF(IEFD.EQ.1.OR.DOESP2.AND.IVMUL.GT.1) CALL EFDINT(X(LWRK),X(LH),
C    *                X(LUNTXYZ),X(LVMUL),LDAV,X(LINDVMUL),X(LFMOESPB))
C     IF(IEFQ.EQ.1.OR.DOESP2.AND.IVMUL.GT.2) CALL EFQINT(X(LWRK),X(LH),
C    *                X(LUNTXYZ),X(LVMUL),LDAV,X(LINDVMUL),X(LFMOESPB))
C     IF(IEFO.EQ.1.OR.DOESP2.AND.IVMUL.GT.3) CALL EFOINT(X(LWRK),X(LH),
C    *                X(LUNTXYZ),X(LVMUL),LDAV,X(LINDVMUL),X(LFMOESPB))
C     IF(IEFP.EQ.1) CALL POLINT(X(LWRK),X(LS),X(LT),L2)
C     IF(IEFP.EQ.1) THEN
C       IF (IEFPFMO.EQ.2) THEN
C         CALL DRCTPOLWRP(L1,L2,X(LH),X(LWRK),X(LS),X(LT))
C       ELSE
C         CALL POLINT(X(LWRK),X(LS),X(LT),L2)
C       END IF
C     END IF
C
C     IF(IREP.EQ.1) CALL REPINT(X(LWRK),X(LH),DOREP)
C     IF(IEFF.GT.0  .AND.  SOME) THEN
C        CALL TSECND(T1)
C        TCPU = T1 - T0
C        T0 = T1
C        WRITE(IW,9040) TCPU
C     END IF
c     call stopwa(6,1)
C     END IF
C 700 CONTINUE
C
C     FRAGMENT MOLECULAR ORBITAL METHOD:
C     HO PROJECTOR AND ELECTROSTATIC POTENTIAL (ESP).
C     (SOME HIDDEN ARGUMENTS SHOULD BE SET SOMEWHERE BEFORE).
C
      call stopwa(7,0)
      outpcm=iand(nprfmo,3).eq.0
      IF(DOPCM) CALL PCMPOT(X(LH),X(LWRK),NTS,X(LQSE),X(LAXYZCT),L2,0,
     *                      outpcm)
      call stopwa(7,1)
      IF(NFG.NE.0) CALL DCOPY(L2,X(LH),1,X(LHP),1)
      call viclr(idamdt,1,3)
      IF(DOHOP) CALL FMOHOP(L1,L2,X(LH),X(LS),X(LSS),X(LQ),X(LDD),
     *            X(LSCR),X(LT),X(LWRK),X(LIABDFG),X(LJABDFG),X(LIDXCAO)
     *            ,X(LIAGLOB),X(LNCBS),X(LNCAO),X(LIAPRJO),X(LJAPRJO),
     *             X(LSHIFTB),X(LCOREAO),X(LFMOC),X(LROTLCAO),
     *             X(LLOCFMO),NSHELL,KATOM,KTYPE,KLOC,KMIN,.TRUE.,
     *             .FALSE.,rnone,idamdt)
      IF(DOHOP2) CALL FMOHOPQO(L1,L2,X(LH),X(LS),X(LFMODA),X(LFMOBUF(1))
     *                       ,X(LLAYFRG),X(LSCFFRG),X(LNUMFRG)
     *                       ,X(LIODFMO),X(LIDMREC),X(LLOADM))
      CALL DAREAD(IDAF,IODA,X(LH),L2,11,0)
      IF (NFG.NE.0) THEN
        CALL DAXPY(L2,-1.0D+00,X(LH),1,X(LHP),1)
        CALL DAWRIT(IDAF,IODA,X(LHP),L2,565,0)
      END IF
      call stopwa(8,0)
c     IF(DOESP)CALL FMOESP(L1,L2,X(LH),X(LLAYFRG),X(LSCFFRG),X(LIDMREC))
c     IF(DOESP) call vclr(x(lfmoespa),1,l2)  !! it must be skipped for non-ESP calculation
      if(doesp) then
         if(scc) then
           CALL DAREAD(IDAF,IODA,X(LS),L2,12,0)
           lpopmati=lpopmat+(maxnat*nfg)*(icurpop-1)
           call dcopy(l2,x(lh),1,x(lfmoespa),1)
           call dscal(l2,-1.0D+00,x(lfmoespa),1)
CD         call DFTB_ESP(x(llayfrg),X(LIAGLOB),X(LNATFRG),X(LINDFRG),
           call DFTB_ESP(X(LIAGLOB),X(LNATFRG),X(LINDFRG),
     *                  X(LIATFRG),x(lpopmati),X(LS),X(LH),X(LISPE),
     *                  X(LFMOC),X(LGAMMA3))
           call daxpy(l2,1.0D+00,x(lh),1,x(lfmoespa),1)
           call dcopy(l2,x(lfmoespa),1,x(lfmoespb),1)
           !! TENTATIVELY HERE SOMEHOW DICTIONARY 11 IS DESTOIED AND CANNOT PERFORM NORMAL CALCULATIONS
           CALL DAWRIT(IDAF,IODA,X(LH),L2,11,0)
         else
           call vclr(x(lfmoespa),1,l2)
        endif
      endif
      call stopwa(8,1)
c
c     variational FMO; contribution to Fock
c
      if (doesp.and.iand(modesp,512).ne.0.and.ifmostp.ge.2) then
        IOLDPOP = 3 - ICURPOP
        LPOTCUR = LVIPOT+(ICURPOP-1)*MAXNAT*NFG
        LPOTOLD = LPOTCUR
        IF (IFMOSTP.GE.4) LPOTOLD = LVIPOT+(IOLDPOP-1)*MAXNAT*NFG
        CALL dltcnt2esp(L2,X(LIAGLOB),X(LIALOC),X(LFMOESPA),X(LWRK),
     *                  X(LH),X(LPOTCUR),X(LPOTOLD),X(LS))
      end if
      IF(ADDESP) THEN
C       CALL DAREAD(IDAF,IODA,X(LH),L2,11,0)
C       CALL DAXPY(L2,ONE,X(LFMOESPA),1,X(LH),1)
C       CALL DAWRIT(IDAF,IODA,X(LH),L2,11,0)
      ELSE IF(NFG.NE.0.AND..NOT.DOESP.AND..NOT.DOESP1.AND..NOT.DOESP0)
     *  THEN
        CALL VCLR(X(LFMOESPA),1,L2)
      ENDIF
C
C     ----- DONE WITH INTEGRALS -----
C
  800 CONTINUE

C AAD WRITE STATIC INTEGRALS TO A PROTECTED AREA FOR EFP.
      CALL DAWRIT(IDAF,IODA,X(LH),L2,87,0)
      CALL RETFM(NEED)
C
C     PRINT TIMING INFO --- AVOID DURING MONTE CARLO, FMO, ...
C
      IF(MASWRK .AND. NPRTGO.NE.2  .AND.  NPRINT.NE.-2183 .AND.
     * (NFG.EQ.0.OR.(IFMOSTP.NE.6.AND.NPRINT.NE.-5))) THEN
         WRITE(IW,9090)
         CALL TIMIT(1)
      END IF
      RETURN
C
 9000 FORMAT(/10X,30(1H*)/10X,'CONSTRUCT NCC-DFTB HAMILTONIAN'
     &       /10X,30(1H*))
 9010 FORMAT(1X,'TIME TO DO NCC-DFTB HAMILTONIAN=',F10.2)
 9030 FORMAT(1X,'TIME TO DO   DIPOLE INTEGRALS=',F10.2)
 9090 FORMAT(1X,'...... END OF NCC-DFTB PREPARATION ......')

      END SUBROUTINE DFTB_NCCMAT
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_HAM_OVER
C>
C>    @brief Calculate Hamiltonian and overlap matrix
C>
C>    @details Calculate Hamiltonian and overlap matrix elements.
C>             This calculates only zeroth order values.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>    @param NSTART,NLAST lower and upper limit for atom index
C>    @param H,S Hamiltonian and overlap matrices
C>    @param THAM Whether Hamiltonian is calculated.
C>    @param TOVER Whether overlap is calculated.
C>
C
      SUBROUTINE DFTB_HAM_OVER(NSTART,NLAST,H,S,THAM,TOVER)
C
      IMPLICIT NONE
C
      INTEGER,PARAMETER :: MXATM=5000, MXSPE=10, MXTAB=1500, MXINT=150
C
      COMMON /DFTBPR/ ETEMP,DFTBDP(MXSPE*14),DAMPXHE,HUBDER(MXSPE),
     *                SPE(MXATM),NSPE,MAXANG(MXATM),ISPE(MXATM),
     *                IND(MXATM+1),IDFTBD
      DOUBLE PRECISION :: ETEMP,DFTBDP,DAMPXHE,HUBDER,SPE
      INTEGER :: NSPE,MAXANG,ISPE,IND,IDFTBD
      COMMON /DFTBSK/ SKHTAB(10,MXTAB,MXSPE,MXSPE),
     &                SKSTAB(10,MXTAB,MXSPE,MXSPE),SKSELF(3,MXSPE),
     &                SKGRID(MXSPE,MXSPE),SKDIM(MXSPE,MXSPE),
     *                SKSPIN(MXSPE),REPCOEFF(6,MXINT,MXSPE,MXSPE),
     *                REPINTV(2,MXINT,MXSPE,MXSPE),
     &                REPSHORT(3,MXSPE,MXSPE),REPCUT(MXSPE,MXSPE),
     &                QREFL(3,MXSPE),HUBBL(3,MXSPE),QREF(MXSPE),
     &                HUBB(MXSPE),SKCUT2,ZREF(MXATM),SPNCST(6,MXSPE),
     *                NUMREP(MXSPE,MXSPE)
      DOUBLE PRECISION :: SKHTAB,SKSTAB,SKSELF,SKGRID,SKDIM,SKSPIN,
     &  HUBBL,QREFL,REPCUT,REPINTV,REPSHORT,REPCOEFF,QREF,HUBB,SKCUT2,
     &  ZREF,SPNCST
      INTEGER :: NUMREP
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      INTEGER :: NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,IAN
      DOUBLE PRECISION :: ZAN,C
C
      INTEGER, INTENT(IN) :: NSTART,NLAST
      DOUBLE PRECISION,INTENT(OUT) :: H(*),S(*)
      LOGICAL,INTENT(IN) :: THAM,TOVER
C
      INTEGER :: I,J,K,L,M,N,NSEQ
      DOUBLE PRECISION :: VEC(3),AU(9,9),BU(9,9)
      LOGICAL :: SKP
C
      DO I = NSTART, NLAST
        DO J = NSTART, I
          VEC(1) = C(1,J) - C(1,I)
          VEC(2) = C(2,J) - C(2,I)
          VEC(3) = C(3,J) - C(3,I)
          CALL VCLR(AU,1,81)
          CALL VCLR(BU,1,81)
          !! USE NUMERICAL DERIVATIVE CODE
C         CALL DFTB_SKODE(ISPE(I),ISPE(J),MAXANG(ISPE(I)),
C    &      MAXANG(ISPE(J)),VEC(1:3),SKGRID(ISPE(I),ISPE(J)),
C    &      SKGRID(ISPE(J),ISPE(I)),SKDIM(ISPE(I),ISPE(J)),
C    &      SKDIM(ISPE(J),ISPE(I)),
C    &      SKHTAB(1:10,1:MXTAB,ISPE(I),ISPE(J)),
C    &      SKHTAB(1:10,1:MXTAB,ISPE(J),ISPE(I)),
C    &      SKSTAB(1:10,1:MXTAB,ISPE(I),ISPE(J)),
C    &      SKSTAB(1:10,1:MXTAB,ISPE(J),ISPE(I)),
C    &      SKSELF(1:3,ISPE(I)),SKCUT2,AU(1:9,1:9),BU(1:9,1:9),
C    *      THAM,TOVER)
          CALL DFTB_SKODEA(ISPE(I),ISPE(J),0,0,0,MAXANG(ISPE(I)),
     &      MAXANG(ISPE(J)),VEC(1:3),SKGRID(ISPE(I),ISPE(J)),
     &      SKGRID(ISPE(J),ISPE(I)),SKDIM(ISPE(I),ISPE(J)),
     &      SKDIM(ISPE(J),ISPE(I)),
     &      SKHTAB(1:10,1:MXTAB,ISPE(I),ISPE(J)),
     &      SKHTAB(1:10,1:MXTAB,ISPE(J),ISPE(I)),
     &      SKSTAB(1:10,1:MXTAB,ISPE(I),ISPE(J)),
     &      SKSTAB(1:10,1:MXTAB,ISPE(J),ISPE(I)),
     &      SKSELF(1:3,ISPE(I)),SKCUT2,AU(1:9,1:9),BU(1:9,1:9),
     *      THAM,TOVER,SKP)
          IF (SKP) CYCLE
          DO K = 1, IND(J+1) - IND(J)
            N = IND(J)+K-IND(NSTART)
            DO L = 1, IND(I+1) - IND(I)
              M = IND(I)+L-IND(NSTART)
              CALL DFTB_CNVSQ(M,N,NSEQ)
              IF (THAM)  H(NSEQ) = AU(L,K)
              IF (TOVER) S(NSEQ) = BU(L,K)
            END DO
          END DO
        END DO
      END DO
c     call prtril(S,num)
C
      RETURN
C
      END SUBROUTINE DFTB_HAM_OVER
C
C-----------------------------------------------------------------------
C*MODULE DFTBLB    *DECK DFTB_DIPINT
C>
C>    @brief Calculate dipole integrals for DFTB
C>
C>    @details Calculate dipole integrals for DFTB in an approximate
C>             way. See the reference shown below.
C>             This is a copy of DIPINT subroutine.
C>
C>    @author Yoshio Nishimoto
C>    - Sep, 2014- Subroutine written
C>
C>    @param IND Index of atomic orbitals
C>    @param XC,YC,ZC Origin?
C>    @param S Overlap matrix
C>    @param DBUG Debug?
C
      SUBROUTINE DFTB_DIPINT(IND,XC,YC,ZC,S,DBUG)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INTEGER IND(*)
      DOUBLE PRECISION S(*)
      LOGICAL DBUG
C
      PARAMETER (MXATM=5000)
C
      COMMON /FMCOM / X(1)
      COMMON /INFOA / NAT,ICH,MUL,NUM,NQMT,NE,NA,NB,
     *                ZAN(MXATM),C(3,MXATM),IAN(MXATM)
      COMMON /IOFILE/ IR,IW,IP,IJK,IJKT,IDAF,NAV,IODA(950)
      COMMON /XYZPRP/ XP,YP,ZP,
     *                DIPMX,DIPMY,DIPMZ,
     *                QXX,QYY,QZZ,QXY,QXZ,QYZ,
     *                QMXX,QMYY,QMZZ,QMXY,QMXZ,QMYZ,
     *                OXXX,OXXY,OXXZ,OXYY,OYYY,OYYZ,
     *                OXZZ,OYZZ,OZZZ,OXYZ,
     *                OMXXX,OMXXY,OMXXZ,OMXYY,OMYYY,
     *                OMYYZ,OMXZZ,OMYZZ,OMZZZ,OMXYZ
C
C     ----- CALCULATE DIPOLE INTEGRALS -----
C     AT REQUESTED ORIGIN, AND SAVE ON THE DAF FILE.
C
      XP = XC
      YP = YC
      ZP = ZC
C
C     SEE THE REFERENCE FOR THE CALCULATION OF DIPOLE INTEGRALS AT DFTB
C     - Barone, V; Carnimeo, I.; Scalmani, G.
C       J. Chem. Theory Comput. 2013, 9, 2052-2071.
C     CALCULATION OF DIPOLE INTEGRALS FOLLOWS EQ.(34) IN THE REF.
C
      L1 = NUM
      L2 = (L1*L1+L1)/2
C
      CALL VALFM (LOADFM)
      LX   = LOADFM + 1
      LY   = LX     + L2
      LZ   = LY     + L2
      LAST = LZ     + L2
      NEED = LAST - LOADFM - 1
      CALL GETFM(NEED)
C
      HALF = 0.5D+00
      DO KI = 1, 3
        IF(KI.EQ.1) THEN
          LXYZ = LX
          TMP = XP
        ELSE IF(KI.EQ.2) THEN
          LXYZ = LY
          TMP = YP
        ELSE IF(KI.EQ.3) THEN
          LXYZ = LZ
          TMP = ZP
        END IF
        DO NM = 1, NAT
          CMXYZ = C(KI,NM)-TMP
          DO M = 1, IND(NM+1)-IND(NM)
            MU = IND(NM)+M
            DO NN = 1, NM
              CNXYZ = C(KI,NN)-TMP
              DO N = 1, IND(NN+1)-IND(NN)
                NU = IND(NN)+N
                CALL DFTB_CNVSQ(MU,NU,NSEQ)
                X(LXYZ+NSEQ-1) = HALF*S(NSEQ)*(CMXYZ+CNXYZ)
              END DO
            END DO
          END DO
        END DO
      END DO
C
C         SAVE TO DISK, POSSIBLE PRINTOUT
C
      CALL DAWRIT(IDAF,IODA,X(LX),L2,95,0)
      CALL DAWRIT(IDAF,IODA,X(LY),L2,96,0)
      CALL DAWRIT(IDAF,IODA,X(LZ),L2,97,0)
C
      IF(DBUG) THEN
         WRITE(IW,*) 'DIPOLE ORIGIN=',XC,YC,ZC
         WRITE(IW,*) 'X DIPOLE INTEGRALS'
         CALL PRTRIL(X(LX),L1)
         WRITE(IW,*) 'Y DIPOLE INTEGRALS'
         CALL PRTRIL(X(LY),L1)
         WRITE(IW,*) 'Z DIPOLE INTEGRALS'
         CALL PRTRIL(X(LZ),L1)
      END IF
C
      CALL RETFM(NEED)
      RETURN
      END
